<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试经典 150 题-数学</title>
    <link href="/2025/03/07/posts/hot150-17/"/>
    <url>/2025/03/07/posts/hot150-17/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-数学"><a href="#LeetCode-面试经典-150-题-数学" class="headerlink" title="LeetCode 面试经典 150 题-数学"></a>LeetCode 面试经典 150 题-数学</h1><h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a><a href="https://leetcode.cn/problems/palindrome-number/description/?envType=study-plan-v2&envId=top-interview-150">回文数</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>反转整数，再进行比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// 边界处理，负数一定不是回文数</span><br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0l</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> x;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-number">0</span>) &#123;<br>            ans = ans * <span class="hljs-number">10</span> + cur % <span class="hljs-number">10</span>;<br>            cur = cur / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x == ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h3 id="反转一半数字"><a href="#反转一半数字" class="headerlink" title="反转一半数字"></a>反转一半数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// 边界处理，负数一定不是回文数</span><br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || (x % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> &amp;&amp; x != <span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x &gt; ans) &#123;<br>            ans = ans * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;<br>            x = x / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x == ans || x == ans / <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="加一"><a href="#加一" class="headerlink" title="加一"></a><a href="https://leetcode.cn/problems/plus-one/?envType=study-plan-v2&envId=top-interview-150">加一</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>先加到nums.length-1上，如果有进位产生再向前加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] plusOne(<span class="hljs-type">int</span>[] digits) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> digits.length;<br>        <span class="hljs-keyword">if</span> (digits[n - <span class="hljs-number">1</span>] != <span class="hljs-number">9</span>) &#123;<br>            digits[n - <span class="hljs-number">1</span>]++;<br>            <span class="hljs-keyword">return</span> digits;<br>        &#125;<br>        <span class="hljs-comment">// 对于有进位产生的情况</span><br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        ans.add(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> digits[i] + carry;<br>            ans.add(<span class="hljs-number">0</span>, sum % <span class="hljs-number">10</span>);<br>            carry = sum / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (carry != <span class="hljs-number">0</span>) &#123;<br>            ans.add(<span class="hljs-number">0</span>, carry);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.stream().mapToInt(Integer::intValue).toArray();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="学习一下别人的写法简洁高效"><a href="#学习一下别人的写法简洁高效" class="headerlink" title="学习一下别人的写法简洁高效"></a>学习一下别人的写法简洁高效</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] plusOne(<span class="hljs-type">int</span>[] digits) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> digits.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            digits[i]++;<br>            digits[i] = digits[i] % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (digits[i] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> digits;  <span class="hljs-comment">// 说明没有进位产生</span><br>        &#125;<br>        digits = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[digits.length + <span class="hljs-number">1</span>];<br>        digits[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> digits;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="阶乘后的零"><a href="#阶乘后的零" class="headerlink" title="阶乘后的零"></a><a href="https://leetcode.cn/problems/factorial-trailing-zeroes/?envType=study-plan-v2&envId=top-interview-150">阶乘后的零</a></h2><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>n! 尾零的数量即为 n! 中因子 10 的个数，而 10&#x3D;2×5，因此转换成求 n! 中质因子 2 的个数和质因子 5 的个数的较小值。可以通过不断将 n 除以 5，并累加每次除后的 n，来得到答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trailingZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            n /= <span class="hljs-number">5</span>;<br>            ans += n;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="x的平方根"><a href="#x的平方根" class="headerlink" title="x的平方根"></a><a href="https://leetcode.cn/problems/sqrtx/?envType=study-plan-v2&envId=top-interview-150">x的平方根</a></h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, right = x;<br>        <br>        <span class="hljs-comment">// 使用二分查找法来找平方根</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">square</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) mid * mid;  <span class="hljs-comment">// 使用 long 来避免溢出</span><br>            <br>            <span class="hljs-keyword">if</span> (square == x) &#123;<br>                <span class="hljs-keyword">return</span> mid;  <span class="hljs-comment">// 找到精确的平方根</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (square &lt; x) &#123;<br>                left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// mid 太小，调整左边界</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;  <span class="hljs-comment">// mid 太大，调整右边界</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> right;  <span class="hljs-comment">// 当退出循环时，right 是最大的整数，满足 right^2 &lt;= x</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h3 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h3><p>逼近$f(x)&#x3D;x^2 − n&#x3D;0$这个方程的根。</p><ol><li>C 被初始化为 x，这是我们要计算平方根的数；x0 代表初始猜测的值，也设为 x。</li><li>xi 是通过牛顿迭代公式计算得到的新猜测值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">double</span> <span class="hljs-variable">C</span> <span class="hljs-operator">=</span> x, x0 = x;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.5</span> * (x0 + C / x0);<br>            <span class="hljs-keyword">if</span> (Math.abs(x0 - xi) &lt; <span class="hljs-number">1e-7</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            x0 = xi;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) x0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试经典 150 题-位运算</title>
    <link href="/2025/03/05/posts/hot150-16/"/>
    <url>/2025/03/05/posts/hot150-16/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-位运算"><a href="#LeetCode-面试经典-150-题-位运算" class="headerlink" title="LeetCode 面试经典 150 题-位运算"></a>LeetCode 面试经典 150 题-位运算</h1><h2 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a><a href="https://leetcode.cn/problems/add-binary/description/?envType=study-plan-v2&envId=top-interview-150">二进制求和</a></h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>逐位相加，标记进位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addBinary</span><span class="hljs-params">(String a, String b)</span> &#123;<br>        <span class="hljs-comment">// a是较长字符串</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> a.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> b.length();<br>        <span class="hljs-keyword">if</span> (m &lt; n) &#123;<br>            <span class="hljs-keyword">return</span> addBinary(b, a);<br>        &#125;<br>        <span class="hljs-comment">// 逐位相加</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> (a.charAt(m - i - <span class="hljs-number">1</span>) - <span class="hljs-string">&#x27;0&#x27;</span>) + carry;<br>            <span class="hljs-keyword">if</span> (i &lt; n) &#123;<br>                sum += (b.charAt(n - i - <span class="hljs-number">1</span>) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>            sb.append(sum % <span class="hljs-number">2</span>);<br>            carry = sum / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-comment">// 进位</span><br>        <span class="hljs-keyword">if</span> (carry != <span class="hljs-number">0</span>) &#123;<br>            sb.append(carry);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sb.reverse().toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(max(m,n))</li><li>空间复杂度：O(1)</li></ul><h2 id="颠倒二进制位"><a href="#颠倒二进制位" class="headerlink" title="颠倒二进制位"></a><a href="https://leetcode.cn/problems/reverse-bits/?envType=study-plan-v2&envId=top-interview-150">颠倒二进制位</a></h2><h3 id="逐位颠倒"><a href="#逐位颠倒" class="headerlink" title="逐位颠倒"></a>逐位颠倒</h3><p>将 n 视作一个长为 32 的二进制串，从低位往高位枚举 n 的每一位，将其倒序添加到翻转结果 rev 中。每枚举一位就将 n 右移一位，这样当前 n 的最低位就是我们要枚举的比特位。当 n 为 0 时即可结束循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// you need treat n as an unsigned value</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reverseBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rev</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span> &amp;&amp; n != <span class="hljs-number">0</span>; i++) &#123;<br>            rev |= (n &amp; <span class="hljs-number">1</span>) &lt;&lt; (<span class="hljs-number">31</span> - i);<br>            n &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h3 id="位运算分治"><a href="#位运算分治" class="headerlink" title="位运算分治"></a>位运算分治</h3><p>若要翻转一个二进制串，可以将其均分成左右两部分，对每部分递归执行翻转操作，然后将左半部分拼在右半部分的后面，即完成了翻转。</p><p>由于左右两部分的计算方式是相似的，利用位掩码和位移运算，我们可以自底向上地完成这一分治流程。</p><ol><li>交换相邻的1位</li><li>交换相邻的2位</li><li>交换相邻的4位</li><li>交换相邻的8位</li><li>交换前16位和后16位</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// you need treat n as an unsigned value</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">M1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x55555555</span>; <span class="hljs-comment">// 01010101010101010101010101010101</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">M2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x33333333</span>; <span class="hljs-comment">// 00110011001100110011001100110011</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">M4</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x0f0f0f0f</span>; <span class="hljs-comment">// 00001111000011110000111100001111</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">M8</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x00ff00ff</span>; <span class="hljs-comment">// 00000000111111110000000011111111</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reverseBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        n = n &gt;&gt;&gt; <span class="hljs-number">1</span> &amp; M1 | (n &amp; M1) &lt;&lt; <span class="hljs-number">1</span>;<br>        n = n &gt;&gt;&gt; <span class="hljs-number">2</span> &amp; M2 | (n &amp; M2) &lt;&lt; <span class="hljs-number">2</span>;<br>        n = n &gt;&gt;&gt; <span class="hljs-number">4</span> &amp; M4 | (n &amp; M4) &lt;&lt; <span class="hljs-number">4</span>;<br>        n = n &gt;&gt;&gt; <span class="hljs-number">8</span> &amp; M8 | (n &amp; M8) &lt;&lt; <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">return</span> n &gt;&gt;&gt; <span class="hljs-number">16</span> | n &lt;&lt; <span class="hljs-number">16</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(1)</li><li>空间复杂度：O(1)</li></ul><h2 id="位1的个数"><a href="#位1的个数" class="headerlink" title="位1的个数"></a><a href="https://leetcode.cn/problems/number-of-1-bits/?envType=study-plan-v2&envId=top-interview-150">位1的个数</a></h2><h3 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算"></a>位运算</h3><p>不断右移并取最后一位的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            ans += (n &amp; <span class="hljs-number">1</span>);<br>            n &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(k)，k是二进制位数。</li><li>空间复杂度：O(1)</li></ul><h3 id="位运算优化"><a href="#位运算优化" class="headerlink" title="位运算优化"></a>位运算优化</h3><p>每次消除最右边的1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            n &amp;= n - <span class="hljs-number">1</span>;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m)，m是1的个数。</li><li>空间复杂度：O(1)</li></ul><h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a><a href="https://leetcode.cn/problems/single-number/description/?envType=study-plan-v2&envId=top-interview-150">只出现一次的数字</a></h2><h3 id="位运算-2"><a href="#位运算-2" class="headerlink" title="位运算"></a>位运算</h3><p>逐个异或，相同的数字异或结果为0，最后的结果就是只出现一次的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            ans ^= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="只出现一次的数字II"><a href="#只出现一次的数字II" class="headerlink" title="只出现一次的数字II"></a><a href="https://leetcode.cn/problems/single-number-ii/?envType=study-plan-v2&envId=top-interview-150">只出现一次的数字II</a></h2><h3 id="位运算-3"><a href="#位运算-3" class="headerlink" title="位运算"></a>位运算</h3><p>根据(0,0)-&gt;(0,1)-&gt;(1,0)-&gt;(0,0)-&gt;…，可以看出，如果a为1，则b需要变成0，否则就异或1，按照这个原则可以得出b &#x3D; (b ^ 1) &amp; ~a；b改变之后，就变成了(0,1)-&gt;(0,0)-&gt;(1,0)-&gt;(0,1)-&gt;…，可以看出，如果变化之后的b为1，那么a需要变成0，否则就异或1，这样就得出a &#x3D; (a ^ 1) &amp; ~b，a改变之后，就变成了(0,1)-&gt;(1,0)-&gt;(0,0)-&gt;(0,1)-&gt;…，和第一个流水线相比，向前走了一半，完成了一次变化。以上是x为1的情况，如果x为0，则希望a和b都不变，那么可以把a ^ 1和b ^ 1换成a ^ 0和b ^ 0即a和b，那么原式变成b &#x3D; b &amp; ~a和a &#x3D; a &amp; ~b，因为是&amp;操作，所以不存在让a或b从0变成1，所以假设a或b会从1变成0，那么要求a和b都是1才行，但是因为根本不存在(1,1)的情况，所以a和b会保持原来的值，这样就保证了x为0时，a和b不变的条件。综上就是a &#x3D; (a ^ x) &amp; ~b和b &#x3D; (b ^ x) &amp; ~a。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            b = ~a &amp; (b ^ num);<br>            a = ~b &amp; (a ^ num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="只出现一次的数字III"><a href="#只出现一次的数字III" class="headerlink" title="只出现一次的数字III"></a><a href="https://leetcode.cn/problems/single-number-iii/">只出现一次的数字III</a></h2><h3 id="位运算-4"><a href="#位运算-4" class="headerlink" title="位运算"></a>位运算</h3><ol><li>求所有数字的异或值：如果数组中有两个数字只出现一次，其余每个元素均出现两次。那么经过全部异或运算。我们可以得到只出现一次的两个数字的异或结果。</li><li>找到最低的不同位，找到最低位为1的位置，即最低位的两个数字不相同的位</li><li>根据最低不同位分组：<ul><li>根据 mask 的位置，将数组中的数字分为两组：一组在 mask 位置上为 0，另一组在 mask 位置上为 1。</li><li>因为相同的数字会被分到同一组且异或为0，最终每组剩下的数字就是 a 和 b。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] singleNumber(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-comment">// 得到只出现一次的两个数字的异或结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">all</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            all ^= nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 找到两数字最低位的不同</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mask</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> ((all &amp; mask) == <span class="hljs-number">0</span>) &#123;<br>            mask &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 分组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((nums[i] &amp; mask) == <span class="hljs-number">0</span>) &#123;<br>                a ^= nums[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                b ^= nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;a, b&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="数字范围按位与"><a href="#数字范围按位与" class="headerlink" title="数字范围按位与"></a><a href="https://leetcode.cn/problems/bitwise-and-of-numbers-range/?envType=study-plan-v2&envId=top-interview-150">数字范围按位与</a></h2><h3 id="位运算-5"><a href="#位运算-5" class="headerlink" title="位运算"></a>位运算</h3><p>每次清除最右边的1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rangeBitwiseAnd</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            right = right &amp; (right - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>位运算的题目代码实现都不难，但是思路不好想，之后还是把以前刷过的题再好好复习一下。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>位运算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试经典 150 题-堆</title>
    <link href="/2025/03/02/posts/hot150-15/"/>
    <url>/2025/03/02/posts/hot150-15/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-堆"><a href="#LeetCode-面试经典-150-题-堆" class="headerlink" title="LeetCode 面试经典 150 题-堆"></a>LeetCode 面试经典 150 题-堆</h1><h2 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/?envType=study-plan-v2&envId=top-interview-150">数组中的第K个最大元素</a></h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ol><li>建立一个大小为K的最小堆。</li><li>遍历数组中的剩余元素，如果它大于堆顶元素，则将堆顶元素删除，将当前元素加入。</li><li>最后堆顶元素就是第k个最大元素。</li></ol><p>堆操作：</p><ul><li>minHeapify(int[] nums, int index, int heapSize)<ul><li>获取左右子树索引，初始化最小索引为当前元素；</li><li>如果左子节点存在且小于当前节点，则更新最小节点索引；</li><li>如果右子节点存在且小于当前节点，则更新最小节点索引；</li><li>如果最小节点索引不等于当前节点索引，则交换当前节点和最小节点，并继续调整最小堆；</li></ul></li><li>buildHeap(int[] nums, int heapSize)<ul><li>从最后一个非叶子节点开始，依次向前调整节点，保证以每个节点为根的子树都是小根堆</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 建立最小堆</span><br>        buildHeap(nums, k);<br>        <span class="hljs-comment">// 遍历剩余元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[<span class="hljs-number">0</span>]) &#123;<br>                swap(nums, i, <span class="hljs-number">0</span>);<br>                minHeapify(nums, <span class="hljs-number">0</span>, k);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-comment">// 最小堆化操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">minHeapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> heapSize)</span> &#123;<br>        <span class="hljs-comment">// 计算左右子树索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">smallest</span> <span class="hljs-operator">=</span> index;<br>        <span class="hljs-comment">// 如果左子节点存在且小于当前节点，则更新最小节点索引</span><br>        <span class="hljs-keyword">if</span> (left &lt; heapSize &amp;&amp; nums[left] &lt; nums[smallest]) &#123;<br>            smallest = left;<br>        &#125;<br>        <span class="hljs-comment">// 如果右子节点存在且小于当前节点，则更新最小节点索引</span><br>        <span class="hljs-keyword">if</span> (right &lt; heapSize &amp;&amp; nums[right] &lt; nums[smallest]) &#123;<br>            smallest = right;<br>        &#125;<br>        <span class="hljs-comment">// 如果最小节点索引不等于当前节点索引，则交换当前节点和最小节点，并继续调整最小堆</span><br>        <span class="hljs-keyword">if</span> (smallest != index) &#123;<br>            swap(nums, smallest, index);<br>            minHeapify(nums, smallest, heapSize);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 建立最小堆</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> heapSize)</span> &#123;<br>        <span class="hljs-comment">// 从最后一个非叶子节点开始向前最小堆化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> heapSize / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            minHeapify(nums, i, heapSize);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 交换数组中的两个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[a];<br>        nums[a] = nums[b];<br>        nums[b] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogk)，建堆的时间是O(k)，O((n - k) * log k)。</li><li>空间复杂度：O(logk)，递归栈空间。</li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速选择函数：</p><pre><code class="hljs">递归地选择数组的一部分，通过分区操作（partition）来逐步缩小问题规模，直到找到第 k 大的元素。通过基准元素将数组分为左右两部分，左边部分元素小于基准，右边部分元素大于基准。递归只会进入包含目标位置的一边。</code></pre><p>分区操作（Partition）：</p><pre><code class="hljs">选择左边界的元素作为基准元素（pivot）。使用两个指针从两边开始扫描，找到大于基准的元素与小于基准的元素，交换它们的位置。最终，将基准元素放置在正确的位置（即它应该排在所有小于它的元素左边，大于它的元素右边）。返回基准元素的位置 pivotIndex，该位置左边的元素都小于基准，右边的元素都大于基准。</code></pre><p>递归选择：</p><pre><code class="hljs">如果基准元素的位置恰好是目标位置（即 pivotIndex == nums.length - k），则返回该元素。如果基准元素的位置小于目标位置，则递归右边部分。如果基准元素的位置大于目标位置，则递归左边部分。</code></pre><p>牛客上有这道题，试试acm模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">// 注意类名必须为 Main, 不要有任何 package xxx 信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        String[] str = in.nextLine().replace(<span class="hljs-string">&quot;[&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[str.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;<br>            nums[i] = Integer.parseInt(str[i]);<br>        &#125;<br>        System.out.println(findKthLargest(nums, <span class="hljs-number">3</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">return</span> quickSelect(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, k);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">quickSelect</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivotIndex</span> <span class="hljs-operator">=</span> partition(nums, left, right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> nums.length - k;<br>        <span class="hljs-keyword">if</span> (pivotIndex == target) &#123;<br>            <span class="hljs-keyword">return</span> nums[pivotIndex];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivotIndex &lt; target) &#123;<br>            <span class="hljs-keyword">return</span> quickSelect(nums, pivotIndex+<span class="hljs-number">1</span>, right, k);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> quickSelect(nums, left, pivotIndex-<span class="hljs-number">1</span>, k);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">// 选择左边界元素作为基准元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> nums[left];<br>        <span class="hljs-comment">// 初始化左右指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left, j = right + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 开始分区</span><br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-comment">// 从左往右找到第一个大于等于基准元素的元素</span><br>            <span class="hljs-keyword">while</span> (++i &lt; right &amp;&amp; nums[i] &lt; pivot);<br>            <span class="hljs-comment">// 从右往左找到第一个小于等于基准元素的元素</span><br>            <span class="hljs-keyword">while</span> (--j &gt; left &amp;&amp; nums[j] &gt; pivot);<br>            <span class="hljs-comment">// 分区完成</span><br>            <span class="hljs-keyword">if</span> (i &gt;= j) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 交换</span><br>            swap(nums, i, j);<br>        &#125;<br><br>        <span class="hljs-comment">// 将基准元素放置在正确的位置上</span><br>        swap(nums, left, j);<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[a];<br>        nums[a] = nums[b];<br>        nums[b] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(logn)</li></ul><h2 id="IPO"><a href="#IPO" class="headerlink" title="IPO"></a><a href="https://leetcode.cn/problems/ipo/description/?envType=study-plan-v2&envId=top-interview-150">IPO</a></h2><h3 id="利用堆的贪心算法"><a href="#利用堆的贪心算法" class="headerlink" title="利用堆的贪心算法"></a>利用堆的贪心算法</h3><p>将项目按照所需资本的从小到大进行排序，每次进行选择时，假设当前手中持有的资本为 w，我们应该从所有投入资本小于等于 w 的项目中选择利润最大的项目 j，然后此时我们更新手中持有的资本为 w+profits[j]，同时再从所有花费资本小于等于 w+profits[j] 的项目中选择，按照上述规则不断选择 k 次即可。</p><p>利用大根堆的特性，我们将所有能够投资的项目的利润全部压入到堆中，每次从堆中取出最大值，然后更新手中持有的资本，同时将待选的项目利润进入堆，不断重复上述操作。</p><p>如果当前的堆为空，则此时我们应当直接返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaximizedCapital</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span>[] profits, <span class="hljs-type">int</span>[] capital)</span> &#123;<br>        <span class="hljs-comment">// 按照所需资本大小进行排序</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> profits.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            arr[i][<span class="hljs-number">0</span>] = capital[i];<br>            arr[i][<span class="hljs-number">1</span>] = profits[i];<br>        &#125;<br>        Arrays.sort(arr, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <br>        <span class="hljs-comment">// 大根堆</span><br>        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; y - x);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-comment">// 将所有需要资本小于w的利润加入队列</span><br>            <span class="hljs-keyword">while</span> (cur &lt; n &amp;&amp; arr[cur][<span class="hljs-number">0</span>] &lt;= w) &#123;<br>                pq.add(arr[cur][<span class="hljs-number">1</span>]);<br>                cur++;<br>            &#125;<br>            <span class="hljs-comment">// 选择利润最大的那个</span><br>            <span class="hljs-keyword">if</span> (!pq.isEmpty()) &#123;<br>                w += pq.poll();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> w;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O((n+k)logn)，其中 n 是数组 profits 和 capital 的长度，k 表示最多的选择数目。我们需要 O(nlogn) 的时间复杂度来来创建和排序项目，往堆中添加元素的时间不超过 O(nlogn)，每次从堆中取出最大值并更新资本的时间为 O(klogn)。</li><li>空间复杂度：O(n)，其中 n 是数组 profits 和 capital 的长度。空间复杂度主要取决于创建用于排序的数组和大根堆。</li></ul><h2 id="查找和最小的K对数字"><a href="#查找和最小的K对数字" class="headerlink" title="查找和最小的K对数字"></a><a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/description/?envType=study-plan-v2&envId=top-interview-150">查找和最小的K对数字</a></h2><h3 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h3><ol><li>定义最小堆，存储两数和、两数下标。</li><li>初始时放入nums1[0]和nums2[0]，这个数对一定是答案中最小的。</li><li>对于优先队列：<ol><li>弹出和最小的数对，获取其下标i和j，加入答案数组。</li><li>加入下一个元素，nums1[i+1]、nums2[j]和nums1[i]、nums2[j+1]。</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">kSmallestPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 初始化</span><br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(k);<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        pq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nums1[<span class="hljs-number">0</span>] + nums2[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-comment">// 循环</span><br>        <span class="hljs-keyword">while</span> (ans.size() &lt; k) &#123;<br>            <span class="hljs-type">int</span>[] p = pq.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> p[<span class="hljs-number">2</span>];<br>            <span class="hljs-comment">// 加入结果集</span><br>            ans.add(List.of(nums1[i], nums2[j]));<br>            <span class="hljs-comment">// 下一个元素</span><br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> &amp;&amp; i + <span class="hljs-number">1</span> &lt; nums1.length) &#123;<br>                pq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nums1[i+<span class="hljs-number">1</span>] + nums2[j], i+<span class="hljs-number">1</span>, j&#125;);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; nums2.length) &#123;<br>                pq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nums1[i] + nums2[j+<span class="hljs-number">1</span>], i, j+<span class="hljs-number">1</span>&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(klogmin(n,k))，其中 n 为 nums1的长度。为了得到 k 个数对，需要循环 k 次，每次出堆入堆的时间复杂度为 logmin(n,k)。所以总的时间复杂度为 O(klogmin(n,k))。</li><li>空间复杂度：O(min(n,k))。堆中至多有 O(min(n,k)) 个三元组。</li></ul><h2 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a><a href="https://leetcode.cn/problems/find-median-from-data-stream/?envType=study-plan-v2&envId=top-interview-150">数据流中的中位数</a></h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>如果当前 left 的大小和 right 的大小相等：先把 num 加到 right 中，然后把 right 的最小值从 right 中去掉，并添加到 left 中。</li><li>如果当前 left 比 right 多 1 个数：先把 num 加到 left 中，然后把 left 的最大值从 left 中去掉，并添加到 right 中。</li></ul><p>即left 是最大堆，right 是最小堆。</p><ul><li>如果当前有奇数个元素，中位数是 left 的堆顶。</li><li>如果当前有偶数个元素，中位数是 left 的堆顶和 right 的堆顶的平均值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityQueue&lt;Integer&gt; left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);  <span class="hljs-comment">// 最大堆</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityQueue&lt;Integer&gt; right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a - b);  <span class="hljs-comment">// 最小堆</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">// 分类讨论</span><br>        <span class="hljs-keyword">if</span> (left.size() == right.size()) &#123;<br>            right.offer(num);<br>            left.offer(right.poll());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left.offer(num);<br>            right.offer(left.poll());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (left.size() == right.size()) &#123;<br>            <span class="hljs-keyword">return</span> (left.peek() + right.peek()) / <span class="hljs-number">2.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MedianFinder obj = new MedianFinder();</span><br><span class="hljs-comment"> * obj.addNum(num);</span><br><span class="hljs-comment"> * double param_2 = obj.findMedian();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：初始化和 findMedian 都是 O(1)，addNum 是 O(logq)，其中 q 是 addNum 的调用次数。每次操作堆需要 O(logq) 的时间。</li><li>空间复杂度：O(q)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要学会自己实现堆，包括堆化和建堆操作；学会使用封装好的PriorityQueue，可以通过重写比较函数实现最大堆和最小堆。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>堆</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试经典 150 题-二分查找</title>
    <link href="/2025/02/28/posts/hot150-14/"/>
    <url>/2025/02/28/posts/hot150-14/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-二分查找"><a href="#LeetCode-面试经典-150-题-二分查找" class="headerlink" title="LeetCode 面试经典 150 题-二分查找"></a>LeetCode 面试经典 150 题-二分查找</h1><h2 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a><a href="https://leetcode.cn/problems/search-insert-position/?envType=study-plan-v2&envId=top-interview-150">搜索插入位置</a></h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix/?envType=study-plan-v2&envId=top-interview-150">搜索二维矩阵</a></h2><h3 id="z字形查找"><a href="#z字形查找" class="headerlink" title="z字形查找"></a>z字形查找</h3><p>从右上角开始搜索，如果当前位置元素小于target，那么i+1，否则j-1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &lt; target) &#123;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m + n)</li><li>空间复杂度：O(1)</li></ul><h3 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = m * n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> matrix[mid / n][mid % n];<br>            <span class="hljs-keyword">if</span> (x == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logmn)</li><li>空间复杂度：O(1)</li></ul><h2 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a><a href="https://leetcode.cn/problems/find-peak-element/description/?envType=study-plan-v2&envId=top-interview-150">寻找峰值</a></h2><h3 id="二分查找-2"><a href="#二分查找-2" class="headerlink" title="二分查找"></a>二分查找</h3><p>通过每次将搜索区间减半，优化查找过程。我们不需要检查每个元素，只需检查中间元素与其相邻元素的关系，从而缩小范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPeakElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[mid + <span class="hljs-number">1</span>]) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/?envType=study-plan-v2&envId=top-interview-150">搜索旋转排序数组</a></h2><h3 id="二分查找-3"><a href="#二分查找-3" class="headerlink" title="二分查找"></a>二分查找</h3><p>判断哪一部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界：</p><ul><li>如果 [left, mid - 1] 是有序数组，即nums[left] &lt;&#x3D; nums[mid]：如果target &gt;&#x3D; nums[left] &amp;&amp; target &lt; nums[mid]，则在左半部分，否则在右半部分；</li><li>否则如果nums[left] &gt; nums[mid]，则右半部分有序：如果target &gt; nums[mid] &amp;&amp; target &lt;&#x3D; nums[right]，则在右半部分，否则在左半部分。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-comment">// 左半部分有序</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= nums[left]) &#123;<br>                <span class="hljs-comment">// 在左边</span><br>                <span class="hljs-keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;<br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 在右边</span><br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 右半部分有序</span><br>                <span class="hljs-comment">// 在右边</span><br>                <span class="hljs-keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 在左边</span><br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="搜索旋转排序数组II"><a href="#搜索旋转排序数组II" class="headerlink" title="搜索旋转排序数组II"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/">搜索旋转排序数组II</a></h2><h3 id="二分查找-4"><a href="#二分查找-4" class="headerlink" title="二分查找"></a>二分查找</h3><ol><li>判断 nums[mid] 是否等于 target，如果是，直接返回 true。</li><li>如果左边有序（即 nums[left] &lt;&#x3D; nums[mid]），那么我们可以通过比较 target 和 nums[left]、nums[mid] 来判断 target 是否在这个有序区间内，从而决定向左还是向右查找。</li><li>如果右边有序（即 nums[mid] &lt;&#x3D; nums[right]），则可以类似地判断 target 是否在这个有序区间内，并决定查找方向。</li><li>如果左右两边有重复元素（即 &#96;nums[left] &#x3D;&#x3D; nums[mid] || nums[mid] &#x3D;&#x3D; nums[right]），我们只能通过将左右边界向内缩小来减少搜索范围。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 左侧有序</span><br>            <span class="hljs-keyword">if</span> (nums[left] &lt; nums[mid]) &#123;<br>                <span class="hljs-comment">// target 是否在左侧有序部分</span><br>                <span class="hljs-keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 右侧有序</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[right]) &#123;<br>                <span class="hljs-comment">// target 是否在右侧有序部分</span><br>                <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 无法确定有序部分，逐步缩小区间</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 去除重复元素</span><br>                <span class="hljs-keyword">if</span> (nums[left] == nums[mid]) &#123;<br>                    left++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (nums[right] == nums[mid]) &#123;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，最坏情况下，由于重复元素的存在。</li><li>空间复杂度：O(1)</li></ul><h2 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150">在排序数组中查找元素的第一个和最后一个位置</a></h2><h3 id="二分查找-5"><a href="#二分查找-5" class="headerlink" title="二分查找"></a>二分查找</h3><p>要找到数组中第一个等于目标元素的位置和第一个大于目标元素的位置-1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftIdx</span> <span class="hljs-operator">=</span> binarySearch(nums, target, <span class="hljs-literal">true</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightIdx</span> <span class="hljs-operator">=</span> binarySearch(nums, target, <span class="hljs-literal">false</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.length &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;leftIdx, rightIdx&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// 二分查找，lower为true查找第一个大于等于target的下标，否则查找第一个大于target的下标</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">boolean</span> lower)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, ans = n;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 向左收缩边界</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>                ans = mid;  <span class="hljs-comment">// mid是可能的答案</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 向右收缩边界</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/?envType=study-plan-v2&envId=top-interview-150">寻找旋转排序数组中的最小值</a></h2><h3 id="二分查找-6"><a href="#二分查找-6" class="headerlink" title="二分查找"></a>二分查找</h3><p>如果nums[mid] &gt; nums[right]，则最小值一定在mid右侧；否则一定是mid或mid的左侧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 在左侧</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[right]) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 在右侧</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/?envType=study-plan-v2&envId=top-interview-150">寻找两个正序数组的中位数</a></h2><h3 id="二分查找-7"><a href="#二分查找-7" class="headerlink" title="二分查找"></a>二分查找</h3><ol><li>确保 nums1 是较小的数组：我们总是对较短的数组进行二分查找，减少搜索空间。</li><li>二分查找：在较短数组中查找一个合适的分割点，使得两数组的左半部分和右半部分满足合并后的中位数条件。</li><li>计算中位数：<ul><li>如果数组的总长度为奇数，中位数是左半部分的最大值。</li><li>如果数组的总长度为偶数，中位数是左半部分最大值与右半部分最小值的平均值。</li></ul></li></ol><p><img src="/2025/02/28/posts/hot150-14/image.png" alt="Alt text"></p><p><img src="/2025/02/28/posts/hot150-14/image-1.png" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-comment">// 保证nums1是长度较短的那个</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br>        <span class="hljs-keyword">if</span> (m &gt; n) &#123;<br>            <span class="hljs-keyword">return</span> findMedianSortedArrays(nums2, nums1);<br>        &#125;<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = m;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-comment">// 划分数组</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> k - i;<br>            <span class="hljs-comment">// 交叉比较</span><br>            <span class="hljs-comment">// 左下大于右上，i需要增大</span><br>            <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span> &amp;&amp; i != m &amp;&amp; nums2[j-<span class="hljs-number">1</span>] &gt; nums1[i]) &#123;<br>                left = i + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; j != n &amp;&amp; nums1[i-<span class="hljs-number">1</span>] &gt; nums2[j]) &#123;<br>                <span class="hljs-comment">// 左上大于右下，i需要减小</span><br>                right = i - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 满足要求，先求左边最大值</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">maxLeft</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">// 数组一没有元素存在于左半部分</span><br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                    maxLeft = nums2[j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 数组二没有元素存在于左半部分</span><br>                    maxLeft = nums1[i - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 两者取较大</span><br>                    maxLeft = Math.max(nums1[i-<span class="hljs-number">1</span>], nums2[j-<span class="hljs-number">1</span>]);<br>                &#125;<br><br>                <span class="hljs-comment">// 奇数不需要考虑右半部分</span><br>                <span class="hljs-keyword">if</span> ((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> maxLeft;<br>                &#125;<br><br>                <span class="hljs-comment">// 如果是偶数，需要考虑右边</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">minRight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">// 数组1没有元素存在于右半部分</span><br>                <span class="hljs-keyword">if</span> (i == m) &#123;<br>                    minRight = nums2[j];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == n) &#123;<br>                    <span class="hljs-comment">// 数组2没有元素存在于右半部分</span><br>                    minRight = nums1[i];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 两者取较小</span><br>                    minRight = Math.min(nums1[i], nums2[j]);<br>                &#125;<br>                <span class="hljs-keyword">return</span> (maxLeft + minRight) / <span class="hljs-number">2.0</span>;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(log(min(m, n)))</li><li>空间复杂度：O(1)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二分查找的题目总体来说不难，但是对于边界的判断容易混淆，以后要多加复习。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>二分查找</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试经典 150 题-Kadane</title>
    <link href="/2025/02/27/posts/hot150-13/"/>
    <url>/2025/02/27/posts/hot150-13/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-Kadane"><a href="#LeetCode-面试经典-150-题-Kadane" class="headerlink" title="LeetCode 面试经典 150 题-Kadane"></a>LeetCode 面试经典 150 题-Kadane</h1><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150">最大子数组和</a></h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>划分阶段：按子数组结尾的位置划分阶段。</li><li>定义状态：dp[i]表示以nums[i]结尾的最大子数组和。</li><li>状态转移方程：dp[i] &#x3D; max(dp[i-1], 0) + nums[i]。</li><li>初始条件：dp[0] &#x3D; nums[0]。</li><li>返回结果：维护一个最大和变量。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>];<br>        <br>        <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], <span class="hljs-number">0</span>) + nums[i];<br>            ans = Math.max(ans, dp[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>维护四个变量：</p><ul><li>lSum：以l为左端点的最大子段和，lSum要么等于左子区间的lSum，要么等于左子区间的iSum+右子区间的lSum，取较大值。</li><li>rSum：以r为右端点的最大子段和，rSum要么等于右子区间的rSum，要么等于右子区间的iSum+左子区间的rSum，取较大值。</li><li>mSum：[l,r]区间内的最大和，它要么等于左子区间的mSum，要么等于右子区间的mSum，要么横跨两区间，即左子区间的rSum + 右子区间的lSum，三者取较大值。</li><li>iSum：[l,r]区间的和，等于左子区间的iSum + 右子区间iSum。</li></ul><ol><li>用结构体定义线段树的这4个状态；</li><li>定义线段树的pushup操作：即给定状态left和right，计算合并后的状态。</li><li>定义获取子区间的和的函数：给定数组和左右下标，递归计算左右子区间状态，返回合并后的状态。</li><li>返回结果：get(nums, 0, nums.size() - 1).mSum;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 定义状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Status</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> lSum, rSum, mSum, iSum;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Status</span><span class="hljs-params">(<span class="hljs-type">int</span> lSum, <span class="hljs-type">int</span> rSum, <span class="hljs-type">int</span> mSum, <span class="hljs-type">int</span> iSum)</span> &#123;<br>            <span class="hljs-built_in">this</span>.lSum = lSum;<br>            <span class="hljs-built_in">this</span>.rSum = rSum;<br>            <span class="hljs-built_in">this</span>.mSum = mSum;<br>            <span class="hljs-built_in">this</span>.iSum = iSum;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> get(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>).mSum;   <br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个区间</span><br>    <span class="hljs-keyword">public</span> Status <span class="hljs-title function_">pushUp</span><span class="hljs-params">(Status left, Status right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">iSum</span> <span class="hljs-operator">=</span> left.iSum + right.iSum;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lSum</span> <span class="hljs-operator">=</span> Math.max(left.lSum, left.iSum + right.lSum);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rSum</span> <span class="hljs-operator">=</span> Math.max(right.rSum, right.iSum + left.rSum);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mSum</span> <span class="hljs-operator">=</span> Math.max(Math.max(left.mSum, right.mSum), left.rSum + right.lSum);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Status</span>(lSum, rSum, mSum, iSum);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取区间和</span><br>    <span class="hljs-keyword">public</span> Status <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Status</span>(nums[left], nums[left], nums[left], nums[left]);<br>        &#125;<br><br>        <span class="hljs-comment">// 分治法求区间和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">Status</span> <span class="hljs-variable">lSub</span> <span class="hljs-operator">=</span> get(nums, left, mid);<br>        <span class="hljs-type">Status</span> <span class="hljs-variable">rSub</span> <span class="hljs-operator">=</span> get(nums, mid + <span class="hljs-number">1</span>, right);<br><br>        <span class="hljs-keyword">return</span> pushUp(lSub, rSub);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(logn)</li></ul><h2 id="环形子数组的最大和"><a href="#环形子数组的最大和" class="headerlink" title="环形子数组的最大和"></a><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/?envType=study-plan-v2&envId=top-interview-150">环形子数组的最大和</a></h2><h3 id="Kadane"><a href="#Kadane" class="headerlink" title="Kadane"></a>Kadane</h3><p><img src="/2025/02/27/posts/hot150-13/image.png" alt="Alt text"></p><p>最大的环形子数组和 &#x3D; max(最大子数组和，数组总和-最小子数组和)。如果数组的所有数都是负数，第一种情况sum会等于数组中的最大值，而对二种情况sum&#x3D;0（最小的子数组就是本数组，total-total&#x3D;0）。所以多加一个case，判断最大子数组和是否小于0，小于0，直接返回该maxSubArray。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubarraySumCircular</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxSum = nums[<span class="hljs-number">0</span>], curMax = <span class="hljs-number">0</span>, minSum = nums[<span class="hljs-number">0</span>], curMin = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            curMax = Math.max(curMax + x, x);   <span class="hljs-comment">// 继续子数组or重新开始子数组</span><br>            maxSum = Math.max(curMax, maxSum);  <span class="hljs-comment">// 更新全局最大子数组和</span><br>            curMin = Math.min(curMin + x, x);   <span class="hljs-comment">// 继续子数组or重新开始子数组</span><br>            minSum = Math.min(curMin, minSum);  <span class="hljs-comment">// 更新全局最小子数组和</span><br>            total += x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxSum &gt; <span class="hljs-number">0</span> ? Math.max(maxSum, total - minSum) : maxSum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Kadane 算法（Kadane’s algorithm）是一种用于解决最大子数组问题的动态规划算法。最大子数组问题的目标是在一个整数数组中找到一个连续的子数组，使得该子数组的和最大。</p><p>Kadane 算法的思路很简单：从头到尾遍历数组，用两个变量maxSum和curMax分别记录全局最大子数组的和以及当前最大子数组的和，每次遍历更新这两个变量即可。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>Kadane</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kadane</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 面试经典 150 题-分治</title>
    <link href="/2025/02/25/posts/hot150-12/"/>
    <url>/2025/02/25/posts/hot150-12/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-分治"><a href="#LeetCode-面试经典-150-题-分治" class="headerlink" title="LeetCode 面试经典 150 题-分治"></a>LeetCode 面试经典 150 题-分治</h1><h2 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&envId=top-interview-150">将有序数组转换为二叉搜索树</a></h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>如果只有一个节点，直接作为根；前面的部分是左子树，后面的部分是右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(nums, <span class="hljs-number">0</span>, nums.length);<br>    &#125;<br><br>    <span class="hljs-comment">// 把left-right-1转换成平衡二叉搜索树</span><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 一分为二</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[mid], dfs(nums, left, mid), dfs(nums, mid + <span class="hljs-number">1</span>, right));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a><a href="https://leetcode.cn/problems/sort-list/?envType=study-plan-v2&envId=top-interview-150">排序链表</a></h2><h3 id="自顶向下归并排序"><a href="#自顶向下归并排序" class="headerlink" title="自顶向下归并排序"></a>自顶向下归并排序</h3><ol><li>找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 2 步，慢指针每次移动 1 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。</li><li>对两个子链表分别排序。</li><li>将两个排序后的子链表合并，得到完整的排序后的链表。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// 如果链表为空或者只有一个节点，无需排序</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 找到中间节点，并断开与其前一个节点的连接</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> middleNode(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> pre.next;<br>        pre.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 分治</span><br>        head = sortList(head);<br>        mid = sortList(mid);<br>        <span class="hljs-comment">// 合并</span><br>        <span class="hljs-keyword">return</span> merge(head, mid);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个有序链表</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode left, ListNode right)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (left.val &lt; right.val) &#123;<br>                cur.next = left;<br>                left = left.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = right;<br>                right = right.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-comment">// 链接剩余部分</span><br>        cur.next = left != <span class="hljs-literal">null</span> ? left : right;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)</li></ul><h3 id="自底向上归并排序"><a href="#自底向上归并排序" class="headerlink" title="自底向上归并排序"></a>自底向上归并排序</h3><ol><li>遍历链表，获取链表长度 length。</li><li>初始化步长 step&#x3D;1。</li><li>循环直到 step≥length。</li><li>每轮循环，从链表头节点开始。</li><li>分割出两段长为 step 的链表，合并，把合并后的链表插到新链表的末尾。重复该步骤，直到链表遍历完毕。</li><li>把 step 扩大一倍。回到第 4 步。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// 如果链表为空或只有一个元素，直接返回</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 获取链表长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> getLength(head);<br>        <br>        <span class="hljs-comment">// 从小到大逐渐合并</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy.next = head;<br>        <br>        <span class="hljs-comment">// 每次合并两个相邻的部分，部分的大小是step</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; step &lt; len; step *= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy.next;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> dummy;<br>            <br>            <span class="hljs-comment">// 每次处理一组大小为step的链表</span><br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 分割出两个部分</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> cur;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> split(left, step);<br>                cur = split(right, step);  <span class="hljs-comment">// cur 指向下一个部分</span><br>                <br>                <span class="hljs-comment">// 合并这两部分</span><br>                tail.next = merge(left, right);<br>                <br>                <span class="hljs-comment">// 移动 tail 指针到合并后的末尾</span><br>                <span class="hljs-keyword">while</span> (tail.next != <span class="hljs-literal">null</span>) &#123;<br>                    tail = tail.next;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取链表长度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            length++;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br><br>    <span class="hljs-comment">// 分割链表</span><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">split</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; size &amp;&amp; head.next != <span class="hljs-literal">null</span>; i++) &#123;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> head.next;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> second;<br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个有序链表</span><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode left, ListNode right)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <br>        <span class="hljs-keyword">while</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (left.val &lt; right.val) &#123;<br>                cur.next = left;<br>                left = left.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = right;<br>                right = right.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 连接剩余部分</span><br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span>) &#123;<br>            cur.next = left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur.next = right;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><h2 id="建立四叉树"><a href="#建立四叉树" class="headerlink" title="建立四叉树"></a><a href="https://leetcode.cn/problems/construct-quad-tree/?envType=study-plan-v2&envId=top-interview-150">建立四叉树</a></h2><p>这道题以后再做。</p><h2 id="合并k个有序链表"><a href="#合并k个有序链表" class="headerlink" title="合并k个有序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/?envType=study-plan-v2&envId=top-interview-150">合并k个有序链表</a></h2><h3 id="分治法-1"><a href="#分治法-1" class="headerlink" title="分治法"></a>分治法</h3><p>将链表数组分治成较小的子问题。每次通过中点将数组分成两部分，分别对这两部分递归调用 mergeSort，直到数组只剩下一个链表为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-comment">// 边界处理</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> lists.length;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mergeSort(lists, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            <span class="hljs-keyword">return</span> lists[left];<br>        &#125;<br>        <span class="hljs-comment">// 递归合并</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> merge(mergeSort(lists, left, mid), mergeSort(lists, mid + <span class="hljs-number">1</span>, right));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <br>        <span class="hljs-keyword">while</span>(list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;<br>                cur.next = list1;<br>                list1 = list1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = list2;<br>                list2 = list2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = list1 != <span class="hljs-literal">null</span> ? list1 : list2;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n * k * log(k))</li><li>空间复杂度：O(logk)</li></ul><h3 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h3><p>维护当前每个链表没有被合并的元素的最前面一个，k 个链表就最多有 k 个满足这样条件的元素，每次在这些元素里面选取 val 属性最小的元素合并到答案中。在选取最小元素的时候，可以用优先队列来优化这个过程。</p><p>初始把所有链表的头节点入堆，然后不断弹出堆中最小节点 x，如果 x.next 不为空就加入堆中。循环直到堆为空。把弹出的节点按顺序拼接起来，就得到了答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-comment">// 初始化最小堆</span><br>        PriorityQueue&lt;ListNode&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a.val - b.val);<br>        <span class="hljs-keyword">for</span> (ListNode node : lists) &#123;<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>                pq.offer(node);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 合并链表</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>            <span class="hljs-comment">// 最小堆中的最小节点</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> pq.poll();<br>            <span class="hljs-keyword">if</span> (node.next != <span class="hljs-literal">null</span>) &#123;<br>                pq.offer(node.next);<br>            &#125;<br>            <span class="hljs-comment">// 合并到链表中</span><br>            cur.next = node;<br>            cur = cur.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：考虑优先队列中的元素不超过 k 个，那么插入和删除的时间代价为 O(logk)，这里最多有 kn 个点，对于每个点都被插入删除各一次，故总的时间代价即渐进时间复杂度为 O(kn×logk)。</li><li>空间复杂度：O(k)，优先队列中的元素不超过 k 个。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>分治</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试经典 150 题-回溯</title>
    <link href="/2025/02/15/posts/hot150-11/"/>
    <url>/2025/02/15/posts/hot150-11/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-回溯"><a href="#LeetCode-面试经典-150-题-回溯" class="headerlink" title="LeetCode 面试经典 150 题-回溯"></a>LeetCode 面试经典 150 题-回溯</h1><p>从今天开始练习ACM模式的题目，从牛客上找力扣对应或相似的题目。</p><h2 id="字符串组合"><a href="#字符串组合" class="headerlink" title="字符串组合"></a><a href="https://www.nowcoder.com/practice/837f4d04f5cb4f26a8215b2b95cc76a5?tpId=182&tqId=34795&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?questionJobId=10&subTabName=online_coding_page&difficulty=undefined&judgeStatus=undefined&tags=&title=%E7%BB%84%E5%90%88">字符串组合</a></h2><h3 id="穷举"><a href="#穷举" class="headerlink" title="穷举"></a>穷举</h3><ol><li>使用treeset去重，重定义比较函数。</li><li>外层循环枚举字符串长度，内层循环枚举起始位置，加入集合。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-comment">// 注意类名必须为 Main, 不要有任何 package xxx 信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> in.nextLine();<br>        <span class="hljs-comment">// 用于存储所有的组合，使用Set来去重</span><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>                <span class="hljs-keyword">if</span> (s1.length() == s2.length()) &#123;<br>                    <span class="hljs-keyword">return</span> s1.compareTo(s2);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> s1.length() - s2.length();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 生成所有相邻字符的组合</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">// 枚举字符串长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; len &lt;= n; len++) &#123;<br>            <span class="hljs-comment">// 枚举起始位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; start &lt;= n - len; start++) &#123;<br>                set.add(s.substring(start, start + len));<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 输出结果，以空格分隔</span><br>        System.out.println(String.join(<span class="hljs-string">&quot; &quot;</span>, set));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：生成所有字符串$O(n^2)$，排序$O(n^2 \log (n^2))$，因为最多生成$n^2$个字符串。</li><li>空间复杂度：$O(n^2)$</li></ul><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&envId=top-interview-150">电话号码的字母组合</a></h2><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>这道题的核心是 回溯法（Backtracking），类似于一个多叉树的遍历问题。</p><p>步骤：</p><pre><code class="hljs">构建映射关系：用哈希表存储 数字 -&gt; 字母 的映射，例如 &#39;2&#39; -&gt; &quot;abc&quot;，&#39;3&#39; -&gt; &quot;def&quot;。回溯递归：    遍历输入 digits，对每个数字对应的字母 逐个尝试。    递归深入下一层，直到构造完所有的字母组合。    递归结束后回溯（撤销当前选择），尝试下一个可能的组合。边界情况：输入为空时，返回空列表。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> backtrack;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LetterCombinations</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LetterCombinations</span> <span class="hljs-variable">solver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LetterCombinations</span>();<br><br>        <span class="hljs-comment">// 测试案例</span><br>        System.out.println(solver.letterCombinations(<span class="hljs-string">&quot;23&quot;</span>));<br>        System.out.println(solver.letterCombinations(<span class="hljs-string">&quot;7&quot;</span>));<br>        System.out.println(solver.letterCombinations(<span class="hljs-string">&quot;&quot;</span>));<br>        System.out.println(solver.letterCombinations(<span class="hljs-string">&quot;9&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Map&lt;Character, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>            put(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&quot;def&quot;</span>);<br>            put(<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&quot;ghi&quot;</span>);<br>            put(<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br>            put(<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&quot;mno&quot;</span>);<br>            put(<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>);<br>            put(<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&quot;tuv&quot;</span>);<br>            put(<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>);<br>        &#125;&#125;;<br>        backtrack(res, digits, map,<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;String&gt; res, String digits, Map&lt;Character, String&gt; map, <span class="hljs-type">int</span> index, StringBuffer combination)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == digits.length()) &#123;<br>            res.add(combination.toString());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> digits.charAt(index);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> map.get(ch);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>                combination.append(s.charAt(i));<br>                backtrack(res, digits, map, index + <span class="hljs-number">1</span>, combination);<br>                combination.deleteCharAt(combination.length() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(3^m * 4^n)$</li><li>空间复杂度：O(m+n)，空间复杂度主要取决于哈希表以及回溯过程中的递归调用层数，哈希表的大小与输入无关，可以看成常数，递归调用层数最大为m+n。</li></ul><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a><a href="https://leetcode.cn/problems/combinations/description/?envType=study-plan-v2&envId=top-interview-150">组合</a></h2><h3 id="回溯法-1"><a href="#回溯法-1" class="headerlink" title="回溯法"></a>回溯法</h3><p>首先，从 1 到 n 中选择一个数字，并递归地继续选择下一个数字，直到组合的大小达到 k。当组合完成时，将其添加到结果中。在递归过程中，通过回溯移除最后添加的元素，回到上一步继续尝试其他可能的组合。这样能够生成所有从 1 到 n 中选择 k 个数的组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> backtrack;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Combinations</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> scanner.nextInt();<br><br>        <span class="hljs-type">Combinations</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Combinations</span>();<br>        List&lt;List&lt;Integer&gt;&gt; res = solution.combine(n, k);<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; list : res) &#123;<br>            System.out.println(list);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        backtrack(res, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(), <span class="hljs-number">1</span>, n, k);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; combination, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (combination.size() == k) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(combination));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt;= n; i++) &#123;<br>                combination.add(i);<br>                backtrack(res, combination, i + <span class="hljs-number">1</span>, n, k);<br>                combination.remove(combination.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(C(n,k) \times k)$，组合的总数为 C(n,k) &#x3D; n!&#x2F;(k!(n-k)!)，对于每个组合，我们需要O(k)的时间来创建新的列表并添加到结果中。</li><li>空间复杂度：O(k)，递归的最大深度为k，因为我们需要选择k个数。</li></ul><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a><a href="https://leetcode.cn/problems/permutations/?envType=study-plan-v2&envId=top-interview-150">全排列</a></h2><h3 id="回溯法-2"><a href="#回溯法-2" class="headerlink" title="回溯法"></a>回溯法</h3><p>首先，将输入数组 nums 转换为列表 cur。然后，通过递归函数 backtrack 实现回溯算法生成所有排列。在每一层递归中，遍历从当前索引 index 到列表末尾的所有元素，并通过交换来生成新的排列。每当递归到达 cur.size() 时，表示一个完整的排列已生成，添加到结果 res 中。回溯过程中使用 Collections.swap 恢复元素顺序，以便探索其他排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> backtrack;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Permutations</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Permutations</span> <span class="hljs-variable">permutations</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Permutations</span>();<br>        List&lt;List&lt;Integer&gt;&gt; res = permutations.permute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);<br>        System.out.println(res);<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            cur.add(nums[i]);<br>        &#125;<br>        backtrack(res, cur, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; cur, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (index == cur.size()) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(cur));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; cur.size(); i++) &#123;<br>                Collections.swap(cur, index, i);<br>                backtrack(res, cur, index + <span class="hljs-number">1</span>);<br>                Collections.swap(cur, index, i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n * n!)，backtrack的调用次数是O(n!)，需要将当前答案使用O(n)的时间复制到答案数组中。</li><li>空间复杂度：O(n)，递归栈空间，不计返回值空间。</li></ul><h2 id="N皇后II"><a href="#N皇后II" class="headerlink" title="N皇后II"></a><a href="https://leetcode.cn/problems/n-queens-ii/description/?envType=study-plan-v2&envId=top-interview-150">N皇后II</a></h2><h3 id="回溯法-3"><a href="#回溯法-3" class="headerlink" title="回溯法"></a>回溯法</h3><p>定义每列、左上-右下、右上-左下标记数组，尝试对于每一行放置皇后，遍历每一列，计算对角线下标，然后递归下一行，再回溯。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> backtrack;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">nqueens</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> ans;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">nqueens</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">nqueens</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        System.out.println(solution.totalNQueens(n));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">totalNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">boolean</span>[] col = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-type">boolean</span>[] diag1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>];<br>        <span class="hljs-type">boolean</span>[] diag2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>];<br>        dfs(<span class="hljs-number">0</span>, col, diag1, diag2);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">boolean</span>[] col, <span class="hljs-type">boolean</span>[] diag1, <span class="hljs-type">boolean</span>[] diag2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> col.length;<br>        <span class="hljs-comment">// 找到一个合法方案</span><br>        <span class="hljs-keyword">if</span> (r == n) &#123;<br>            ans++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 遍历当前行每一列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; c &lt; n; c++) &#123;<br>            <span class="hljs-comment">// 转换成合法索引</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rc</span> <span class="hljs-operator">=</span> r - c + n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (!col[c] &amp;&amp; !diag1[r + c] &amp;&amp; !diag2[rc]) &#123;<br>                col[c] = diag1[r + c] = diag2[rc] = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// 在(r,c)放置皇后</span><br>                dfs(r + <span class="hljs-number">1</span>, col, diag1, diag2);              <span class="hljs-comment">// 放置下一行</span><br>                col[c] = diag1[r + c] = diag2[rc] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 回溯</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n!)</li><li>空间复杂度：O(n)</li></ul><h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/?envType=study-plan-v2&envId=top-interview-150">括号生成</a></h2><h3 id="回溯法-4"><a href="#回溯法-4" class="headerlink" title="回溯法"></a>回溯法</h3><ol><li>回溯函数参数：结果集和当前括号组合，左括号剩余数和右括号剩余数。</li><li>递归结束条件：左括号剩余数和右括号剩余数都是0.</li><li>如果当前左括号剩余数大于0，那么可以选择左括号，左括号剩余数-1再递归遍历，回溯；如果当前左括号剩余数小于右括号剩余数，那么可以选择右括号，右括号剩余数-1再递归遍历，回溯。</li><li>返回结果集。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> backtrack;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentTheses</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">ParentTheses</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentTheses</span>();<br>        List&lt;String&gt; ans = p.generateParenthesis(n);<br>        System.out.println(ans);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        backtrack(ans, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(), n, n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;String&gt; ans, StringBuffer s, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>) &#123;<br>            ans.add(s.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 选择左括号</span><br>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>            s.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            backtrack(ans, s, left - <span class="hljs-number">1</span>, right);<br>            s.deleteCharAt(s.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 选择右括号</span><br>        <span class="hljs-keyword">if</span> (right &gt; left) &#123;<br>            s.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            backtrack(ans, s, left, right - <span class="hljs-number">1</span>);<br>            s.deleteCharAt(s.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$\frac{4^n}{\sqrt{n}}$</li><li>空间复杂度：O(n)，结果不计入空间。</li></ul><h2 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a><a href="https://leetcode.cn/problems/word-search/?envType=study-plan-v2&envId=top-interview-150">单词搜索</a></h2><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><ol><li>对每一个位置作为单词起始进行搜索，如果搜索到了就可以返回true；</li><li>回溯函数参数：网格，单词，当前搜索位置行列坐标，单词索引；</li><li>递归结束条件：单词索引遍历到最后；</li><li>剪枝：超出边界、当前位置已访问过、当前位置字符不等于当前单词字符；</li><li>对上下左右四个方向进行搜索，回溯；</li><li>返回结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br><br>        <span class="hljs-comment">// 搜索每一个位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (backtrack(board, word, visited, i, j, <span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word, <span class="hljs-type">boolean</span>[][] visited, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (index == word.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 边界处理</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= m || j &lt; <span class="hljs-number">0</span> || j &gt;= n || visited[i][j] || board[i][j] != word.charAt(index)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 上下左右四个方向搜索</span><br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> backtrack(board, word, visited, i-<span class="hljs-number">1</span>, j, index+<span class="hljs-number">1</span>) || backtrack(board, word, visited, i+<span class="hljs-number">1</span>, j, index+<span class="hljs-number">1</span>) || backtrack(board, word, visited, i, j-<span class="hljs-number">1</span>, index + <span class="hljs-number">1</span>) || backtrack(board, word, visited, i, j+<span class="hljs-number">1</span>, index + <span class="hljs-number">1</span>);<br>        visited[i][j] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(mn \cdot 3^L)$，除了第一次可以进入4个分支以外，其余时间我们最多会进入3个分支。</li><li>空间复杂度：O(m * n + L)。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试经典 150 题-图</title>
    <link href="/2025/01/22/posts/hot150-10/"/>
    <url>/2025/01/22/posts/hot150-10/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-图"><a href="#LeetCode-面试经典-150-题-图" class="headerlink" title="LeetCode 面试经典 150 题-图"></a>LeetCode 面试经典 150 题-图</h1><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/?envType=study-plan-v2&envId=top-interview-150">岛屿数量</a></h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ol><li>遍历图，当遇到为1的格子时，开始深度优先搜索。</li><li>判断当前位置是否合法，判断是否是1防止重复遍历。</li><li>标记当前位置已访问过，然后遍历上下左右四个方向。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    ans++;<br>                    dfs(grid, i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-comment">// 判断位置是否合法</span><br>        <span class="hljs-keyword">if</span> (!isValid(grid, row, col)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 防止重复遍历</span><br>        <span class="hljs-keyword">if</span> (grid[row][col] != <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <br>        <span class="hljs-comment">// 标记已访问过</span><br>        grid[row][col] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>        <span class="hljs-comment">// 遍历上下左右四个方向</span><br>        dfs(grid, row - <span class="hljs-number">1</span>, col);<br>        dfs(grid, row + <span class="hljs-number">1</span>, col);<br>        dfs(grid, row, col - <span class="hljs-number">1</span>);<br>        dfs(grid, row, col + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; n ) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><ol><li>遍历图，如果一个位置为 1，则将其加入队列，开始进行广度优先搜索。</li><li>在广度优先搜索的过程中，每个搜索到的 1 都会被标记为 2。</li><li>直到队列为空，搜索结束。最终岛屿的数量就是我们进行广度优先搜索的次数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    ans++;<br>                    grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                    <span class="hljs-comment">// 定义队列</span><br>                    Queue&lt;Integer&gt; neighbors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>                    neighbors.offer(i * n + j);<br>                    <span class="hljs-comment">// 广度优先搜索</span><br>                    <span class="hljs-keyword">while</span> (!neighbors.isEmpty()) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> neighbors.poll();<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> id / n;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> id % n;<br>                        <span class="hljs-keyword">if</span> (isValid(grid, r - <span class="hljs-number">1</span>, c) &amp;&amp; grid[r - <span class="hljs-number">1</span>][c] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                            neighbors.offer((r-<span class="hljs-number">1</span>) * n + c);<br>                            grid[r-<span class="hljs-number">1</span>][c] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (isValid(grid, r + <span class="hljs-number">1</span>, c) &amp;&amp; grid[r + <span class="hljs-number">1</span>][c] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                            neighbors.offer((r+<span class="hljs-number">1</span>) * n + c);<br>                            grid[r+<span class="hljs-number">1</span>][c] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (isValid(grid, r, c - <span class="hljs-number">1</span>) &amp;&amp; grid[r][c - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                            neighbors.offer(r * n + c - <span class="hljs-number">1</span>);<br>                            grid[r][c-<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (isValid(grid, r, c + <span class="hljs-number">1</span>) &amp;&amp; grid[r][c + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                            neighbors.offer(r * n + c + <span class="hljs-number">1</span>);<br>                            grid[r][c+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; n ) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(min(m, n))</li></ul><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>如果一个位置为 1，则将其与相邻四个方向上的 1 在并查集中进行合并。最终岛屿的数量就是并查集中连通分量的数目。</p><ol><li>并查集成员变量：父亲数组、秩数组、连通集数量。</li><li>并查集成员函数：<ul><li>构造函数：初始化父亲数组和秩数组。</li><li>find函数：查找祖先。</li><li>unite函数：按秩合并两个结点。</li><li>getCount函数：返回count。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>        <span class="hljs-type">int</span> count;<br>        <span class="hljs-type">int</span>[] parent;<br>        <span class="hljs-type">int</span>[] rank;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>            count = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>            parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m * n];<br>            rank = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m * n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        parent[i * n + j] = i * n + j;<br>                        ++count;<br>                    &#125;<br>                    rank[i * n + j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>            <span class="hljs-keyword">if</span> (parent[i] != i) &#123;<br>                parent[i] = find(parent[i]);<br>            &#125;<br>            <span class="hljs-keyword">return</span> parent[i];<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rootx</span> <span class="hljs-operator">=</span> find(x);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rooty</span> <span class="hljs-operator">=</span> find(y);<br>            <span class="hljs-keyword">if</span> (rootx != rooty) &#123;<br>                <span class="hljs-keyword">if</span> (rank[rootx] &gt; rank[y]) &#123;<br>                    parent[rooty] = parent[x];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;<br>                    parent[rootx] = parent[y];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    parent[rooty] = rootx;<br>                    rank[rootx]++;<br>                &#125;<br>                --count;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">UnionFind</span> <span class="hljs-variable">uf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(grid);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                    <span class="hljs-keyword">if</span> (isValid(grid, i-<span class="hljs-number">1</span>, j) &amp;&amp; grid[i-<span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        uf.union(i * n + j, (i-<span class="hljs-number">1</span>) * n + j);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (isValid(grid, i+<span class="hljs-number">1</span>, j) &amp;&amp; grid[i+<span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        uf.union(i * n + j, (i+<span class="hljs-number">1</span>) * n + j);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (isValid(grid, i, j-<span class="hljs-number">1</span>) &amp;&amp; grid[i][j-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        uf.union(i * n + j, i * n + j - <span class="hljs-number">1</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (isValid(grid, i, j+<span class="hljs-number">1</span>) &amp;&amp; grid[i][j+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        uf.union(i * n + j, i * n + j + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> uf.getCount();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; n ) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><h2 id="被围绕的区域"><a href="#被围绕的区域" class="headerlink" title="被围绕的区域"></a><a href="https://leetcode.cn/problems/surrounded-regions/description/?envType=study-plan-v2&envId=top-interview-150">被围绕的区域</a></h2><h3 id="深度优先搜索-1"><a href="#深度优先搜索-1" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ul><li>对于每一个边界上的 O，我们以它为起点，标记所有与它直接或间接相连的字母 O；</li><li>最后我们遍历这个矩阵，对于每一个字母：<ul><li>如果该字母被标记过，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；</li><li>如果该字母没有被标记过，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-comment">// 第一列和最后一列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            dfs(board, i, <span class="hljs-number">0</span>);<br>            dfs(board, i, n - <span class="hljs-number">1</span>);<br>        &#125;    <br>        <span class="hljs-comment">// 第一行和最后一行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            dfs(board, <span class="hljs-number">0</span>, i);<br>            dfs(board, m - <span class="hljs-number">1</span>, i);<br>        &#125;<br>        <span class="hljs-comment">// 修改标记</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;A&#x27;</span>) &#123;<br>                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-comment">// 检查边界</span><br>        <span class="hljs-keyword">if</span> (row &lt; <span class="hljs-number">0</span> || row &gt;= m || col &lt; <span class="hljs-number">0</span> || col &gt;= n) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果是&#x27;O&#x27;，则标记为&#x27;A&#x27;</span><br>        <span class="hljs-keyword">if</span> (board[row][col] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>            board[row][col] = <span class="hljs-string">&#x27;A&#x27;</span>;<br>            <span class="hljs-comment">// 递归上下左右</span><br>            dfs(board, row - <span class="hljs-number">1</span>, col);<br>            dfs(board, row + <span class="hljs-number">1</span>, col);<br>            dfs(board, row, col - <span class="hljs-number">1</span>);<br>            dfs(board, row, col + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><h2 id="克隆图"><a href="#克隆图" class="headerlink" title="克隆图"></a><a href="https://leetcode.cn/problems/clone-graph/?envType=study-plan-v2&envId=top-interview-150">克隆图</a></h2><h3 id="深度优先搜索-2"><a href="#深度优先搜索-2" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ol><li>使用一个哈希表存储所有已被访问和克隆的节点。哈希表中的 key 是原始图中的节点，value 是克隆图中的对应节点。</li><li>从给定节点开始遍历图。如果某个节点已经被访问过，则返回其克隆图中的对应节点。</li><li>如果当前访问的节点不在哈希表中，则创建它的克隆节点并存储在哈希表中。注意：在进入递归之前，必须先创建克隆节点并保存在哈希表中。如果不保证这种顺序，可能会在递归中再次遇到同一个节点，再次遍历该节点时，陷入死循环。</li><li>递归调用每个节点的邻接点。每个节点递归调用的次数等于邻接点的数量，每一次调用返回其对应邻接点的克隆节点，最终返回这些克隆邻接点的列表，将其放入对应克隆节点的邻接表中。这样就可以克隆给定的节点和其邻接点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> HashMap&lt;Node, Node&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">cloneGraph</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-comment">// 边界条件</span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;    <br><br>        <span class="hljs-comment">// 如果已经访问过，则可以直接返回</span><br>        <span class="hljs-keyword">if</span> (visited.containsKey(node)) &#123;<br>            <span class="hljs-keyword">return</span> visited.get(node);<br>        &#125;<br><br>        <span class="hljs-comment">// 克隆节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cloneNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(node.val, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>        visited.put(node, cloneNode);<br><br>        <span class="hljs-comment">// 克隆邻居节点</span><br>        <span class="hljs-keyword">for</span> (Node neighbor : node.neighbors) &#123;<br>            cloneNode.neighbors.add(cloneGraph(neighbor));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cloneNode;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="广度优先搜索-1"><a href="#广度优先搜索-1" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><ol><li>使用一个哈希表 visited 存储所有已被访问和克隆的节点。哈希表中的 key 是原始图中的节点，value 是克隆图中的对应节点。</li><li>将题目给定的节点添加到队列。克隆该节点并存储到哈希表中。</li><li>每次从队列首部取出一个节点，遍历该节点的所有邻接点。如果某个邻接点已被访问，则该邻接点一定在 visited 中，那么从 visited 获得该邻接点，否则创建一个新的节点存储在 visited 中，并将邻接点添加到队列。将克隆的邻接点添加到克隆图对应节点的邻接表中。重复上述操作直到队列为空，则整个图遍历结束。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> HashMap&lt;Node, Node&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">cloneGraph</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-comment">// 边界条件</span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;    <br><br>        <span class="hljs-comment">// 定义队列</span><br>        Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Node&gt;();<br>        queue.offer(node);<br>        visited.put(node, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(node.val, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>()));<br><br>        <span class="hljs-comment">// 广度优先搜索</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">for</span> (Node neighbor : cur.neighbors) &#123;<br>                <span class="hljs-keyword">if</span> (!visited.containsKey(neighbor)) &#123;<br>                    visited.put(neighbor, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(neighbor.val, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>()));<br>                    queue.offer(neighbor);<br>                &#125;<br>                visited.get(cur).neighbors.add(visited.get(neighbor));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> visited.get(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="除法求值"><a href="#除法求值" class="headerlink" title="除法求值"></a><a href="https://leetcode.cn/problems/evaluate-division/solutions/548585/chu-fa-qiu-zhi-by-leetcode-solution-8nxb/?envType=study-plan-v2&envId=top-interview-150">除法求值</a></h2><h3 id="并查集-1"><a href="#并查集-1" class="headerlink" title="并查集"></a>并查集</h3><ol><li>定义并查集：<ul><li>父节点数组、权重数组（代表到父节点的权值）</li><li>初始化：父节点为其本身下标，权重初始化为1.0</li><li>合并：rootx的父亲指向rooty，并计算weight[rootx]；<br> <img src="/2025/01/22/posts/hot150-10/image.png" alt="Alt text"></li><li>查找（路径压缩）：在查找根节点的同时更新每个节点的权值，保持了树的扁平化。</li><li>查询是否连通：如果父节点相同，则连通，直接计算值；否则返回-1.</li></ul></li><li>将变量映射到整数，用哈希表存放。</li><li>合并每个equation。</li><li>查询。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="hljs-type">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;<br>        <span class="hljs-comment">// 最多有2 * equationsSize个id</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">equationsSize</span> <span class="hljs-operator">=</span> equations.size();<br>        <span class="hljs-type">UnionFind</span> <span class="hljs-variable">uf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(<span class="hljs-number">2</span> * equationsSize);<br>        <span class="hljs-comment">// 预处理，将变量与id映射</span><br>        Map&lt;String, Integer&gt; hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">2</span> * equationsSize);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; equationsSize; i++) &#123;<br>            List&lt;String&gt; equation = equations.get(i);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> equation.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> equation.get(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span> (!hash.containsKey(var1)) &#123;<br>                hash.put(var1, id);<br>                id++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!hash.containsKey(var2)) &#123;<br>                hash.put(var2, id);<br>                id++;<br>            &#125;<br><br>            uf.union(hash.get(var1), hash.get(var2), values[i]);<br>        &#125;<br><br>        <span class="hljs-comment">// 查询</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">queriesSize</span> <span class="hljs-operator">=</span> queries.size();<br>        <span class="hljs-type">double</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[queriesSize];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queriesSize; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> queries.get(i).get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> queries.get(i).get(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">id1</span> <span class="hljs-operator">=</span> hash.get(var1);<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">id2</span> <span class="hljs-operator">=</span> hash.get(var2);<br><br>            <span class="hljs-keyword">if</span> (id1 == <span class="hljs-literal">null</span> || id2 == <span class="hljs-literal">null</span>) &#123;<br>                res[i] = -<span class="hljs-number">1.0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res[i] = uf.isConnected(id1, id2);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>        <span class="hljs-comment">// 父节点数组和权值数组</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] parent;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">double</span>[] weight;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>            parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            weight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                parent[i] = i;<br>                weight[i] = <span class="hljs-number">1.0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 合并</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">double</span> value)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rootx</span> <span class="hljs-operator">=</span> find(x);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rooty</span> <span class="hljs-operator">=</span> find(y);<br>            <span class="hljs-keyword">if</span> (rootx == rooty) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            parent[rootx] = rooty;<br>            weight[rootx] = weight[y] * value / weight[x];<br>        &#125;<br><br>        <span class="hljs-comment">// 路径压缩</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>            <span class="hljs-keyword">if</span> (x != parent[x]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">orign</span> <span class="hljs-operator">=</span> parent[x];<br>                parent[x] = find(parent[x]);<br>                weight[x] *= weight[orign];<br>            &#125;<br>            <span class="hljs-keyword">return</span> parent[x];<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rootx</span> <span class="hljs-operator">=</span> find(x);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rooty</span> <span class="hljs-operator">=</span> find(y);<br>            <span class="hljs-keyword">if</span> (rootx == rooty) &#123;<br>                <span class="hljs-keyword">return</span> weight[x] / weight[y];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1.0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a><a href="https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&envId=top-interview-150">课程表</a></h2><h3 id="深度优先搜索-3"><a href="#深度优先搜索-3" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>在每一轮的搜索搜索开始时，任取一个「未搜索」的节点开始进行深度优先搜索。</p><ol><li>将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：<ul><li>如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</li><li>如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</li><li>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u,v) 之前的拓扑关系，以及不用进行任何操作。</li></ul></li><li>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</li><li>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; edges;<br>    <span class="hljs-type">int</span>[] visited;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites)</span> &#123;<br>        <span class="hljs-comment">// 初始化图</span><br>        edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        <span class="hljs-comment">// 建图</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] info : prerequisites) &#123;<br>            edges.get(info[<span class="hljs-number">1</span>]).add(info[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 深度优先搜索</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses &amp;&amp; valid; i++) &#123;<br>            <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-number">0</span>) &#123;<br>                dfs(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> valid;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>        visited[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 遍历所有邻接节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : edges.get(u)) &#123;<br>            <span class="hljs-keyword">if</span> (visited[v] == <span class="hljs-number">0</span>) &#123;<br>                dfs(v);<br>                <span class="hljs-keyword">if</span> (!valid) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (visited[v] == <span class="hljs-number">1</span>) &#123;<br>                valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 回溯</span><br>        visited[u] = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(m+n)</li></ul><h3 id="广度优先搜索-2"><a href="#广度优先搜索-2" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><ol><li>初始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</li><li>在广度优先搜索的每一步中，我们取出队首的节点 u：<ul><li>我们将 u 放入答案中；</li><li>我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。</li></ul></li><li>在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</li><li>由于我们只需要判断是否存在一种拓扑排序，因此我们省去存放答案数组，而是只用一个变量记录被放入答案数组的节点个数。在广度优先搜索结束之后，我们判断该变量的值是否等于课程数，就能知道是否存在一种拓扑排序。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; edges;<br>    <span class="hljs-type">int</span>[] indeg;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites)</span> &#123;<br>        <span class="hljs-comment">// 初始化图</span><br>        edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        indeg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        <span class="hljs-comment">// 建图</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] info : prerequisites) &#123;<br>            edges.get(info[<span class="hljs-number">1</span>]).add(info[<span class="hljs-number">0</span>]);<br>            indeg[info[<span class="hljs-number">0</span>]]++;<br>        &#125;<br>        <span class="hljs-comment">// 广度优先搜索</span><br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            <span class="hljs-keyword">if</span> (indeg[i] == <span class="hljs-number">0</span>) &#123;<br>                queue.offer(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">visited</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            visited++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : edges.get(u)) &#123;<br>                --indeg[v];<br>                <span class="hljs-keyword">if</span> (indeg[v] == <span class="hljs-number">0</span>) &#123;<br>                    queue.offer(v);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> visited == numCourses;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m + n)</li><li>空间复杂度：O(m + n)</li></ul><h2 id="课程表II"><a href="#课程表II" class="headerlink" title="课程表II"></a><a href="https://leetcode.cn/problems/course-schedule-ii/description/?envType=study-plan-v2&envId=top-interview-150">课程表II</a></h2><p>和上一题的不同在于，这里需要记录拓扑排序的路径。</p><h3 id="深度优先搜索-4"><a href="#深度优先搜索-4" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; edges;<br>    <span class="hljs-type">int</span>[] visited;<br>    <span class="hljs-type">int</span>[] res;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> index;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findOrder(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites) &#123;<br>        <span class="hljs-comment">// 初始化图</span><br>        edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        index = numCourses - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 建图</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] info : prerequisites) &#123;<br>            edges.get(info[<span class="hljs-number">1</span>]).add(info[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 深度优先搜索</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses &amp;&amp; valid; i++) &#123;<br>            <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-number">0</span>) &#123;<br>                dfs(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">if</span> (!valid) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125; <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>        <span class="hljs-comment">// 标记已访问过</span><br>        visited[u] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 遍历所有邻接节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : edges.get(u)) &#123;<br>            <span class="hljs-keyword">if</span> (visited[v] == <span class="hljs-number">0</span>) &#123;<br>                dfs(v);<br>                <span class="hljs-keyword">if</span> (!valid) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (visited[v] == <span class="hljs-number">1</span>) &#123;<br>                valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 标记已完成</span><br>        visited[u] = <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 加入结果</span><br>        res[index--] = u;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m + n)</li><li>空间复杂度：O(m + n)</li></ul><h3 id="广度优先搜索-3"><a href="#广度优先搜索-3" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; edges;<br>    <span class="hljs-type">int</span>[] indeg;<br>    <span class="hljs-type">int</span>[] res;<br>    <span class="hljs-type">int</span> index;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findOrder(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites) &#123;<br>        <span class="hljs-comment">// 初始化图</span><br>        edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        indeg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        index = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 建图</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] info : prerequisites) &#123;<br>            edges.get(info[<span class="hljs-number">1</span>]).add(info[<span class="hljs-number">0</span>]);<br>            indeg[info[<span class="hljs-number">0</span>]]++;<br>        &#125;<br><br>        <span class="hljs-comment">// 广度优先搜索</span><br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            <span class="hljs-keyword">if</span> (indeg[i] == <span class="hljs-number">0</span>) &#123;<br>                queue.offer(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">visited</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            visited++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> queue.poll();<br>            res[index++] = u;<br>            <span class="hljs-comment">// 对于所有邻接节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : edges.get(u)) &#123;<br>                --indeg[v];<br>                <span class="hljs-keyword">if</span> (indeg[v] == <span class="hljs-number">0</span>) &#123;<br>                    queue.offer(v);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">if</span> (visited != numCourses) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125; <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m + n)</li><li>空间复杂度：O(m + n)</li></ul><h2 id="蛇梯棋"><a href="#蛇梯棋" class="headerlink" title="蛇梯棋"></a><a href="https://leetcode.cn/problems/snakes-and-ladders/description/?envType=study-plan-v2&envId=top-interview-150">蛇梯棋</a></h2><h3 id="广度优先搜索-4"><a href="#广度优先搜索-4" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>原问题等价于在有向图上求出从 1 到 $n^2$ 的最短路长度。</p><ol><li>抽象成有向图：<ul><li>不是蛇或梯子，添加x指向$x+i(0 \leq i \leq 6)$的边；</li><li>是蛇或梯子，添加x指向y的边；</li></ul></li><li>将节点编号和到达该节点的移动次数作为搜索状态，顺着该节点的出边扩展新状态，直至到达终点，返回此时的移动次数。若无法到达终点则返回 −1。<ul><li>用一个队列来存储搜索状态，初始时将起点状态 (1,0) 加入队列，表示当前位于起点 1，移动次数为 0。</li><li>不断取出队首，每次取出队首元素时扩展新状态，即遍历该节点的出边，若出边对应节点未被访问，则将该节点和移动次数加一的结果作为新状态，加入队列。</li><li>如此循环直至到达终点或队列为空。</li></ul></li><li>需要计算出编号在棋盘中的对应行列，以便从 board 中得到目的地。设编号为 id，由于每行有 n 个数字，其位于棋盘从下往上数的第$r &#x3D; \frac{id-1}{n}$行，由于棋盘的每一行会交替方向，若 r 为偶数，则编号方向从左向右，列号为 $(id−1) \mod n$；若 r 为奇数，则编号方向从右向左，列号为 $n - 1 - ((id - 1) \mod n)$。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">snakesAndLadders</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] board)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-comment">// 标记编号是否已访问过</span><br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n * n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 队列，存储编号和次数</span><br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-comment">// 广度优先搜索</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] point = queue.poll();<br>            <span class="hljs-comment">// 搜索能到达的位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> point[<span class="hljs-number">0</span>] + i;<br>                <span class="hljs-comment">// 超出边界</span><br>                <span class="hljs-keyword">if</span> (next &gt; n * n) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 计算下一步到达的位置</span><br>                <span class="hljs-type">int</span>[] rc = id2rc(next, n);<br>                <span class="hljs-comment">// 存在蛇或梯子</span><br>                <span class="hljs-keyword">if</span> (board[rc[<span class="hljs-number">0</span>]][rc[<span class="hljs-number">1</span>]] &gt; <span class="hljs-number">0</span>) &#123;<br>                    next = board[rc[<span class="hljs-number">0</span>]][rc[<span class="hljs-number">1</span>]];<br>                &#125;<br>                <span class="hljs-comment">// 到达终点</span><br>                <span class="hljs-keyword">if</span> (next == n * n) &#123;<br>                    <span class="hljs-keyword">return</span> point[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-comment">// 未访问过，加入队列</span><br>                <span class="hljs-keyword">if</span> (!visited[next]) &#123;<br>                    visited[next] = <span class="hljs-literal">true</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;next, point[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// id转换为行列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] id2rc(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (id - <span class="hljs-number">1</span>) / n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (id - <span class="hljs-number">1</span>) % n;<br>        <span class="hljs-keyword">if</span> (r % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            c = n - <span class="hljs-number">1</span> - c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;n - <span class="hljs-number">1</span> - r, c&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n^2)$</li></ul><h2 id="最小基因变化"><a href="#最小基因变化" class="headerlink" title="最小基因变化"></a><a href="https://leetcode.cn/problems/minimum-genetic-mutation/description/?envType=study-plan-v2&envId=top-interview-150">最小基因变化</a></h2><h3 id="广度优先搜索-5"><a href="#广度优先搜索-5" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><ol><li>定义两个哈希表存放基因库和基因序列是否访问过。</li><li>定义队列，存放基因序列。</li><li>广度优先搜索：<ul><li>弹出当前层基因序列，然后对其所有可能的24种变化做处理：</li><li>如果变化到end，直接返回步数；</li><li>否则加入队列，标记已访问过。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minMutation</span><span class="hljs-params">(String startGene, String endGene, String[] bank)</span> &#123;<br>        <span class="hljs-comment">// 定义哈希表存储基因库和标记</span><br>        Set&lt;String&gt; cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        Set&lt;String&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] keys = &#123;<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>&#125;;<br>        <span class="hljs-keyword">for</span> (String w : bank) &#123;<br>            cnt.add(w);<br>        &#125;<br>        <span class="hljs-comment">// 特殊情况</span><br>        <span class="hljs-keyword">if</span> (startGene.equals(endGene)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!cnt.contains(endGene)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 定义队列</span><br>        Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(startGene);<br>        visited.add(startGene);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 广度优先</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                        <span class="hljs-comment">// 基因变化</span><br>                        <span class="hljs-keyword">if</span> (keys[k] != cur.charAt(j)) &#123;<br>                            <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(cur);<br>                            sb.setCharAt(j, keys[k]);<br>                            <span class="hljs-comment">// 没出现过且存在于基因库</span><br>                            <span class="hljs-type">String</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> sb.toString();<br>                            <span class="hljs-keyword">if</span> (!visited.contains(next) &amp;&amp; cnt.contains(next)) &#123;<br>                                <span class="hljs-comment">// 变化到endGene</span><br>                                <span class="hljs-keyword">if</span> (next.equals(endGene)) &#123;<br>                                    <span class="hljs-keyword">return</span> step;<br>                                &#125;<br>                                queue.offer(next);<br>                                visited.add(next);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            step++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(C×n×m)，其中 n 为基因序列的长度，m 为数组 bank 的长度。对于队列中的每个合法的基因序列每次都需要计算 C×n 种变化，在这里 C&#x3D;4；队列中最多有 m 个元素，因此时间复杂度为 O(C×n×m)。</li><li>空间复杂度：O(n×m)，其中 n 为基因序列的长度，m 为数组 bank 的长度。合法性的哈希表中一共存有 m 个元素，队列中最多有 m 个元素，每个元素的空间为 O(n)；队列中最多有 m 个元素，每个元素的空间为 O(n)，因此空间复杂度为 O(n×m)。</li></ul><h3 id="预处理优化"><a href="#预处理优化" class="headerlink" title="预处理优化"></a>预处理优化</h3><ol><li>邻接表的构建：<ul><li>adj[i] 存储与基因 bank[i] 相差一个字符的基因的索引。</li><li>通过遍历 bank 中的基因对，比较每两个基因之间的差异，如果差异只有一个字符，就在它们之间建立连接。</li></ul></li><li>广度优先搜索（BFS）：<ul><li>在 BFS 中，我们从 start 基因出发，找到所有与它相差一个字符的基因，并将它们放入队列。</li><li>之后从队列中取出基因，查找它的邻接基因，直到找到 end 基因，返回步数。</li><li>如果队列为空，且未找到 end，则返回 -1，表示无法从 start 到达 end。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// minMutation 方法：计算从 start 到 end 基因的最小变异步数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minMutation</span><span class="hljs-params">(String start, String end, String[] bank)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> start.length();  <span class="hljs-comment">// 基因字符串的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> bank.length;  <span class="hljs-comment">// 基因库的大小</span><br>        <span class="hljs-comment">// 创建一个邻接表（图）adj，存储每个基因与其他基因的连接关系</span><br>        List&lt;Integer&gt;[] adj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            adj[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();  <span class="hljs-comment">// 初始化每个基因的邻接列表</span><br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">endIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 记录 end 基因在基因库中的索引</span><br>        <span class="hljs-comment">// 连接每对相差一个字符的基因</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (end.equals(bank[i])) &#123;<br>                endIndex = i;  <span class="hljs-comment">// 找到 end 基因的索引</span><br>            &#125;<br>            <span class="hljs-comment">// 遍历所有基因库中的基因，查找与当前基因相差一个字符的基因</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mutations</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录两个基因之间的字符差异数</span><br>                <span class="hljs-comment">// 比较两个基因的每个字符</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; m; k++) &#123;<br>                    <span class="hljs-keyword">if</span> (bank[i].charAt(k) != bank[j].charAt(k)) &#123;<br>                        mutations++;  <span class="hljs-comment">// 如果字符不同，差异数加1</span><br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (mutations &gt; <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 如果差异数超过1，跳出循环</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 如果两个基因之间只有一个字符的差异，建立邻接关系</span><br>                <span class="hljs-keyword">if</span> (mutations == <span class="hljs-number">1</span>) &#123;<br>                    adj[i].add(j);  <span class="hljs-comment">// 将 j 基因加入 i 基因的邻接列表</span><br>                    adj[j].add(i);  <span class="hljs-comment">// 将 i 基因加入 j 基因的邻接列表</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果在基因库中没有找到 end 基因，返回 -1</span><br>        <span class="hljs-keyword">if</span> (endIndex == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 广度优先搜索（BFS）队列</span><br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];  <span class="hljs-comment">// 标记基因是否已被访问过</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 步数，从 start 基因开始计数</span><br><br>        <span class="hljs-comment">// 将与 start 基因相差一个字符的基因加入队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mutations</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录 start 基因和 bank[i] 基因的差异数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; m; k++) &#123;<br>                <span class="hljs-keyword">if</span> (start.charAt(k) != bank[i].charAt(k)) &#123;<br>                    mutations++;  <span class="hljs-comment">// 如果字符不同，差异数加1</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> (mutations &gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 如果差异数超过1，跳出循环</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果 start 和 bank[i] 只有一个字符差异，将 bank[i] 加入队列</span><br>            <span class="hljs-keyword">if</span> (mutations == <span class="hljs-number">1</span>) &#123;<br>                queue.offer(i);  <span class="hljs-comment">// 将 bank[i] 的索引加入队列</span><br>                visited[i] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记 bank[i] 为已访问</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 使用 BFS 进行最短路径查找</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> queue.size();  <span class="hljs-comment">// 当前队列中的元素数量（即当前层的节点数）</span><br>            <span class="hljs-comment">// 遍历当前层的所有节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> queue.poll();  <span class="hljs-comment">// 从队列中取出一个基因</span><br>                <span class="hljs-keyword">if</span> (curr == endIndex) &#123;<br>                    <span class="hljs-keyword">return</span> step;  <span class="hljs-comment">// 如果找到了 end 基因，返回当前的步数</span><br>                &#125;<br>                <span class="hljs-comment">// 遍历当前基因的所有邻接基因</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : adj[curr]) &#123;<br>                    <span class="hljs-keyword">if</span> (visited[next]) &#123;<br>                        <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 如果下一个基因已被访问过，跳过</span><br>                    &#125;<br>                    visited[next] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 标记下一个基因为已访问</span><br>                    queue.offer(next);  <span class="hljs-comment">// 将下一个基因加入队列</span><br>                &#125;<br>            &#125;<br>            step++;  <span class="hljs-comment">// 完成一层遍历，步数加1</span><br>        &#125;<br><br>        <span class="hljs-comment">// 如果 BFS 完成后仍未找到 end 基因，返回 -1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(m \times n ^ 2)$</li><li>空间复杂度：$O(n ^ 2)$</li></ul><p>不是很懂为什么方法二要给出一个时间复杂度更高的解法。</p><h2 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a><a href="https://leetcode.cn/problems/word-ladder/?envType=study-plan-v2&envId=top-interview-150">单词接龙</a></h2><h3 id="广度优先搜索-6"><a href="#广度优先搜索-6" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>和上一题类似，把每个单词都抽象为一个点，如果两个单词可以只改变一个字母进行转换，那么说明他们之间有一条双向边。因此我们只需要把满足转换条件的点相连，就形成了一张图。基于该图，以 beginWord 为图的起点，以 endWord 为终点进行广度优先搜索，寻找 beginWord 到 endWord 的最短路径。</p><ol><li>先给每一个单词标号，即给每个单词分配一个 id。创建一个由单词 word 到 id 对应的映射 wordId，并将 beginWord 与 wordList 中所有的单词都加入这个映射中。之后我们检查 endWord 是否在该映射内，若不存在，则输入无解。我们可以使用哈希表实现上面的映射关系。</li><li>枚举每一对单词的组合，判断它们是否恰好相差一个字符，以判断这两个单词对应的节点是否能够相连。但是这样效率太低，我们可以优化建图。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 定义单词到id映射和邻接表</span><br>    Map&lt;String, Integer&gt; word2id = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; edge = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">nodeNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ladderLength</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;<br>        <span class="hljs-comment">// 建立图</span><br>        <span class="hljs-keyword">for</span> (String word : wordList) &#123;<br>            addEdge(word);<br>        &#125;<br>        <span class="hljs-comment">// 起始节点加入图</span><br>        addEdge(beginWord);<br>        <span class="hljs-comment">// 边界处理</span><br>        <span class="hljs-keyword">if</span> (!word2id.containsKey(endWord)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 定义距离数组，表示beginWord到当前节点的距离</span><br>        <span class="hljs-type">int</span>[] dis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nodeNum];<br>        Arrays.fill(dis, Integer.MAX_VALUE);<br>        <span class="hljs-comment">// 起点终点索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">beginId</span> <span class="hljs-operator">=</span> word2id.get(beginWord);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">endId</span> <span class="hljs-operator">=</span> word2id.get(endWord);<br>        dis[beginId] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 广度优先搜索</span><br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(beginId);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span> (x == endId) &#123;<br>                <span class="hljs-keyword">return</span> dis[x] / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 将所有相邻节点加入队列</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it : edge.get(x)) &#123;<br>                <span class="hljs-keyword">if</span> (dis[it] == Integer.MAX_VALUE) &#123;<br>                    dis[it] = dis[x] + <span class="hljs-number">1</span>;<br>                    queue.offer(it);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 建立边</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEdge</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-comment">// 加入映射</span><br>        addWord(word);<br>        <span class="hljs-comment">// 获取id</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">id1</span> <span class="hljs-operator">=</span> word2id.get(word);<br>        <span class="hljs-type">char</span>[] array = word.toCharArray();<br>        <span class="hljs-comment">// 创建虚拟节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> array[i];<br>            array[i] = <span class="hljs-string">&#x27;*&#x27;</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">newWord</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(array);<br>            addWord(newWord);<br>            <span class="hljs-comment">// 添加边</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">id2</span> <span class="hljs-operator">=</span> word2id.get(newWord);<br>            edge.get(id1).add(id2);<br>            edge.get(id2).add(id1);<br>            <span class="hljs-comment">// 还原</span><br>            array[i] = tmp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加单词至映射</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWord</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!word2id.containsKey(word)) &#123;<br>            word2id.put(word, nodeNum++);<br>            edge.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(N \times C^2)$，其中 N 为 wordList 的长度，C 为列表中单词的长度。</li><li>空间复杂度：$O(N \times C^2)$。</li></ul><h3 id="双向广度优先搜索"><a href="#双向广度优先搜索" class="headerlink" title="双向广度优先搜索"></a>双向广度优先搜索</h3><p>一边从 beginWord 开始，另一边从 endWord 开始。我们每次从两边各扩展一层节点，当发现某一时刻两边都访问过同一顶点时就停止搜索。这就是双向广度优先搜索，它可以可观地减少搜索空间大小，从而提高代码运行效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 定义单词到id映射和邻接表</span><br>    Map&lt;String, Integer&gt; word2id = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; edge = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">nodeNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ladderLength</span><span class="hljs-params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;<br>        <span class="hljs-comment">// 建立图</span><br>        <span class="hljs-keyword">for</span> (String word : wordList) &#123;<br>            addEdge(word);<br>        &#125;<br>        <span class="hljs-comment">// 起始节点加入图</span><br>        addEdge(beginWord);<br>        <span class="hljs-comment">// 边界处理</span><br>        <span class="hljs-keyword">if</span> (!word2id.containsKey(endWord)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 定义距离数组，表示beginWord到当前节点的距离</span><br>        <span class="hljs-type">int</span>[] disBegin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nodeNum];<br>        Arrays.fill(disBegin, Integer.MAX_VALUE);<br>        <span class="hljs-comment">// 起点终点索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">beginId</span> <span class="hljs-operator">=</span> word2id.get(beginWord);<br>        disBegin[beginId] = <span class="hljs-number">0</span>;<br>        Queue&lt;Integer&gt; queBegin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queBegin.offer(beginId);<br><br>        <span class="hljs-comment">// 定义距离数组，表示endWord到当前节点的距离</span><br>        <span class="hljs-type">int</span>[] disEnd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nodeNum];<br>        Arrays.fill(disEnd, Integer.MAX_VALUE);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">endId</span> <span class="hljs-operator">=</span> word2id.get(endWord);<br>        disEnd[endId] = <span class="hljs-number">0</span>;<br>        Queue&lt;Integer&gt; queEnd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queEnd.offer(endId);<br><br>        <span class="hljs-comment">// 广度优先搜索</span><br>        <span class="hljs-keyword">while</span> (!queBegin.isEmpty() &amp;&amp; !queEnd.isEmpty()) &#123;<br>            <span class="hljs-comment">// 从begin开始</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">queBeginSize</span> <span class="hljs-operator">=</span> queBegin.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queBeginSize; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nodeBegin</span> <span class="hljs-operator">=</span> queBegin.poll();<br>                <span class="hljs-comment">// 如果从后向前的搜索已经搜索过该节点</span><br>                <span class="hljs-keyword">if</span> (disEnd[nodeBegin] != Integer.MAX_VALUE) &#123;<br>                    <span class="hljs-keyword">return</span> (disBegin[nodeBegin] + disEnd[nodeBegin]) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-comment">// 所有相邻节点加入队列</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it : edge.get(nodeBegin)) &#123;<br>                    <span class="hljs-keyword">if</span> (disBegin[it] == Integer.MAX_VALUE) &#123;<br>                        disBegin[it] = disBegin[nodeBegin] + <span class="hljs-number">1</span>;<br>                        queBegin.offer(it);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 从end开始</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">queEndSize</span> <span class="hljs-operator">=</span> queEnd.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queEndSize; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nodeEnd</span> <span class="hljs-operator">=</span> queEnd.poll();<br>                <span class="hljs-comment">// 如果从前向后已经搜索过该节点</span><br>                <span class="hljs-keyword">if</span> (disBegin[nodeEnd] != Integer.MAX_VALUE) &#123;<br>                    <span class="hljs-keyword">return</span> (disBegin[nodeEnd] + disEnd[nodeEnd]) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-comment">// 所有相邻节点加入队列</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it : edge.get(nodeEnd)) &#123;<br>                    <span class="hljs-keyword">if</span> (disEnd[it] == Integer.MAX_VALUE) &#123;<br>                        disEnd[it] = disEnd[nodeEnd] + <span class="hljs-number">1</span>;<br>                        queEnd.offer(it);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 建立边</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEdge</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-comment">// 加入映射</span><br>        addWord(word);<br>        <span class="hljs-comment">// 获取id</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">id1</span> <span class="hljs-operator">=</span> word2id.get(word);<br>        <span class="hljs-type">char</span>[] array = word.toCharArray();<br>        <span class="hljs-comment">// 创建虚拟节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> array[i];<br>            array[i] = <span class="hljs-string">&#x27;*&#x27;</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">newWord</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(array);<br>            addWord(newWord);<br>            <span class="hljs-comment">// 添加边</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">id2</span> <span class="hljs-operator">=</span> word2id.get(newWord);<br>            edge.get(id1).add(id2);<br>            edge.get(id2).add(id1);<br>            <span class="hljs-comment">// 还原</span><br>            array[i] = tmp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加单词至映射</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWord</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!word2id.containsKey(word)) &#123;<br>            word2id.put(word, nodeNum++);<br>            edge.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(N \times C^2)$</li><li>空间复杂度：$O(N \times C^2)$</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>图的问题主要解决方法是深度优先搜索、广度优先搜索和并查集，以后要多加复习。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试经典 150 题-二叉树</title>
    <link href="/2025/01/15/posts/hot150-9/"/>
    <url>/2025/01/15/posts/hot150-9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-二叉树"><a href="#LeetCode-面试经典-150-题-二叉树" class="headerlink" title="LeetCode 面试经典 150 题-二叉树"></a>LeetCode 面试经典 150 题-二叉树</h1><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150">二叉树的最大深度</a></h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>当前节点最大深度为max(左子树最大深度, 右子树最大深度) + 1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：最坏情况下，二叉树退化成一条链，递归需要 O(n) 的栈空间。</li></ul><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量 ans 来维护拓展的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 定义队列</span><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-comment">// 广度优先搜索</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-comment">// 遍历每一层所有结点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.poll();<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    que.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a><a href="https://leetcode.cn/problems/same-tree/?envType=study-plan-v2&envId=top-interview-150">相同的树</a></h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>如果当前结点不相同，则返回false，否则递归判断左子树和右子树是否相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSameTree</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p.val != q.val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/?envType=study-plan-v2&envId=top-interview-150">翻转二叉树</a></h2><h3 id="深度优先搜索-1"><a href="#深度优先搜索-1" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ol><li>边界处理，为空直接返回；</li><li>递归翻转左右子树；</li><li>翻转当前结点；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 递归翻转左右子树</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> invertTree(root.left);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> invertTree(root.right);<br>        <span class="hljs-comment">// 交换当前左右子树</span><br>        root.left = right;<br>        root.right = left;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/?envType=study-plan-v2&envId=top-interview-150">对称二叉树</a></h2><h3 id="深度优先搜索-2"><a href="#深度优先搜索-2" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>需要判断左右子树值是否相等，以及左子树的左子树是否等于右子树的右子树，以及左子树的右子树是否等于右子树的左子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// 边界处理</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> helper(root.left, root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> || right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> left == right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left.val == right.val &amp;&amp; helper(left.left, right.right) &amp;&amp; helper(left.right, right.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="广度优先搜索-1"><a href="#广度优先搜索-1" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>使用队列实现，每次弹出两个结点，比较其是否相等，在添加结点时，按照相反的顺序添加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        que.offer(root);<br>        que.offer(root);<br><br>        <span class="hljs-comment">// 广度优先搜索</span><br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> que.poll();<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> que.poll();<br>            <span class="hljs-comment">// 如果为空</span><br>            <span class="hljs-keyword">if</span> (u == <span class="hljs-literal">null</span> &amp;&amp; v == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (u == <span class="hljs-literal">null</span> || v == <span class="hljs-literal">null</span> || u.val != v.val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <br><br>            <span class="hljs-comment">// 交错顺序放入队列</span><br>            que.offer(u.left);<br>            que.offer(v.right);<br>            que.offer(u.right);<br>            que.offer(v.left);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&envId=top-interview-150">从前序与中序遍历序列构造二叉树</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li>将中序遍历序列存入哈希表，方便查找。</li><li>定义递归函数处理：<ol><li>递归结束：前序数组遍历完；</li><li>O(1)时间在中序遍历中找到根节点；</li><li>递归遍历左右子树；</li><li>连接子树，返回当前节点；</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> preorder.length;<br>        Map&lt;Integer, Integer&gt; index = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            index.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(preorder, index, <span class="hljs-number">0</span>, n, <span class="hljs-number">0</span>, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, Map&lt;Integer, Integer&gt; index, <span class="hljs-type">int</span> preL, <span class="hljs-type">int</span> preR, <span class="hljs-type">int</span> inL, <span class="hljs-type">int</span> inR)</span> &#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (preL == preR) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 计算左子树大小</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSize</span> <span class="hljs-operator">=</span> index.get(preorder[preL]) - inL;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs(preorder, index, preL + <span class="hljs-number">1</span>, preL+<span class="hljs-number">1</span>+leftSize, inL, inL+leftSize);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs(preorder, index, preL+<span class="hljs-number">1</span>+leftSize, preR, inL+<span class="hljs-number">1</span>+leftSize, inR);<br>        <span class="hljs-comment">// 连接子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preL], left, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/?envType=study-plan-v2&envId=top-interview-150">从中序与后序遍历序列构造二叉树</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>同上题:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> inorder.length;<br>        <span class="hljs-comment">// 将中序序列存入哈希表</span><br>        Map&lt;Integer, Integer&gt; index = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            index.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(postorder, index, <span class="hljs-number">0</span>, n, <span class="hljs-number">0</span>, n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder, Map&lt;Integer, Integer&gt; index, <span class="hljs-type">int</span> postL, <span class="hljs-type">int</span> postR, <span class="hljs-type">int</span> inL, <span class="hljs-type">int</span> inR)</span> &#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (postL == postR) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 计算左右子树</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSize</span> <span class="hljs-operator">=</span> index.get(postorder[postR-<span class="hljs-number">1</span>]) - inL;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs(postorder, index, postL, postL + leftSize, inL, inL + leftSize);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs(postorder, index, postL + leftSize, postR - <span class="hljs-number">1</span>, inL + leftSize + <span class="hljs-number">1</span>, inR);<br><br>        <span class="hljs-comment">// 连接子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(postorder[postR-<span class="hljs-number">1</span>], left, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="填充每个节点的下一个右侧节点指针II"><a href="#填充每个节点的下一个右侧节点指针II" class="headerlink" title="填充每个节点的下一个右侧节点指针II"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/?envType=study-plan-v2&envId=top-interview-150">填充每个节点的下一个右侧节点指针II</a></h2><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>使用队列实现层序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">// 定义队列</span><br>        Queue&lt;Node&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-comment">// 广度优先搜索</span><br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.poll();<br>                <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;<br>                    pre.next = node;<br>                &#125;<br>                pre = node;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    que.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    que.offer(node.right);<br>                &#125;<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="BFS-链表"><a href="#BFS-链表" class="headerlink" title="BFS+链表"></a>BFS+链表</h3><ul><li>从第一层开始（第一层只有一个 root 节点），每次循环：</li><li>遍历当前层的链表节点，通过节点的 left 和 right 得到下一层的节点。</li><li>把下一层的节点从左到右连接成一个链表。</li><li>拿到下一层链表的头节点，进入下一轮循环。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <br>        <span class="hljs-comment">// 广度优先搜索</span><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            dummy.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">nxt</span> <span class="hljs-operator">=</span> dummy;   <span class="hljs-comment">// 下一层链表</span><br>            <span class="hljs-comment">// 遍历当前层链表</span><br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                    nxt.next = cur.left;<br>                    nxt = cur.left;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                    nxt.next = cur.right;<br>                    nxt = cur.right;<br>                &#125;<br>                cur = cur.next; <span class="hljs-comment">// 当前层下一个节点</span><br>            &#125;<br>            <span class="hljs-comment">// 下一层链表</span><br>            cur = dummy.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?envType=study-plan-v2&envId=top-interview-150">二叉树展开为链表</a></h2><h3 id="先序遍历-递归"><a href="#先序遍历-递归" class="headerlink" title="先序遍历-递归"></a>先序遍历-递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;TreeNode&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        preOrder(root, arr);<br><br>        <span class="hljs-comment">// 把先序遍历的结果链接成链表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.size(); i++) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> arr.get(i - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> arr.get(i);<br>            pre.left = <span class="hljs-literal">null</span>;<br>            pre.right = cur;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode root, List&lt;TreeNode&gt; arr)</span> &#123;<br>        <span class="hljs-comment">// 按照根、左、右的顺序</span><br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            arr.add(root);<br>            preOrder(root.left, arr);<br>            preOrder(root.right, arr);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="先序遍历-迭代"><a href="#先序遍历-迭代" class="headerlink" title="先序遍历-迭代"></a>先序遍历-迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;TreeNode&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 迭代</span><br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>                arr.add(node);<br>                stack.push(node);<br>                node = node.left;<br>            &#125;<br>            node = stack.pop();<br>            node = node.right;<br>        &#125;<br><br>        <span class="hljs-comment">// 把先序遍历的结果链接成链表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.size(); i++) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> arr.get(i - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> arr.get(i);<br>            pre.left = <span class="hljs-literal">null</span>;<br>            pre.right = cur;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><ol><li>将左子树插入到右子树的地方</li><li>将原来的右子树接到左子树的最右边节点</li><li>考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 左子树为空，考虑下一个节点</span><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) &#123;<br>                root = root.right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 找到左子树上最右边的节点</span><br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> root.left;<br>                <span class="hljs-keyword">while</span> (pre.right != <span class="hljs-literal">null</span>) &#123;<br>                    pre = pre.right;<br>                &#125;<br>                <span class="hljs-comment">// 将根节点右子树链到左子树最右边节点的右子树上</span><br>                pre.right = root.right;<br>                <span class="hljs-comment">// 左子树放到右子树</span><br>                root.right = root.left;<br>                root.left = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// 下一个节点</span><br>                root = root.right;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="后序遍历-递归"><a href="#后序遍历-递归" class="headerlink" title="后序遍历-递归"></a>后序遍历-递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        flatten(root.right);<br>        flatten(root.left);<br>        root.right = pre;<br>        root.left = <span class="hljs-literal">null</span>;<br>        pre = root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="后序遍历-迭代"><a href="#后序遍历-迭代" class="headerlink" title="后序遍历-迭代"></a>后序遍历-迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Deque&lt;TreeNode&gt; stack  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-comment">// 右子树入栈</span><br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur);<br>                cur = cur.right;<br>            &#125;<br>            cur = stack.peek();<br>            <span class="hljs-comment">// 在不存在左节点或者右节点已经访问过的情况下，访问根节点</span><br>            <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> || cur.left == pre) &#123;<br>                stack.pop();<br>                cur.right = pre;<br>                cur.left = <span class="hljs-literal">null</span>;<br>                pre = cur;<br>                cur = <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 先访问左子树</span><br>                cur = cur.left;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a><a href="https://leetcode.cn/problems/path-sum/?envType=study-plan-v2&envId=top-interview-150">路径总和</a></h2><h3 id="深度优先搜索-3"><a href="#深度优先搜索-3" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ul><li>递归结束：当前节点为空，返回false。如果当前节点为叶子结点，则判断当前节点值是否等于target。</li><li>递归计算左右子树。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root.val == targetSum;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="广度优先搜索-2"><a href="#广度优先搜索-2" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>队列中存储结点和当前路径和的键值对，在广度遍历的过程中判断是否是叶子节点且和满足条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 队列中存储的是 (当前节点, 当前路径和)</span><br>        Queue&lt;Pair&lt;TreeNode, Integer&gt;&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(root, root.val));<br><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-comment">// 获取当前节点和当前路径和</span><br>            Pair&lt;TreeNode, Integer&gt; pair = queue.poll();<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> pair.getKey();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currentSum</span> <span class="hljs-operator">=</span> pair.getValue();<br><br>            <span class="hljs-comment">// 判断是否为叶子节点且路径和等于目标值</span><br>            <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span> &amp;&amp; currentSum == targetSum) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 向队列中添加左右子节点</span><br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(node.left, currentSum + node.left.val));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(node.right, currentSum + node.right.val));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果遍历完队列仍然没有找到符合条件的路径</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="求根节点到叶节点的数字之和"><a href="#求根节点到叶节点的数字之和" class="headerlink" title="求根节点到叶节点的数字之和"></a><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/?envType=study-plan-v2&envId=top-interview-150">求根节点到叶节点的数字之和</a></h2><h3 id="递归-无返回值"><a href="#递归-无返回值" class="headerlink" title="递归-无返回值"></a>递归-无返回值</h3><ul><li>递归结束：节点为空。</li><li>递归计算左子树数字、右子树数字，求和。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> curNum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        curNum = curNum * <span class="hljs-number">10</span> + root.val;<br>        <span class="hljs-comment">// 如果是叶子节点</span><br>        <span class="hljs-keyword">if</span> (root.left == root.right) &#123;<br>            ans += curNum;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        dfs(root.left, curNum);<br>        dfs(root.right, curNum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归-有返回值"><a href="#递归-有返回值" class="headerlink" title="递归-有返回值"></a>递归-有返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> curNum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        curNum = curNum * <span class="hljs-number">10</span> + root.val;<br>        <span class="hljs-comment">// 如果是叶子节点</span><br>        <span class="hljs-keyword">if</span> (root.left == root.right) &#123;<br>            <span class="hljs-keyword">return</span> curNum;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dfs(root.left, curNum) + dfs(root.right, curNum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=top-interview-150">二叉树中的最大路径和</a></h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><ol><li>定义递归函数，返回值是从当前节点到叶子节点的最大和，其值等于当前节点值+max(左子树最大和，右子树最大和)。</li><li>同时更新最大路径和，区分其与dfs的返回值，它应该等于左子树最大和+右子树最大和+当前节点值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 递归计算左右子树最大和，注意如果是负数，那就不算这些节点，直接取0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, dfs(root.left));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, dfs(root.right));<br><br>        <span class="hljs-comment">// 更新全局最大路径和</span><br>        ans = Math.max(ans, left + right + root.val);<br><br>        <span class="hljs-keyword">return</span> root.val + Math.max(left, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="二叉搜索树迭代器"><a href="#二叉搜索树迭代器" class="headerlink" title="二叉搜索树迭代器"></a><a href="https://leetcode.cn/problems/binary-search-tree-iterator/?envType=study-plan-v2&envId=top-interview-150">二叉搜索树迭代器</a></h2><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> idx;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; arr;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTIterator</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        idx = <span class="hljs-number">0</span>;<br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        inorderTraversal(root);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> arr.get(idx++);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> idx &lt; arr.size();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inorderTraversal(root.left);<br>        arr.add(root.val);<br>        inorderTraversal(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span> &#123;<br><br>    <span class="hljs-keyword">private</span> TreeNode cur;<br>    <span class="hljs-keyword">private</span> Deque&lt;TreeNode&gt; stack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTIterator</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        cur = root;<br>        stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(cur);<br>            cur = cur.left;<br>        &#125;<br>        cur = stack.pop();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> cur.val;<br>        cur = cur.right;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cur != <span class="hljs-literal">null</span> || !stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/?envType=study-plan-v2&envId=top-interview-150">完全二叉树的节点个数</a></h2><h3 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h3><ul><li>递归结束：如果节点为空，返回0.</li><li>递归计算左右子树，加1.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="二分查找-位运算"><a href="#二分查找-位运算" class="headerlink" title="二分查找+位运算"></a>二分查找+位运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 计算完全二叉树的节点数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// 如果树为空，节点数为0</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算树的深度（height），从根节点一直向左走</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>            level++;<br>            node = node.left; <span class="hljs-comment">// 一直沿着左子树遍历，直到到达最左的叶子节点</span><br>        &#125;<br><br>        <span class="hljs-comment">// low 和 high 表示最后一层的节点编号范围</span><br>        <span class="hljs-comment">// 2^level 是最后一层最小编号，(2^(level+1) - 1) 是最后一层最大编号</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; level; <span class="hljs-comment">// 2^level</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; (level + <span class="hljs-number">1</span>)) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 2^(level+1) - 1</span><br><br>        <span class="hljs-comment">// 使用二分查找来确定最后一层的节点数量</span><br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>            <span class="hljs-comment">// 计算中间节点编号</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (high - low + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + low;<br>            <span class="hljs-comment">// 检查编号为 mid 的节点是否存在</span><br>            <span class="hljs-keyword">if</span> (exists(root, level, mid)) &#123;<br>                <span class="hljs-comment">// 如果节点存在，则说明低位的节点编号存在，移动 low</span><br>                low = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果节点不存在，则说明高位的节点编号存在，移动 high</span><br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 最终的 low 就是节点总数</span><br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断完全二叉树中，编号为 k 的节点是否存在</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exists</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 从树的根开始，检查路径是否存在</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bits</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; (level - <span class="hljs-number">1</span>); <span class="hljs-comment">// 2^(level-1)，用于判断该节点的路径</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br><br>        <span class="hljs-comment">// 根据二进制位来决定向左还是向右走</span><br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span> &amp;&amp; bits &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((bits &amp; k) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 如果 k 对应的位是 0，则走左子树</span><br>                node = node.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果 k 对应的位是 1，则走右子树</span><br>                node = node.right;<br>            &#125;<br>            bits &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 移动到下一个二进制位</span><br>        &#125;<br><br>        <span class="hljs-comment">// 如果最后到达的节点不是 null，则说明节点存在</span><br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(h^2)$</li><li>空间复杂度：O(1)</li></ul><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150">二叉树的最近公共祖先</a></h2><h3 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h3><ul><li>遍历树，如果当前节点为空，或者等于p或q，则最近公共祖先就是该节点本身；</li><li>否则递归遍历左右子树，如果得到的左右公共祖先都不为空，说明p、q分列左右子树，那么当前节点就是最近公共祖先；</li><li>否则p、q同位于左子树或者同位于右子树。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root == p || root == q) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">// 递归查找左右子树</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p, q);<br>        <span class="hljs-comment">// 分列于左右子树</span><br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">// 位于左子树或右子树</span><br>        <span class="hljs-keyword">return</span> left == <span class="hljs-literal">null</span> ? right : left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&envId=top-interview-150">二叉树的右视图</a></h2><h3 id="递归-5"><a href="#递归-5" class="headerlink" title="递归"></a>递归</h3><p>找每一层最右边的节点：</p><ol><li>用一个变量记录当前遍历到的深度，如果当前结果数组的大小等于深度，说明是首次到达该深度，将当前节点加入结果集。</li><li>先递归遍历右子树，再递归遍历左子树。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> depth)</span> &#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 首次到达depth</span><br>        <span class="hljs-keyword">if</span> (ans.size() == depth) &#123;<br>            ans.add(root.val);<br>        &#125;<br>        <span class="hljs-comment">// 先递归右子树，再递归左子树</span><br>        dfs(root.right, depth + <span class="hljs-number">1</span>);<br>        dfs(root.left, depth + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>用队列实现层序遍历，将每一层最后一个结点加入结果集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.poll();<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    que.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    que.add(node.right);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i == size - <span class="hljs-number">1</span>) &#123;<br>                    ans.add(node.val);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150">二叉树的层平均值</a></h2><h3 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h3><p>计算每一层的和&#x2F;节点个数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Double&gt; <span class="hljs-title function_">averageOfLevels</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Double&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        que.offer(root);<br><br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> que.size();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.poll();<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) que.offer(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) que.offer(node.right);<br>                sum += node.val;<br>            &#125;<br>            ans.add(sum * <span class="hljs-number">1.0</span> / n);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>注意sum要用long防止溢出。</p><h2 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title="二叉树的锯齿形层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/?envType=study-plan-v2&envId=top-interview-150">二叉树的锯齿形层序遍历</a></h2><h3 id="层序遍历-1"><a href="#层序遍历-1" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>把奇数层节点逆转即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">zigzagLevelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> que.size();<br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> que.poll();<br>                tmp.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    que.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    que.offer(node.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 从右到左</span><br>            <span class="hljs-keyword">if</span> (ans.size() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                Collections.reverse(tmp);<br>            &#125;<br>            ans.add(tmp);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/?envType=study-plan-v2&envId=top-interview-150">二叉搜索树的最小绝对差</a></h2><h3 id="深度优先搜索-4"><a href="#深度优先搜索-4" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>把数字排序后，最小差值一定是相邻两个数的差值。由于二叉搜索树的中序遍历得到的序列是有序的，我们可以计算中序遍历中的相邻两数的差值，取最小值，即为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.left);<br><br>        <span class="hljs-keyword">if</span> (pre == -<span class="hljs-number">1</span>) &#123;<br>            pre = root.val;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans = Math.min(ans, root.val - pre);<br>            pre = root.val;<br>        &#125;<br>        <br>        dfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素"></a><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/?envType=study-plan-v2&envId=top-interview-150">二叉搜索树中第K小的元素</a></h2><h3 id="深度优先搜索-5"><a href="#深度优先搜索-5" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ol><li>中序遍历：递归遍历二叉树的左子树、访问根节点、然后遍历右子树。</li><li>计数与判断：每访问一个节点，count 就增加。当 count &#x3D;&#x3D; k 时，表示当前节点是我们要找的第 k 小节点。</li><li>提前结束：一旦找到了第 k 小的元素，就不再继续递归，直接返回结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 用来记录当前遍历到的节点数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 存储第 k 小的值</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        dfs(root, k);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || result != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历左子树</span><br>        dfs(root.left, k);<br>        <br>        <span class="hljs-comment">// 访问当前节点</span><br>        count++;<br>        <span class="hljs-keyword">if</span> (count == k) &#123;<br>            result = root.val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历右子树</span><br>        dfs(root.right, k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/?envType=study-plan-v2&envId=top-interview-150">验证二叉搜索树</a></h2><p>做一次错一次，例如虽然左子树节点值小于父节点值，右子树节点值大于父节点值，但没有检查左子树和右子树的节点是否满足这些范围限制。</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> left, <span class="hljs-type">long</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> root.val;<br>        <span class="hljs-keyword">return</span> left &lt; x &amp;&amp; x &lt; right &amp;&amp; isValid(root.left, left, x) &amp;&amp; isValid(root.right, x, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!isValidBST(root.left) || root.val &lt;= pre) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        pre = root.val;<br>        <span class="hljs-keyword">return</span> isValidBST(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试经典 150 题-队列</title>
    <link href="/2025/01/12/posts/hot150-8/"/>
    <url>/2025/01/12/posts/hot150-8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-队列"><a href="#LeetCode-面试经典-150-题-队列" class="headerlink" title="LeetCode 面试经典 150 题-队列"></a>LeetCode 面试经典 150 题-队列</h1><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/?envType=study-plan-v2&envId=top-interview-150">环形链表</a></h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>定义快慢指针，若两指针最后相遇则有环，否则快指针会指向空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 快慢指针</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表II</a></h2><h3 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>找到环形入口点。假设入环点距链表头为a，相遇点距入环点为b，相遇点到最后是c，则有快指针走了<code>a + n(b+c) + b</code>，慢指针走了<code>a + b</code>，快指针走的是慢指针的两倍，即<code>a + n(n+c) + b = 2(a + b)</code>，即<code>a = c + (n-1)(b+c)</code>。即从链表头到入环点的距离等于从相遇点出发走了n-1次环的距离，即如果定义一个指针从链表头出发，一个指针从相遇点出发，每次都向后走一步，他们最终会相遇，相遇的地点就是入环点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// 边界处理</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 快慢指针</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>            <span class="hljs-comment">// 走到相遇点</span><br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> head;<br>                <span class="hljs-keyword">while</span> (ptr != slow) &#123;<br>                    ptr = ptr.next;<br>                    slow = slow.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> ptr;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，在最初判断快慢指针是否相遇时，slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度。</li><li>空间复杂度：O(1)</li></ul><h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-interview-150">两数相加</a></h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-keyword">return</span> addTwo(l1, l2, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">addTwo</span><span class="hljs-params">(ListNode l1, ListNode l2, <span class="hljs-type">int</span> carry)</span> &#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span> &amp;&amp; l2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> carry != <span class="hljs-number">0</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry) : <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 保证l1是更长的那个</span><br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>) &#123;<br>            l1 = l2;<br>            l2 = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 计算</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> carry + l1.val + (l2 != <span class="hljs-literal">null</span> ? l2.val : <span class="hljs-number">0</span>);<br>        l1.val = sum % <span class="hljs-number">10</span>;<br>        carry = sum / <span class="hljs-number">10</span>;<br>        l1.next = addTwo(l1.next, (l2 != <span class="hljs-literal">null</span> ? l2.next : <span class="hljs-literal">null</span>), carry);<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>初始化答案为一个「空链表」，每次循环，向该链表末尾添加一个节点（保存一个数位）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-comment">// 定义哑节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-comment">// 计算</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span> || carry != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) &#123;<br>                carry += l1.val;<br>                l1 = l1.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) &#123;<br>                carry += l2.val;<br>                l2 = l2.next;<br>            &#125;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry % <span class="hljs-number">10</span>);<br>            cur.next = node;<br>            cur = cur.next;<br>            carry /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists?envType=study-plan-v2&envId=top-interview-150">合并两个有序链表</a></h2><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;<br>                cur.next = list1;<br>                list1 = list1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = list2;<br>                list2 = list2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-comment">// 链接剩余部分</span><br>        cur.next = list1 != <span class="hljs-literal">null</span> ? list1 : list2;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m + n)</li><li>空间复杂度：O(1)</li></ul><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>递归边界：如果其中一个链表为空，直接返回另一个链表作为合并后的结果。</p><p>如果两个链表都不为空，则比较两个链表当前节点的值，并选择较小的节点作为新链表的当前节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list1;<br>        <span class="hljs-comment">// 比较</span><br>        <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;<br>            list1.next = mergeTwoLists(list1.next, list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<br>        list2.next = mergeTwoLists(list1, list2.next);<br>        <span class="hljs-keyword">return</span> list2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m + n)</li><li>空间复杂度：O(m + n)</li></ul><h2 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-interview-150">随机链表的复制</a></h2><h3 id="回溯-哈希表"><a href="#回溯-哈希表" class="headerlink" title="回溯+哈希表"></a>回溯+哈希表</h3><p>定义一个哈希表，用于存储节点的副本，如果这个节点已经存在，就直接返回，如果不存在，就复制一份，然后递归复制它的next和random。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node next;</span><br><span class="hljs-comment">    Node random;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment">        this.next = null;</span><br><span class="hljs-comment">        this.random = null;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Node, Node&gt; hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 如果不存在，就创建</span><br>        <span class="hljs-keyword">if</span> (!hash.containsKey(head)) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(head.val);<br>            hash.put(head, newNode);<br>            <span class="hljs-comment">// 递归创建指针副本</span><br>            newNode.next = copyRandomList(head.next);<br>            newNode.random = copyRandomList(head.random);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> hash.get(head);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h3><ol><li>将所有节点都复制一份，链接到原节点后面。</li><li>复制节点的random就是原节点的random的next。</li><li>分离链表。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node next;</span><br><span class="hljs-comment">    Node random;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment">        this.next = null;</span><br><span class="hljs-comment">        this.random = null;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">// 复制链表节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head; cur != <span class="hljs-literal">null</span>; cur = cur.next.next) &#123;<br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(cur.val, cur.next, <span class="hljs-literal">null</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 链接random</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head; cur != <span class="hljs-literal">null</span>; cur = cur.next.next) &#123;<br>            <span class="hljs-comment">// 注意cur-&gt;random需要不为空才能这样操作</span><br>            <span class="hljs-keyword">if</span> (cur.random != <span class="hljs-literal">null</span>) &#123;<br>                cur.next.random = cur.random.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 分离链表</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head; cur != <span class="hljs-literal">null</span>; cur = cur.next) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">copy</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = cur.next.next;<br>            copy.next = copy.next != <span class="hljs-literal">null</span> ? copy.next.next : <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)，返回值不计入。</li></ul><h2 id="反转链表II"><a href="#反转链表II" class="headerlink" title="反转链表II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/description/?envType=study-plan-v2&envId=top-interview-150">反转链表II</a></h2><h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>定义指针：</p><ol><li>cur：当前待反转节点；</li><li>next：待反转节点的下一个节点；</li><li>pre：待反转区域的前一个节点；</li></ol><p><img src="/2025/01/12/posts/hot150-8/image.png" alt="Alt text"></p><ol><li>将cur.next指向next.next；</li><li>将next.next指向pre.next；</li><li>将pre.next指向next。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">// 定义哑节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-comment">// 找到反转起点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        ListNode pre= dummy;<br>        <span class="hljs-keyword">while</span> (i &lt; left) &#123;<br>            pre = pre.next;<br>            i++;<br>        &#125;<br>        <span class="hljs-comment">// 开始反转</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pre.next;<br>        <span class="hljs-keyword">while</span> (i &lt; right) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = next.next;<br>            next.next = pre.next;<br>            pre.next = next;<br>            i++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="灵神做法"><a href="#灵神做法" class="headerlink" title="灵神做法"></a>灵神做法</h3><p><img src="/2025/01/12/posts/hot150-8/image-1.png" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">// 定义哑节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-comment">// 找到反转起点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        ListNode p0= dummy;<br>        <span class="hljs-keyword">while</span> (i &lt; left) &#123;<br>            p0 = p0.next;<br>            i++;<br>        &#125;<br>        <span class="hljs-comment">// 开始反转</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> p0.next;<br>        <span class="hljs-keyword">while</span> (i &lt; right) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>            i++;<br>        &#125;<br>        <span class="hljs-comment">// 链接</span><br>        p0.next.next = cur;<br>        p0.next = pre;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="k个一组翻转链表"><a href="#k个一组翻转链表" class="headerlink" title="k个一组翻转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/?envType=study-plan-v2&envId=top-interview-150">k个一组翻转链表</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li>先得到链表的长度n，即需要翻转n&#x2F;k组。</li><li>p0指向待反转组的前一个节点。<br><img src="/2025/01/12/posts/hot150-8/image-2.png" alt="Alt text"></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 统计节点个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head; cur != <span class="hljs-literal">null</span>; cur = cur.next) &#123;<br>            n++;<br>        &#125;<br><br>        <span class="hljs-comment">// 定义哑节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p0</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br><br>        <span class="hljs-comment">// k个一组处理</span><br>        <span class="hljs-keyword">for</span> (; n &gt;= k; n -= k) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">nxt</span> <span class="hljs-operator">=</span> cur.next;<br>                cur.next = pre;<br>                pre = cur;<br>                cur = nxt;<br>            &#125;<br>            <span class="hljs-comment">// p0指向下一个待反转区域的前一个节点</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">nxt</span> <span class="hljs-operator">=</span> p0.next;<br>            p0.next.next = cur;<br>            p0.next = pre;<br>            p0 = nxt;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="删除链表的倒数第N个结点"><a href="#删除链表的倒数第N个结点" class="headerlink" title="删除链表的倒数第N个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/?envType=study-plan-v2&envId=top-interview-150">删除链表的倒数第N个结点</a></h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>快指针先走n步，然后慢指针从哑节点开始和快指针一起走到末尾，此时慢指针指向的就是第len-n个结点。但是要删除倒数第n个节点，需要让slow指向待删除结点的前一个结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 定义哑节点，便于处理删除头结点的情况</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br><br>        <span class="hljs-comment">// 快指针先走n步</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-comment">// 快慢指针同时走</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-comment">// 此时slow指向待删除结点的前一个结点</span><br>        slow.next = slow.next.next;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="删除链表中的重复元素II"><a href="#删除链表中的重复元素II" class="headerlink" title="删除链表中的重复元素II"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/?envType=study-plan-v2&envId=top-interview-150">删除链表中的重复元素II</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ol><li>定义哑节点；</li><li>遍历，初始化cur &#x3D; dummy：<ul><li>cur.next.val &#x3D;&#x3D; cur.next.next.val：开启循环，删除所有重复的节点；</li><li>否则指向下一个即可。</li></ul></li><li>返回dummy.next。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br><br>        <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果相等就删除所有重复的</span><br>            <span class="hljs-keyword">if</span> (cur.next.val == cur.next.next.val)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> cur.next.val;<br>                <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.val == val) &#123;<br>                    cur.next = cur.next.next;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a><a href="https://leetcode.cn/problems/rotate-list/description/?envType=study-plan-v2&envId=top-interview-150">旋转链表</a></h2><h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h3><p>可以利用求倒数第n个结点的思想，找到倒数第k个结点，断开链表，将后端链表链接到开头。</p><ol><li>求出链表长度n，然后找倒数第k%n个结点。</li><li>断开链接；</li><li>后段链表的最后一个节点指向链表头。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">rotateRight</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 边界处理</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 求链表长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head; cur != <span class="hljs-literal">null</span>; cur = cur.next) &#123;<br>            n++;<br>        &#125;<br>        <span class="hljs-comment">// 找倒数第k%n个结点</span><br>        k = k % n;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-comment">// 断开链接</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">back</span> <span class="hljs-operator">=</span> slow.next;<br>        slow.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 链到表头</span><br>        fast.next = head;<br><br>        <span class="hljs-keyword">return</span> back;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a><a href="https://leetcode.cn/problems/partition-list?envType=study-plan-v2&envId=top-interview-150">分隔链表</a></h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><ol><li>使用两个链表small和large，并定义哑节点指向它们；</li><li>遍历链表，小于x的链接到small，大于等于x的链接到large；</li><li>small链接到largeHead.next。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// 定义两个链表</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">smallHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">largeHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">small</span> <span class="hljs-operator">=</span> smallHead;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">large</span> <span class="hljs-operator">=</span> largeHead;<br><br>        <span class="hljs-comment">// 遍历链表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head; cur != <span class="hljs-literal">null</span>; cur = cur.next) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val &lt; x) &#123;<br>                small.next = cur;<br>                small = small.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                large.next = cur;<br>                large = large.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 链接起来</span><br>        large.next = <span class="hljs-literal">null</span>;<br>        small.next = largeHead.next;<br>        <span class="hljs-keyword">return</span> smallHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意最后要让large.next置空，否则会让链表出现环路。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a><a href="https://leetcode.cn/problems/lru-cache/?envType=study-plan-v2&envId=top-interview-150">LRU缓存</a></h2><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-comment">// 双向链表结构</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">DLinkedNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> value;<br>        DLinkedNode prev;<br>        DLinkedNode next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DLinkedNode</span><span class="hljs-params">()</span> &#123;&#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DLinkedNode</span><span class="hljs-params">(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _value)</span> &#123;<br>            key = _key;<br>            value = _value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//数据结构</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> DLinkedNode dummy;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-comment">// 初始化哑节点</span><br>        dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLinkedNode</span>();<br>        dummy.prev = dummy;<br>        dummy.next = dummy;<br>        <span class="hljs-comment">// 初始化缓存容量</span><br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNode(key);<br>        <span class="hljs-keyword">return</span> node == <span class="hljs-literal">null</span> ? -<span class="hljs-number">1</span> : node.value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNode(key);<br>        <span class="hljs-comment">// 如果已经存在，就更新value</span><br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            node.value = value;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则new一个新节点加入哈希表</span><br>            node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLinkedNode</span>(key, value);<br>            pushFront(node);<br>            cache.put(key, node);<br>            <span class="hljs-comment">// 如果超出容量，需要删除结点</span><br>            <span class="hljs-keyword">if</span> (cache.size() &gt; capacity) &#123;<br>                cache.remove(dummy.prev.key);<br>                remove(dummy.prev);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 辅助函数</span><br>    <span class="hljs-keyword">private</span> DLinkedNode <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cache.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 取出并放在最前面</span><br>            <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> cache.get(key);<br>            remove(node);<br>            pushFront(node);<br>            <span class="hljs-keyword">return</span> cache.get(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除结点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(DLinkedNode x)</span> &#123;<br>        x.prev.next = x.next;<br>        x.next.prev = x.prev;<br>    &#125;<br><br>    <span class="hljs-comment">// 放在头部</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushFront</span><span class="hljs-params">(DLinkedNode x)</span> &#123;<br>        x.prev = dummy;<br>        x.next = dummy.next;<br>        x.prev.next = x;<br>        x.next.prev = x;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(1)</li><li>空间复杂度：O(min(p,capacity))，其中 p 为 put 的调用次数。</li></ul><h2 id="LFU缓存"><a href="#LFU缓存" class="headerlink" title="LFU缓存"></a><a href="https://leetcode.cn/problems/lfu-cache/solutions/2457716/tu-jie-yi-zhang-tu-miao-dong-lfupythonja-f56h/">LFU缓存</a></h2><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span> &#123;<br>    <span class="hljs-comment">// 双向链表结构</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">DLinkedNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> value;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">freq</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>        DLinkedNode prev;<br>        DLinkedNode next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DLinkedNode</span><span class="hljs-params">()</span> &#123;&#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DLinkedNode</span><span class="hljs-params">(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _value)</span> &#123;<br>            key = _key;<br>            value = _value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//数据结构</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, DLinkedNode&gt; keyToNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, DLinkedNode&gt; freqToDummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> minFreq;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LFUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNode(key);<br>        <span class="hljs-keyword">return</span> node == <span class="hljs-literal">null</span> ? -<span class="hljs-number">1</span> : node.value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">// 有就更新</span><br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNode(key);<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            node.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 否则判断容量</span><br>        <span class="hljs-keyword">if</span> (keyToNode.size() == capacity) &#123;<br>            <span class="hljs-comment">// 移出频率最小的那个</span><br>            <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> freqToDummy.get(minFreq);<br>            <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">back</span> <span class="hljs-operator">=</span> dummy.prev;<br>            keyToNode.remove(back.key);<br>            remove(back);<br>            <span class="hljs-comment">// 移除空链表</span><br>            <span class="hljs-keyword">if</span> (dummy.prev == dummy) &#123;<br>                freqToDummy.remove(minFreq);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 加入</span><br>        node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLinkedNode</span>(key, value);<br>        keyToNode.put(key, node);<br>        pushFront(<span class="hljs-number">1</span>, node);<br>        minFreq = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 辅助函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(DLinkedNode x)</span> &#123;<br>        x.prev.next = x.next;<br>        x.next.prev = x.prev;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建新的双向链表</span><br>    <span class="hljs-keyword">private</span> DLinkedNode <span class="hljs-title function_">newList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLinkedNode</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        dummy.prev = dummy;<br>        dummy.next = dummy;<br>        <span class="hljs-keyword">return</span> dummy;<br>    &#125;<br><br>    <span class="hljs-comment">// 放在最前面</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushFront</span><span class="hljs-params">(<span class="hljs-type">int</span> freq, DLinkedNode x)</span> &#123;<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> freqToDummy.computeIfAbsent(freq, k -&gt; newList());<br>        x.prev = dummy;<br>        x.next = dummy.next;<br>        x.prev.next = x;<br>        x.next.prev = x;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> DLinkedNode <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-comment">// 不存在</span><br>        <span class="hljs-keyword">if</span> (!keyToNode.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 取出</span><br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> keyToNode.get(key);<br>        remove(node);<br>        <span class="hljs-type">DLinkedNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> freqToDummy.get(node.freq);<br>        <span class="hljs-comment">// 为空</span><br>        <span class="hljs-keyword">if</span> (dummy.prev == dummy) &#123;<br>            freqToDummy.remove(node.freq);<br>            <span class="hljs-comment">// 更新最小频率</span><br>            <span class="hljs-keyword">if</span> (minFreq == node.freq) &#123;<br>                minFreq++;<br>            &#125;<br>        &#125;<br>        pushFront(++node.freq, node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LFUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LFUCache obj = new LFUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(1)</li><li>空间复杂度：O(min(p,capacity))，其中 p 为 put 的调用次数。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单链表的题一般与双指针有关，LRU、LFU缓存的设计利用了双向循环链表，需要多加复习。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试经典 150 题-栈</title>
    <link href="/2025/01/10/posts/hot150-7/"/>
    <url>/2025/01/10/posts/hot150-7/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-栈"><a href="#LeetCode-面试经典-150-题-栈" class="headerlink" title="LeetCode 面试经典 150 题-栈"></a>LeetCode 面试经典 150 题-栈</h1><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/description/?envType=study-plan-v2&envId=top-interview-150">有效的括号</a></h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ol><li>如果是左括号则入栈，如果是右括号则查看栈顶是否匹配。</li><li>最后判断栈是否为空。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 剪枝</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 初始化存放左右括号的哈希表</span><br>        Map&lt;Character, Character&gt; hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>);<br>            put(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>);<br>            put(<span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>);<br>        &#125;&#125;;<br>        <span class="hljs-comment">// 栈</span><br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-comment">// 左括号入栈</span><br>            <span class="hljs-keyword">if</span> (!hash.containsKey(c)) &#123;<br>                stack.push(c);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.isEmpty() || stack.pop() != hash.get(c)) &#123;<br>                <span class="hljs-comment">// 右括号查看是否匹配</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a><a href="https://leetcode.cn/problems/simplify-path/?envType=study-plan-v2&envId=top-interview-150">简化路径</a></h2><h3 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h3><p>把 path 用 &#x2F; 分割，得到一个字符串列表。</p><p>遍历字符串列表的同时，用栈维护遍历过的字符串：</p><ul><li>如果当前字符串是空串或者 .，什么也不做（跳过）。</li><li>如果当前字符串不是 ..，那么把字符串入栈。</li><li>否则弹出栈顶字符串（前提是栈不为空），模拟返回上一级目录。</li><li>最后把栈中字符串用 &#x2F; 拼接起来（最前面也要有个 &#x2F;）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">simplifyPath</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-comment">// 定义栈</span><br>        List&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 分割字符串并遍历</span><br>        <span class="hljs-keyword">for</span> (String s : path.split(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 跳过</span><br>            <span class="hljs-keyword">if</span> (s.isEmpty() || s.equals(<span class="hljs-string">&quot;.&quot;</span>)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!s.equals(<span class="hljs-string">&quot;..&quot;</span>)) &#123;<br>                <span class="hljs-comment">// 加入栈</span><br>                stack.add(s);                <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!stack.isEmpty())&#123;<br>                <span class="hljs-comment">// 回退上一级目录</span><br>                stack.remove(stack.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/&quot;</span> + String.join(<span class="hljs-string">&quot;/&quot;</span>, stack);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a><a href="https://leetcode.cn/problems/min-stack/?envType=study-plan-v2&envId=top-interview-150">最小栈</a></h2><h3 id="栈-2"><a href="#栈-2" class="headerlink" title="栈"></a>栈</h3><p>可以使用辅助栈，在入栈的时候将当前栈的最小元素也加入最小栈，这里只分析不使用辅助栈的方法。</p><p>栈中存储的是当前元素+当前元素的最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Deque&lt;<span class="hljs-type">int</span>[]&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 初始时放入一个哨兵节点</span><br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">0</span>, Integer.MAX_VALUE&#125;);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;val, Math.min(getMin(), val)&#125;);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        stack.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek()[<span class="hljs-number">0</span>];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek()[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：所有操作均为 O(1)。</li><li>空间复杂度：O(q)。其中 q 是 push 调用的次数。最坏情况下，只有 push 操作，需要 O(q) 的空间保存元素。</li></ul><h2 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/?envType=study-plan-v2&envId=top-interview-150">逆波兰表达式求值</a></h2><h3 id="栈-3"><a href="#栈-3" class="headerlink" title="栈"></a>栈</h3><p>遇到数字放入栈，遇到符号弹出两个操作数进行运算，再将结果放入栈中，最后返回栈中的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-comment">// 遍历</span><br>        <span class="hljs-keyword">for</span> (String s : tokens) &#123;<br>            <span class="hljs-comment">// 是数字入栈</span><br>            <span class="hljs-keyword">if</span> (s.matches(<span class="hljs-string">&quot;^-?\\d+$&quot;</span>)) &#123;<br>                stack.push(Integer.parseInt(s));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-comment">// 是符号运算</span><br>                <span class="hljs-keyword">switch</span> (s) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span> :<br>                        stack.push(a + b);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span> :<br>                        stack.push(a - b);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span> :<br>                        stack.push(a * b);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        stack.push(a / b);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="基本计算器"><a href="#基本计算器" class="headerlink" title="基本计算器"></a><a href="https://leetcode.cn/problems/basic-calculator/?envType=study-plan-v2&envId=top-interview-150">基本计算器</a></h2><h3 id="括号展开-栈"><a href="#括号展开-栈" class="headerlink" title="括号展开+栈"></a>括号展开+栈</h3><p>思路是通过栈来将括号展开，确定将括号展开后的符号。</p><ol><li><p>初始化：栈 ops 初始化为 [1]，表示默认符号为 +。</p></li><li><p>遍历字符串：</p><p> 如果是空格，跳过。<br> 如果是 + 或 -，更新符号 sign。<br> 如果是 (，将当前符号入栈（进入一个新的运算子区域）。<br> 如果是 )，弹出栈顶元素，恢复到上一级的符号。<br> 如果是数字，解析并计算出数字，累加到结果 ret 中。</p></li><li><p>返回结果：当遍历完整个字符串后，ret 即为最终计算的结果</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 定义符号栈</span><br>        Deque&lt;Integer&gt; ops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        ops.push(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 遍历字符串</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-comment">// 如果是空格</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                <span class="hljs-comment">// +，更新符号</span><br>                sign = ops.peek();<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                <span class="hljs-comment">// -，更新符号</span><br>                sign = -ops.peek();<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 进入到新的计算区域</span><br>                ops.push(sign);<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 回退到上一层的状态</span><br>                ops.pop();<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果是数字</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; Character.isDigit(s.charAt(i))) &#123;<br>                    num = num * <span class="hljs-number">10</span> + (s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                    i++;<br>                &#125;<br>                <span class="hljs-comment">// 更新结果</span><br>                ans += sign * num;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>如果还有*、&#x2F;、%等等符号，可以用双栈。</p><ol><li>初始化哈希表存储运算符及其优先级。</li><li>遍历字符串：<ul><li>左括号：加入符号栈。</li><li>右括号：不断计算当前符号栈和数字栈中的值，直到遇到左括号，把左括号弹出。</li><li>数字：取完整的数字加入数字栈。</li><li>符号：如果前一个字符是 ( 或运算符（+ 或 -），则需要先在栈中加入一个 0（这代表此处有一个隐式的 0 操作数）。接下来，判断栈中是否有高优先级的操作符，如果有，则执行计算并弹出栈中的操作符。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 运算符优先级</span><br>    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;() &#123;&#123;<br>        put(<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>);<br>        put(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>);<br>        put(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>);<br>        put(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>);<br>        put(<span class="hljs-string">&#x27;%&#x27;</span>, <span class="hljs-number">2</span>);<br>        put(<span class="hljs-string">&#x27;^&#x27;</span>, <span class="hljs-number">3</span>);<br>    &#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 去掉空格</span><br>        s = s.replaceAll(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-type">char</span>[] str = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> str.length;<br>        <span class="hljs-comment">// 定义双栈</span><br>        Deque&lt;Character&gt; ops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        Deque&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-comment">// 初始时加入0</span><br>        nums.push(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 遍历字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> str[i];<br>            <span class="hljs-comment">// 左括号</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                ops.push(c);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 右括号，计算</span><br>                <span class="hljs-keyword">while</span>(!ops.isEmpty() &amp;&amp; ops.peek() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    cal(ops, nums);<br>                &#125;<br>                <span class="hljs-comment">// 弹出左括号</span><br>                ops.pop();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;<br>                <span class="hljs-comment">// 如果是数字，则获取完整的数字</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; Character.isDigit(str[i]))&#123;<br>                    num = num * <span class="hljs-number">10</span> + (str[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                    i++;<br>                &#125;<br>                nums.push(num);<br>                i--;    <span class="hljs-comment">// 外层for循环还要+1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果是符号，且前一个字符是左括号或+-</span><br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (str[i-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span> || str[i-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;+&#x27;</span> || str[i-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)) &#123;<br>                    nums.push(<span class="hljs-number">0</span>);<br>                &#125;<br>                <span class="hljs-comment">// 判断优先级并计算</span><br>                <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peek() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    <span class="hljs-type">char</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ops.peek();<br>                    <span class="hljs-keyword">if</span> (map.get(prev) &gt;= map.get(c)) &#123;<br>                        cal(ops, nums);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 将当前符号入栈</span><br>                ops.push(c);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算栈中剩余内容</span><br>        <span class="hljs-keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peek() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>            cal(ops, nums);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> nums.peek();<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cal</span><span class="hljs-params">(Deque&lt;Character&gt; ops, Deque&lt;Integer&gt; nums)</span> &#123;<br>        <span class="hljs-comment">// 边界条件</span><br>        <span class="hljs-keyword">if</span> (nums.size() &lt; <span class="hljs-number">2</span> || ops.isEmpty()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 计算</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> nums.pop();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> nums.pop();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> ops.pop();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">switch</span> (op) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                ans = a + b;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                ans = a - b;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                ans = a * b;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                ans = a / b;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span> :<br>                ans = (<span class="hljs-type">int</span>)Math.pow(a, b);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;%&#x27;</span> :<br>                ans = a % b;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span> :<br>        &#125;   <br><br>        <span class="hljs-comment">// 入栈</span><br>        nums.push(ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><code>Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;()</code>和<code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;()</code>的区别：</p><ol><li><p>底层实现</p><p> LinkedList<Integer>：底层使用双向链表来实现 Deque。每个元素在内存中是一个节点，包含指向前后元素的指针。<br> ArrayDeque<Integer>：底层使用动态数组（类似于 ArrayList）来实现 Deque。数组的大小会根据元素的数量动态调整。</Integer></Integer></p></li><li><p>性能差异</p><p> LinkedList：<br> 插入和删除操作（在队头和队尾）是常数时间操作，O(1)。<br> 但是访问元素（例如通过索引）需要遍历链表，时间复杂度是 O(n)。<br> ArrayDeque：<br> 插入和删除操作（在队头和队尾）通常是 O(1)，但如果数组需要扩容（当数组满时），扩容操作是 O(n)。<br> 访问元素的时间复杂度是 O(1)，因为它使用数组，所以可以直接通过索引访问。</p></li><li><p>内存占用</p><p> LinkedList：由于每个元素都需要额外的内存来存储指向前后节点的指针，因此每个元素的内存占用较大。<br> ArrayDeque：数组的内存占用通常较小，但当需要扩容时，可能会分配更大的数组，因此可能会浪费一些内存。</p></li><li><p>线程安全性</p><p> LinkedList 和 ArrayDeque 都不是线程安全的。如果在多线程环境中需要操作它们，应该使用同步机制（如 synchronized）或使用 ConcurrentLinkedDeque 等线程安全的实现。</p></li><li><p>适用场景</p><p> LinkedList：适合频繁插入和删除元素的场景，尤其是在队列的两端进行操作时，性能较好。<br> ArrayDeque：适合需要高效随机访问和较少插入删除操作的场景，尤其是在栈或队列的应用中，通常会比 LinkedList 更高效。</p></li></ol><p>总结：</p><pre><code class="hljs">如果你需要频繁地进行插入和删除操作，LinkedList 是一个不错的选择。如果你更关注性能，尤其是栈或队列操作的效率，ArrayDeque 通常会提供更好的性能。</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试经典 150 题-区间</title>
    <link href="/2025/01/09/posts/hot150-6/"/>
    <url>/2025/01/09/posts/hot150-6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-区间"><a href="#LeetCode-面试经典-150-题-区间" class="headerlink" title="LeetCode 面试经典 150 题-区间"></a>LeetCode 面试经典 150 题-区间</h1><h2 id="汇总区间"><a href="#汇总区间" class="headerlink" title="汇总区间"></a><a href="https://leetcode.cn/problems/summary-ranges/description/?envType=study-plan-v2&envId=top-interview-150">汇总区间</a></h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">summaryRanges</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        <span class="hljs-comment">// 处理边界 </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 添加区间</span><br>            <span class="hljs-keyword">if</span> (nums[i] != nums[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 区间内包含多个数字</span><br>                <span class="hljs-keyword">if</span> (pre != nums[i-<span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> pre + <span class="hljs-string">&quot;-&gt;&quot;</span> + nums[i-<span class="hljs-number">1</span>];<br>                    res.add(str);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res.add(String.valueOf(pre));<br>                &#125;<br>                <span class="hljs-comment">// 更新区间起始</span><br>                pre = nums[i];<br>            &#125; <br>        &#125;<br><br>        <span class="hljs-comment">// 处理最后一个区间</span><br>        <span class="hljs-keyword">if</span> (pre != nums[n - <span class="hljs-number">1</span>]) &#123;<br>            res.add(pre + <span class="hljs-string">&quot;-&gt;&quot;</span> + nums[n - <span class="hljs-number">1</span>]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res.add(String.valueOf(pre));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals?envType=study-plan-v2&envId=top-interview-150">合并区间</a></h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><ol><li>对区间按照起始点进行排序。</li><li>遍历区间，如果当前区间的起始位置小于上一个区间的结束位置，则说明可以合并区间，将区间的结束位置置为两区间结束位置的较大值。否则直接加入结果集。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        <span class="hljs-comment">// 按照起始位置进行排序</span><br>        Arrays.sort(intervals, (row1, row2) -&gt; Integer.compare(row1[<span class="hljs-number">0</span>], row2[<span class="hljs-number">0</span>]));<br>        <span class="hljs-comment">// 遍历区间</span><br>        List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        res.add(intervals[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>            <span class="hljs-type">int</span> last[] = res.get(res.size()-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt;= last[<span class="hljs-number">1</span>]) &#123;<br>                last[<span class="hljs-number">1</span>] = Math.max(last[<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.add(intervals[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 转为数组</span><br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)</li></ul><h2 id="插入区间"><a href="#插入区间" class="headerlink" title="插入区间"></a><a href="https://leetcode.cn/problems/insert-interval/?envType=study-plan-v2&envId=top-interview-150">插入区间</a></h2><h3 id="模拟-1"><a href="#模拟-1" class="headerlink" title="模拟"></a>模拟</h3><ol><li>维护待插入区间的范围，维护是否在遍历过程中插入的标记；</li><li>遍历区间：<ul><li>在插入区间右侧且无交集：如果还未插入，则插入，然后将当前区间加入结果；</li><li>在插入区间左侧且无交集：当前区间加入结果集；</li><li>有重叠：更新待插入区间的范围；</li></ul></li><li>如果在遍历区间的时候没有插入新区间，说明整个区间都是重叠的，插入。</li><li>返回结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] insert(<span class="hljs-type">int</span>[][] intervals, <span class="hljs-type">int</span>[] newInterval) &#123;<br>        <span class="hljs-comment">// 维护待插入区间的范围</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> newInterval[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> newInterval[<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 标记是否在遍历过程中插入</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">placed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 遍历区间</span><br>        List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] interval : intervals) &#123;<br>            <span class="hljs-comment">// 在插入区间右侧且无交集</span><br>            <span class="hljs-keyword">if</span> (interval[<span class="hljs-number">0</span>] &gt; right) &#123;<br>                <span class="hljs-comment">// 插入</span><br>                <span class="hljs-keyword">if</span> (!placed) &#123;<br>                    res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, right&#125;);<br>                    placed = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-comment">// 插入当前区间</span><br>                res.add(interval);<br><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interval[<span class="hljs-number">1</span>] &lt; left) &#123;<br>                <span class="hljs-comment">// 在插入区间左侧且无交集</span><br>                res.add(interval);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 与插入区间有交集，计算其并集</span><br>                left = Math.min(left, interval[<span class="hljs-number">0</span>]);<br>                right = Math.max(right, interval[<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果再循环中未被插入，即整个区间都是重叠的</span><br>        <span class="hljs-keyword">if</span> (!placed) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, right&#125;);<br>        &#125;<br><br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/?envType=study-plan-v2&envId=top-interview-150">用最少数量的箭引爆气球</a></h2><h3 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h3><p>将坐标按结束位置升序排序。对于第一个区间，假设弓箭射在其结束位置，往后依次遍历每个区间，如果弓箭的坐标小于区间的起始坐标，说明需要新的弓箭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        <span class="hljs-comment">// 按结束位置进行排序</span><br>        Arrays.sort(points, (p1, p2) -&gt; Integer.compare(p1[<span class="hljs-number">1</span>], p2[<span class="hljs-number">1</span>]));<br>        <br>        <span class="hljs-comment">// 遍历坐标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">arrow</span> <span class="hljs-operator">=</span> points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];   <span class="hljs-comment">// 箭射在第一个球的结束位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; points.length; i++) &#123;<br>            <span class="hljs-comment">// 需要一支新的箭</span><br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &gt; arrow) &#123;<br>                ans++;<br>                arrow = points[i][<span class="hljs-number">1</span>];   <span class="hljs-comment">// 更新弓箭位置</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相当于合并区间的时候取交集，最后返回交集区间数。</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>排序</p><p> 很多区间类问题都要求按区间的起始点或结束点排序，这是解题的第一步。排序后，可以更容易地判断区间之间的关系（是否有交集，是否可以合并等）。</p><ul><li>排序依据：通常按区间的起始位置排序，或按结束位置排序。</li><li>排序后，简化问题：排序后的区间更容易处理，很多问题可以转换成遍历排序后的区间，逐一进行合并或插入。</li></ul></li><li><p>区间的合并与插入</p><ul><li>合并区间：遍历所有区间，遇到有交集的区间时，将它们合并成一个新区间。- </li><li>插入区间：对于给定的新区间，遍历现有区间，判断是否存在交集，若有交集则更新新区间的范围，否则直接插入。</li></ul></li><li><p>贪心策略</p><p>贪心算法非常适合用于区间问题，特别是涉及到最小化操作的题目，如最少箭数射爆气球、区间调度问题等。通过选择当前最优的局部解来达到全局最优。典型的做法是按结束点或起始点对区间进行排序，之后选择最合适的区间进行处理。</p></li><li><p>区间的交集与并集</p><ul><li>交集：两个区间是否有交集可以通过比较它们的起始点和结束点来判断。</li><li>并集：若两个区间有交集，则它们的并集区间就是从最小的起点到最大的终点。</li></ul></li><li><p>边界条件处理</p><p> 许多区间问题的边界条件处理需要特别注意，如空区间的情况、只有一个区间的情况等。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>区间</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>区间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试经典 150 题-哈希表</title>
    <link href="/2025/01/06/posts/hot150-5/"/>
    <url>/2025/01/06/posts/hot150-5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-哈希表"><a href="#LeetCode-面试经典-150-题-哈希表" class="headerlink" title="LeetCode 面试经典 150 题-哈希表"></a>LeetCode 面试经典 150 题-哈希表</h1><h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a><a href="https://leetcode.cn/problems/ransom-note/description/?envType=study-plan-v2&envId=top-interview-150">赎金信</a></h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ol><li>对magzine中的字符做统计。</li><li>遍历ransomNote字符串，对出现的字符，哈希表-1，如果出现小于0的情况则返回false，否则最后返回true。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> &#123;<br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-comment">// 对于magazine</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; magazine.length(); i++) &#123;<br>            cnt[magazine.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-comment">// 对于ransomNote</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ransomNote.length(); i++) &#123;<br>            cnt[ransomNote.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-keyword">if</span> (cnt[ransomNote.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m + n)</li><li>空间复杂度：$O(|\Sigma|)$</li></ul><h2 id="同构字符串"><a href="#同构字符串" class="headerlink" title="同构字符串"></a><a href="https://leetcode.cn/problems/isomorphic-strings/?envType=study-plan-v2&envId=top-interview-150">同构字符串</a></h2><h3 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h3><p>考虑统计两字符串不同字符的个数，经测试会有测试点不通过：s &#x3D;”bbbaaaba”，t &#x3D;”aaabbbba”。t &#x3D;<br>“aaabbbba”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIsomorphic</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span>[] hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-comment">// 对于字符串s</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cntS</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (hash[s.charAt(i)] == <span class="hljs-number">0</span>) &#123;<br>                cntS++;<br>            &#125;<br>            hash[s.charAt(i)]++;<br>        &#125;<br>        <span class="hljs-comment">// 对于t</span><br>        Arrays.fill(hash, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cntT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; t.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (hash[t.charAt(i)] == <span class="hljs-number">0</span>) &#123;<br>                cntT++;<br>            &#125;<br>            hash[t.charAt(i)]++;<br>        &#125;<br>        <span class="hljs-comment">// 比较</span><br>        <span class="hljs-keyword">return</span> cntS == cntT;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>维护两张哈希表，第一张哈希表 s2t 以 s 中字符为键，映射至 t 的字符为值，第二张哈希表 t2s 以 t 中字符为键，映射至 s 的字符为值。</li><li>从左至右遍历两个字符串的字符，不断更新两张哈希表，如果出现冲突（即当前下标 index 对应的字符 s[index] 已经存在映射且不为 t[index] 或当前下标 index 对应的字符 t[index] 已经存在映射且不为 s[index]）时说明两个字符串无法构成同构，返回 false。</li><li>如果遍历结束没有出现冲突，则表明两个字符串是同构的，返回 true 即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIsomorphic</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        Map&lt;Character, Character&gt; s2t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Character, Character&gt; t2s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> t.charAt(i);<br>            <span class="hljs-keyword">if</span> ((s2t.containsKey(x) &amp;&amp; s2t.get(x) != y) || (t2s.containsKey(y) &amp;&amp; t2s.get(y) != x)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            s2t.put(x, y);<br>            t2s.put(y, x);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：$O(|\Sigma|)$</li></ul><h2 id="单词规律"><a href="#单词规律" class="headerlink" title="单词规律"></a><a href="https://leetcode.cn/problems/word-pattern/?envType=study-plan-v2&envId=top-interview-150">单词规律</a></h2><h3 id="哈希表-2"><a href="#哈希表-2" class="headerlink" title="哈希表"></a>哈希表</h3><p>与上一题类似，但对应关系变为character -&gt; string。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordPattern</span><span class="hljs-params">(String pattern, String s)</span> &#123;<br>        <span class="hljs-comment">// 使用正则表达式分割以避免多个空格问题</span><br>        String[] words = s.split(<span class="hljs-string">&quot;\\s+&quot;</span>);<br>        <br>        <span class="hljs-comment">// 长度不一致直接返回 false</span><br>        <span class="hljs-keyword">if</span> (pattern.length() != words.length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 定义两个映射：字符到字符串和字符串到字符的映射</span><br>        Map&lt;Character, String&gt; p2s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;String, Character&gt; s2p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 遍历模式字符串中的每个字符和对应的单词</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pattern.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> pattern.charAt(i);  <span class="hljs-comment">// 当前模式字符</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> words[i];  <span class="hljs-comment">// 当前对应的单词</span><br><br>            <span class="hljs-comment">// 检查映射是否冲突</span><br>            <span class="hljs-keyword">if</span> (p2s.containsKey(x) &amp;&amp; !p2s.get(x).equals(y) || s2p.containsKey(y) &amp;&amp; !s2p.get(y).equals(x)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 更新映射</span><br>            p2s.put(x, y);<br>            s2p.put(y, x);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意判断字符串是否相等要用.equals方法而不能直接用&#x3D;&#x3D;。</p><ul><li>时间复杂度：O(m + n)</li><li>空间复杂度：O(m + n)，最坏情况下，我们需要存储 pattern 中的每一个字符和 str 中的每一个字符串。</li></ul><h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/?envType=study-plan-v2&envId=top-interview-150">有效的字母异位词</a></h2><h3 id="哈希表-3"><a href="#哈希表-3" class="headerlink" title="哈希表"></a>哈希表</h3><p>判断两个字符串的哈希情况是否一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-keyword">if</span> (m != n) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-comment">// 统计s</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            hash[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-comment">// 统计t</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            hash[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-keyword">if</span> (hash[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//检查</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (hash[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：$O(|\Sigma|)$</li></ul><h2 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-interview-150">字母异位词分组</a></h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ol><li>把每个单词进行排序，将排序后的字符串作为键，字符串作为值加入到该键对应的字符串数组中。</li><li>遍历上面的哈希表，加入结果集。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-comment">// 定义哈希表</span><br>        Map&lt;String, List&lt;String&gt;&gt; hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-comment">// 排序</span><br>            <span class="hljs-type">char</span>[] charArray = str.toCharArray();<br>            Arrays.sort(charArray);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sortedStr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArray);<br>            <span class="hljs-comment">// 加入哈希表</span><br>            <span class="hljs-keyword">if</span> (!hash.containsKey(sortedStr)) &#123;<br>                hash.put(sortedStr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>            &#125;<br>            <span class="hljs-comment">// 将当前字符串加入到对应的 List 中</span><br>            hash.get(sortedStr).add(str);<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(hash.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nklogk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。</li><li>空间复杂度：O(nk)</li></ul><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><ol><li>对于每个字符串，首先使用哈希表统计每个字母出现的频率，然后将频率表转换为字符串作为键。</li><li>这样处理完之后就得到与上一种方法类似的哈希表。最后将哈希表中的结果移到结果数组中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-comment">// 定义哈希表</span><br>        Map&lt;String, List&lt;String&gt;&gt; hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-comment">// 统计</span><br>            <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>                cnt[str.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            &#125;<br>            <span class="hljs-comment">// 拼接成字符串</span><br>            <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>                sb.append(cnt[i]);<br>                sb.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 加入哈希表</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> sb.toString();<br>            <span class="hljs-keyword">if</span> (!hash.containsKey(key)) &#123;<br>                hash.put(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;());<br>            &#125;<br>            hash.get(key).add(str);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(hash.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n(k+∣Σ∣))</li><li>空间复杂度：O(n(k+∣Σ∣))</li></ul><h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a><a href="https://leetcode.cn/problems/4sum/solutions/436368/si-shu-zhi-he-by-leetcode-solution/">四数之和</a></h2><h3 id="排序-双指针"><a href="#排序-双指针" class="headerlink" title="排序+双指针"></a>排序+双指针</h3><p>之前做过两数、三数之和，四数之和与三数之和的思路类似，都是先排序，固定数，然后剩下两个数利用双指针找。</p><ul><li>每一种循环枚举到的下标必须大于上一重循环枚举到的下标；</li><li>同一重循环中，如果当前元素与上一个元素相同，则跳过当前元素。</li></ul><p>一些剪枝操作：</p><ul><li>在确定第一个数之后，如果 nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target，说明此时剩下的三个数无论取什么值，四数之和一定大于 target，因此退出第一重循环；</li><li>在确定第一个数之后，如果 nums[i]+nums[n−3]+nums[n−2]+nums[n−1]&lt;target，说明此时剩下的三个数无论取什么值，四数之和一定小于 target，因此第一重循环直接进入下一轮，枚举 nums[i+1]；</li><li>在确定前两个数之后，如果 nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target，说明此时剩下的两个数无论取什么值，四数之和一定大于 target，因此退出第二重循环；</li><li>在确定前两个数之后，如果 nums[i]+nums[j]+nums[n−2]+nums[n−1]&lt;target，说明此时剩下的两个数无论取什么值，四数之和一定小于 target，因此第二重循环直接进入下一轮，枚举 nums[j+1]。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-comment">// 排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">// 确定第一个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-comment">// 剪枝，跳过重复元素</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 剪枝，大于目标</span><br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[i] + nums[i+<span class="hljs-number">1</span>] + nums[i+<span class="hljs-number">2</span>] + nums[i+<span class="hljs-number">3</span>] &gt; target) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 剪枝，小于目标</span><br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[i] + nums[n-<span class="hljs-number">3</span>] + nums[n-<span class="hljs-number">2</span>] + nums[n-<span class="hljs-number">1</span>] &lt; target) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 确定第二个数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-comment">// 剪枝，跳过重复元素</span><br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j-<span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 剪枝，大于目标</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[i] + nums[j] + nums[j+<span class="hljs-number">1</span>] + nums[j+<span class="hljs-number">2</span>] &gt; target) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <br>                <span class="hljs-comment">// 剪枝，小于目标</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[i] + nums[j] + nums[n-<span class="hljs-number">2</span>] + nums[n-<span class="hljs-number">1</span>] &lt; target) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 双指针寻找第三、四个数</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) nums[i] + nums[j] + nums[left] + nums[right];<br>                    <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));<br>                        <span class="hljs-comment">// 跳过重复元素</span><br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left+<span class="hljs-number">1</span>]) &#123;<br>                            left++;<br>                        &#125;<br>                        left++;<br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right-<span class="hljs-number">1</span>]) &#123;<br>                            right--;<br>                        &#125;<br>                        right--;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>                        left++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        right--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^3)$</li><li>空间复杂度：O(logn)</li></ul><p>注意求和的地方需要转为long，否则会溢出。</p><h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a><a href="https://leetcode.cn/problems/happy-number/?envType=study-plan-v2&envId=top-interview-150">快乐数</a></h2><h3 id="哈希表-4"><a href="#哈希表-4" class="headerlink" title="哈希表"></a>哈希表</h3><p>不断对数字的每一位进行平方求和，如果这个数不是快乐数，那么它一定会产生循环。使用哈希表存储已经访问过的情况，如果再次遇到这个数字，就说明出现循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        set.add(n);<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>                num += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>                n /= <span class="hljs-number">10</span>;<br>            &#125;<br>            n = num;<br>            <span class="hljs-keyword">if</span> (set.contains(n)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            set.add(n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(logn)</li></ul><h3 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h3><p>可以看成是链表，起始数字是链表的头 “节点”，链中的所有其他数字都是节点。问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> n, fast = getNext(n);<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-number">1</span> &amp;&amp; slow != fast) &#123;<br>            slow = getNext(slow);<br>            fast = getNext(getNext(fast));<br>        &#125;<br>        <span class="hljs-keyword">return</span> fast == <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> n % <span class="hljs-number">10</span>;<br>            n /= <span class="hljs-number">10</span>;<br>            num += d * d;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="存在重复元素II"><a href="#存在重复元素II" class="headerlink" title="存在重复元素II"></a><a href="https://leetcode.cn/problems/contains-duplicate-ii/?envType=study-plan-v2&envId=top-interview-150">存在重复元素II</a></h2><h3 id="哈希表-5"><a href="#哈希表-5" class="headerlink" title="哈希表"></a>哈希表</h3><p>一边遍历数组，一边把索引存到哈希表中。如果当前元素已经存在于哈希表，则判断其索引值之差的绝对值是否小于等于k，如果小于直接返回true，否则更新索引为当前元素下标，因为需要索引差尽可能接近。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsNearbyDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Map&lt;Integer, Integer&gt; hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (hash.containsKey(nums[i]) &amp;&amp; Math.abs(i - hash.get(nums[i])) &lt;= k) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            hash.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>考虑数组 nums 中的每个长度不超过 k+1 的滑动窗口，同一个滑动窗口中的任意两个下标差的绝对值不超过 k。如果存在一个滑动窗口，其中有重复元素，则存在两个不同的下标 i 和 j 满足 nums[i]&#x3D;nums[j] 且 ∣i−j∣≤k。如果所有滑动窗口中都没有重复元素，则不存在符合要求的下标。因此，只要遍历每个滑动窗口，判断滑动窗口中是否有重复元素即可。</p><p>如果一个滑动窗口的结束下标是 i，则该滑动窗口的开始下标是 max(0,i−k)。可以使用哈希集合存储滑动窗口中的元素。从左到右遍历数组 nums，当遍历到下标 i 时，具体操作如下：</p><ul><li>如果 i&gt;k，则下标 i−k−1 处的元素被移出滑动窗口，因此将 nums[i−k−1] 从哈希集合中删除；</li><li>判断 nums[i] 是否在哈希集合中，如果在哈希集合中则在同一个滑动窗口中有重复元素，返回 true，如果不在哈希集合中则将其加入哈希集合。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsNearbyDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 维护滑动窗口</span><br>            <span class="hljs-keyword">if</span> (i &gt; k) &#123;<br>                set.remove(nums[i-k-<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-comment">// 已经存在就返回true</span><br>            <span class="hljs-keyword">if</span> (!set.add(nums[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(k)</li></ul><h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-interview-150">最长连续序列</a></h2><h3 id="哈希表-6"><a href="#哈希表-6" class="headerlink" title="哈希表"></a>哈希表</h3><ol><li>用集合进行去重</li><li>遍历集合：</li></ol><ul><li>确定序列起始，即判断当前数字-1是否存在于集合中，如果不存在，则当前数字就是序列起始；</li><li>更新连续序列长度；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// 将元素加入集合</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            set.add(nums[i]);<br>        &#125;<br>        <span class="hljs-comment">// 遍历集合</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : set) &#123;<br>            <span class="hljs-comment">// 确定当前序列起始</span><br>            <span class="hljs-keyword">if</span> (!set.contains(num - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">curNum</span> <span class="hljs-operator">=</span> num, curLen = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (set.contains(curNum + <span class="hljs-number">1</span>)) &#123;<br>                    curNum++;<br>                    curLen++;<br>                &#125;<br>                ans = Math.max(ans, curLen);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，外层循环需要 O(n) 的时间复杂度，只有当一个数是连续序列的第一个数的情况下才会进入内层循环，然后在内层循环中匹配连续序列中的数，因此数组中的每个数只会进入内层循环一次。</li><li>空间复杂度：O(n)</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>Java的集合（Collection）是Java提供的一种数据结构，用于存储和操作数据。集合框架提供了一种高效、灵活的方式来处理对象的数据，可以替代数组等传统的数据结构。Java集合框架包括了各种不同的接口和类，可以满足不同的数据存储和操作需求。</p><p>Java集合框架的核心接口包括：</p><h3 id="1-Collection接口"><a href="#1-Collection接口" class="headerlink" title="1. Collection接口"></a>1. <strong>Collection接口</strong></h3><p><code>Collection</code>是所有集合类的根接口。它定义了常见的集合操作，如添加、删除、迭代等。<code>Collection</code>接口的子接口包括<code>Set</code>、<code>List</code>、<code>Queue</code>等。</p><h3 id="2-List接口"><a href="#2-List接口" class="headerlink" title="2. List接口"></a>2. <strong>List接口</strong></h3><p><code>List</code>是一个有序的集合，允许元素重复。元素可以根据索引访问。<code>List</code>接口的常见实现类有：</p><ul><li><strong>ArrayList</strong>：基于动态数组实现，支持快速随机访问，但在插入或删除元素时性能较差。</li><li><strong>LinkedList</strong>：基于双向链表实现，插入和删除操作较快，但访问元素时速度较慢。</li><li><strong>Vector</strong>：类似于<code>ArrayList</code>，但它是同步的，因此线程安全，性能相对较差，通常不推荐使用。</li></ul><h3 id="3-Set接口"><a href="#3-Set接口" class="headerlink" title="3. Set接口"></a>3. <strong>Set接口</strong></h3><p><code>Set</code>是一个不允许重复元素的集合。<code>Set</code>接口的常见实现类有：</p><ul><li><strong>HashSet</strong>：基于哈希表实现，插入和查找效率较高，但元素的顺序是不确定的。</li><li><strong>LinkedHashSet</strong>：基于哈希表和链表实现，保证元素的插入顺序。</li><li><strong>TreeSet</strong>：基于红黑树实现，支持排序和快速查找。</li></ul><h3 id="4-Queue接口"><a href="#4-Queue接口" class="headerlink" title="4. Queue接口"></a>4. <strong>Queue接口</strong></h3><p><code>Queue</code>是一个按先进先出（FIFO）原则处理元素的集合。它适合用来实现任务调度、消息队列等。常见的<code>Queue</code>实现类有：</p><ul><li><strong>LinkedList</strong>：既是<code>List</code>的实现类，又实现了<code>Queue</code>接口，可以作为队列使用。</li><li><strong>PriorityQueue</strong>：基于优先级堆实现，队列中的元素按优先级顺序排列。</li></ul><p>Deque（双端队列，Double-Ended Queue）是一个允许在两端（头部和尾部）进行插入和删除操作的队列。与传统的队列（Queue）不同，Deque 允许在两端进行插入和删除，因此它既可以作为队列（FIFO）使用，也可以作为栈（LIFO）使用。</p><p>在 Java 中，Deque 是 java.util 包下的一个接口，继承自 Queue，并提供了双端队列的相关方法。它的常见实现类包括 ArrayDeque 和 LinkedList。</p><h3 id="5-Map接口"><a href="#5-Map接口" class="headerlink" title="5. Map接口"></a>5. <strong>Map接口</strong></h3><p><code>Map</code>是一个映射关系接口，用于存储键值对（key-value）。<code>Map</code>不继承自<code>Collection</code>接口，因此是一个独立的接口。<code>Map</code>接口的常见实现类有：</p><ul><li><strong>HashMap</strong>：基于哈希表实现，允许<code>null</code>作为键和值，元素无顺序保证。</li><li><strong>LinkedHashMap</strong>：与<code>HashMap</code>类似，但保持插入顺序。</li><li><strong>TreeMap</strong>：基于红黑树实现，键值对按键的自然顺序或自定义顺序排序。</li><li><strong>Hashtable</strong>：类似于<code>HashMap</code>，但它是同步的，因此线程安全，但性能较差，通常不推荐使用。</li></ul><h3 id="6-SortedSet和SortedMap接口"><a href="#6-SortedSet和SortedMap接口" class="headerlink" title="6. SortedSet和SortedMap接口"></a>6. <strong>SortedSet和SortedMap接口</strong></h3><p><code>SortedSet</code>和<code>SortedMap</code>接口分别是<code>Set</code>和<code>Map</code>的有序版本，提供对元素的排序支持。</p><ul><li><strong>SortedSet</strong>：如<code>TreeSet</code>，可以保证集合中的元素有序。</li><li><strong>SortedMap</strong>：如<code>TreeMap</code>，可以保证<code>Map</code>中的键有序。</li></ul><h3 id="7-Iterator接口"><a href="#7-Iterator接口" class="headerlink" title="7. Iterator接口"></a>7. <strong>Iterator接口</strong></h3><p><code>Iterator</code>接口用于遍历集合中的元素。几乎所有的集合都提供了<code>iterator()</code>方法，返回一个<code>Iterator</code>对象。<code>Iterator</code>有三大方法：</p><ul><li><code>hasNext()</code>：检查是否有下一个元素。</li><li><code>next()</code>：返回下一个元素。</li><li><code>remove()</code>：移除当前元素（仅在支持此操作的集合中有效）。</li></ul><h3 id="8-常见的集合操作"><a href="#8-常见的集合操作" class="headerlink" title="8. 常见的集合操作"></a>8. <strong>常见的集合操作</strong></h3><p>集合框架提供了多种操作数据的方法，常见的操作包括：</p><ul><li><strong>添加元素</strong>：<code>add(E e)</code>（<code>Set</code>、<code>List</code>等），<code>put(K key, V value)</code>（<code>Map</code>）。</li><li><strong>删除元素</strong>：<code>remove(Object o)</code>（<code>Set</code>、<code>List</code>等），<code>remove(Object key)</code>（<code>Map</code>）。</li><li><strong>查找元素</strong>：<code>contains(Object o)</code>（<code>Set</code>、<code>List</code>等），<code>containsKey(Object key)</code>（<code>Map</code>）。</li><li><strong>遍历元素</strong>：使用<code>Iterator</code>接口或增强<code>for</code>循环。</li><li><strong>大小</strong>：<code>size()</code>。</li><li><strong>清空集合</strong>：<code>clear()</code>。</li></ul><h3 id="9-集合与泛型"><a href="#9-集合与泛型" class="headerlink" title="9. 集合与泛型"></a>9. <strong>集合与泛型</strong></h3><p>Java集合框架广泛使用了泛型，使得集合能够存储任何类型的对象，并且能够在编译时提供类型检查。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>list.add(<span class="hljs-string">&quot;World&quot;</span>);<br></code></pre></td></tr></table></figure><p>上面的代码使用了泛型，<code>List</code>只能存储<code>String</code>类型的数据，避免了类型转换错误。</p><h3 id="10-集合工具类"><a href="#10-集合工具类" class="headerlink" title="10. 集合工具类"></a>10. <strong>集合工具类</strong></h3><p><code>Collections</code>类是一个工具类，提供了多种静态方法来操作集合，例如排序、查找、反转等。</p><ul><li><code>Collections.sort(List&lt;T&gt; list)</code>：对<code>List</code>进行排序。</li><li><code>Collections.shuffle(List&lt;?&gt; list)</code>：对<code>List</code>进行随机打乱。</li><li><code>Collections.reverse(List&lt;?&gt; list)</code>：反转<code>List</code>的元素顺序。</li><li><code>Collections.max(Collection&lt;? extends T&gt; coll)</code>：返回集合中的最大元素。</li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用ArrayList（实现了List接口）</span><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C++&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;List: &quot;</span> + list);<br><br>        <span class="hljs-comment">// 使用HashSet（实现了Set接口）</span><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        set.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;Apple&quot;</span>);  <span class="hljs-comment">// 重复元素不会被添加</span><br>        System.out.println(<span class="hljs-string">&quot;Set: &quot;</span> + set);<br><br>        <span class="hljs-comment">// 使用HashMap（实现了Map接口）</span><br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br>        map.put(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>);<br>        map.put(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">35</span>);<br>        System.out.println(<span class="hljs-string">&quot;Map: &quot;</span> + map);<br><br>        <span class="hljs-comment">// 使用PriorityQueue（实现了Queue接口）</span><br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        queue.add(<span class="hljs-number">5</span>);<br>        queue.add(<span class="hljs-number">2</span>);<br>        queue.add(<span class="hljs-number">8</span>);<br>        System.out.println(<span class="hljs-string">&quot;Queue: &quot;</span> + queue);<br><br>        <span class="hljs-comment">// 遍历集合</span><br>        System.out.println(<span class="hljs-string">&quot;Iterating over list:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String item : list) &#123;<br>            System.out.println(item);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java集合框架提供了丰富的数据结构和接口，能够满足不同的应用场景。选择合适的集合类型和方法，可以提高代码的效率和可读性。在实际开发中，合理地选择合适的集合类型及其操作是非常重要的。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试经典 150 题-矩阵</title>
    <link href="/2025/01/04/posts/hot150-4/"/>
    <url>/2025/01/04/posts/hot150-4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-矩阵"><a href="#LeetCode-面试经典-150-题-矩阵" class="headerlink" title="LeetCode 面试经典 150 题-矩阵"></a>LeetCode 面试经典 150 题-矩阵</h1><h2 id="有效数独"><a href="#有效数独" class="headerlink" title="有效数独"></a><a href="https://leetcode.cn/problems/valid-sudoku/description/?envType=study-plan-v2&envId=top-interview-150">有效数独</a></h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>先判断行，再判断列，再判断九宫格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidSudoku</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-comment">// 判断行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            Arrays.fill(cnt, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 每次遍历新的一行时，重置计数器</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (Character.isDigit(board[i][j])) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> board[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    <span class="hljs-keyword">if</span> (cnt[num] &gt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    cnt[num]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 判断列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>            Arrays.fill(cnt, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 每次遍历新的一列时，重置计数器</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (Character.isDigit(board[i][j])) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> board[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    <span class="hljs-keyword">if</span> (cnt[num] &gt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    cnt[num]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 判断九宫格</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">blockRow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; blockRow &lt; <span class="hljs-number">3</span>; blockRow++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">blockCol</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; blockCol &lt; <span class="hljs-number">3</span>; blockCol++) &#123;<br>                Arrays.fill(cnt, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 每次遍历新的一宫格时，重置计数器</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> blockRow * <span class="hljs-number">3</span>; i &lt; blockRow * <span class="hljs-number">3</span> + <span class="hljs-number">3</span>; i++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> blockCol * <span class="hljs-number">3</span>; j &lt; blockCol * <span class="hljs-number">3</span> + <span class="hljs-number">3</span>; j++) &#123;<br>                        <span class="hljs-keyword">if</span> (Character.isDigit(board[i][j])) &#123;  <span class="hljs-comment">// 如果是数字</span><br>                            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> board[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                            <span class="hljs-keyword">if</span> (cnt[num] &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 如果该数字已经出现过</span><br>                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                            &#125;<br>                            cnt[num]++;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(1)</li><li>空间复杂度：O(1)</li></ul><h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>创建二维数组 rows 和 columns 分别记录数独的每一行和每一列中的每个数字的出现次数，创建三维数组 subboxes 记录数独的每一个小九宫格中的每个数字的出现次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidSudoku</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-type">int</span>[][] rows = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br>        <span class="hljs-type">int</span>[][] cols = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br>        <span class="hljs-type">int</span>[][][] subboxes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">9</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>                <span class="hljs-comment">// 如果是数字</span><br>                <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> board[i][j] - <span class="hljs-string">&#x27;0&#x27;</span> - <span class="hljs-number">1</span>;<br>                    <span class="hljs-comment">// 更新</span><br>                    rows[i][index]++;<br>                    cols[j][index]++;<br>                    subboxes[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][index]++;<br>                    <span class="hljs-comment">// 不合法直接退出</span><br>                    <span class="hljs-keyword">if</span> (rows[i][index] &gt; <span class="hljs-number">1</span> || cols[j][index] &gt; <span class="hljs-number">1</span> || subboxes[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][index] &gt; <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(1)</li><li>空间复杂度：O(1)</li></ul><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/?envType=study-plan-v2&envId=top-interview-150">螺旋矩阵</a></h2><h3 id="模拟-1"><a href="#模拟-1" class="headerlink" title="模拟"></a>模拟</h3><p>定义四个方向的边界：</p><ul><li>初始：left &#x3D; 0, right &#x3D; n-1, top &#x3D; 0, down &#x3D; m - 1；</li><li>循环遍历：初始时向右走，到达右边界后，更新上边界，继续向下，到达下边界后，更新右边界，继续向左，到达左边界后，更新下边界，继续向上，到达上边界后，更新左边界，继续向右。</li><li>结束条件判断：top &gt; down || left &gt; right。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, up = <span class="hljs-number">0</span>, down = m - <span class="hljs-number">1</span>;<br><br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 向右走</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) &#123;<br>                res.add(matrix[up][i]);<br>            &#125;<br>            <span class="hljs-comment">// 更新上边界并判断是否越界</span><br>            up += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (up &gt; down) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 向下走</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> up; i &lt;= down; i++) &#123;<br>                res.add(matrix[i][right]);<br>            &#125;<br>            <span class="hljs-comment">// 更新右边界并判断是否越界</span><br>            right -= <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (right &lt; left) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 向左走</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left; i--) &#123;<br>                res.add(matrix[down][i]);<br>            &#125;<br>            <span class="hljs-comment">// 更新下边界并判断是否越界</span><br>            down -= <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (down &lt; up) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 向上走</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> down; i &gt;= up; i--) &#123;<br>                res.add(matrix[i][left]);<br>            &#125;<br>            <span class="hljs-comment">// 更新左边界并判断是否越界</span><br>            left += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(mn)$</li><li>空间复杂度：O(1)，返回值不计入。</li></ul><h2 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/?envType=study-plan-v2&envId=top-interview-150">旋转图像</a></h2><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><ul><li>(i, j) -&gt; (j, n-i-1)</li><li>(j, n-i-1) -&gt; (n-i-1, n-j-1)</li><li>(n-i-1, n-j-1) -&gt; (n-j-1, i)</li><li>(n-j-1, i) -&gt; (i, j)</li></ul><p>只需要遍历四分之一的窗格就能完成所有的旋转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n / <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[n-j-<span class="hljs-number">1</span>][i];<br>                matrix[n-j-<span class="hljs-number">1</span>][i] = matrix[n-i-<span class="hljs-number">1</span>][n-j-<span class="hljs-number">1</span>];<br>                matrix[n-i-<span class="hljs-number">1</span>][n-j-<span class="hljs-number">1</span>] = matrix[j][n-i-<span class="hljs-number">1</span>];<br>                matrix[j][n-i-<span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(1)</li></ul><h3 id="水平翻转-主对角线翻转"><a href="#水平翻转-主对角线翻转" class="headerlink" title="水平翻转+主对角线翻转"></a>水平翻转+主对角线翻转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 水平翻转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[n-i-<span class="hljs-number">1</span>][j];<br>                matrix[n-i-<span class="hljs-number">1</span>][j] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 主对角线翻转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(1)</li></ul><h2 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a><a href="https://leetcode.cn/problems/set-matrix-zeroes/?envType=study-plan-v2&envId=top-interview-150">矩阵置零</a></h2><h3 id="模拟-2"><a href="#模拟-2" class="headerlink" title="模拟"></a>模拟</h3><ol><li>额外使用两个标记变量分别记录第一行和第一列是否原本包含 0。</li><li>预处理出两个标记变量</li><li>使用其他行与列去处理第一行与第一列.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">row0</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, col0 = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 初始化标记变量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>                col0 = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) &#123;<br>                row0 = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化第一行和第一列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                    matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 根据第一行和第一列置零</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) &#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 置零第一行和第一列</span><br>        <span class="hljs-keyword">if</span> (row0) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (col0) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(1)</li></ul><h2 id="生命游戏"><a href="#生命游戏" class="headerlink" title="生命游戏"></a><a href="https://leetcode.cn/problems/game-of-life/?envType=study-plan-v2&envId=top-interview-150">生命游戏</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li>规则 1：如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡。这时候，将细胞值改为 -1，代表这个细胞过去是活的现在死了；</li><li>规则 2：如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活。这时候不改变细胞的值，仍为 1；</li><li>规则 3：如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡。这时候，将细胞的值改为 -1，代表这个细胞过去是活的现在死了。可以看到，因为规则 1 和规则 3 下细胞的起始终止状态是一致的，因此它们的复合状态也一致；</li><li>规则 4：如果死细胞周围正好有三个活细胞，则该位置死细胞复活。这时候，将细胞的值改为 2，代表这个细胞过去是死的现在活了。</li></ol><p>对于最终的输出，需要将 board 转成 0，1 的形式。因此这时候需要再遍历一次数组，将复合状态为 2 的细胞的值改为 1，复合状态为 -1 的细胞的值改为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gameOfLife</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] board)</span> &#123;<br>        <span class="hljs-type">int</span>[] neighbors = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-comment">// 遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; row &lt; m; row++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>                <span class="hljs-comment">// 统计活细胞数</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br>                        <span class="hljs-keyword">if</span> (!(neighbors[i] == <span class="hljs-number">0</span> &amp;&amp; neighbors[j] == <span class="hljs-number">0</span>)) &#123;<br>                            <span class="hljs-comment">// 相邻位置坐标</span><br>                            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> row + neighbors[i];<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> col + neighbors[j];<br>                            <span class="hljs-comment">// 查看相邻的细胞是否是活细胞</span><br>                            <span class="hljs-keyword">if</span> ((r &lt; m &amp;&amp; r &gt;= <span class="hljs-number">0</span>) &amp;&amp; (c &lt; n &amp;&amp; c &gt;= <span class="hljs-number">0</span>) &amp;&amp; (Math.abs(board[r][c]) == <span class="hljs-number">1</span>)) &#123;<br>                                cnt++;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// 规则1,3</span><br>                <span class="hljs-keyword">if</span> ((board[row][col] == <span class="hljs-number">1</span>) &amp;&amp; (cnt &lt; <span class="hljs-number">2</span> || cnt &gt; <span class="hljs-number">3</span>)) &#123;<br>                    board[row][col] = -<span class="hljs-number">1</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 规则4</span><br>                <span class="hljs-keyword">if</span> (board[row][col] == <span class="hljs-number">0</span> &amp;&amp; cnt == <span class="hljs-number">3</span>) &#123;<br>                    board[row][col] = <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 更新状态</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] &gt; <span class="hljs-number">0</span>) &#123;<br>                    board[i][j] = <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    board[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>矩阵</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试经典 150 题-滑动窗口</title>
    <link href="/2025/01/02/posts/hot150-3/"/>
    <url>/2025/01/02/posts/hot150-3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-滑动窗口"><a href="#LeetCode-面试经典-150-题-滑动窗口" class="headerlink" title="LeetCode 面试经典 150 题-滑动窗口"></a>LeetCode 面试经典 150 题-滑动窗口</h1><h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">长度最小的子数组</a></h2><h3 id="前缀和-滑动窗口"><a href="#前缀和-滑动窗口" class="headerlink" title="前缀和+滑动窗口"></a>前缀和+滑动窗口</h3><p>子数组不是子序列，不能去掉一些数字，它必须是连续的。考虑求数组的前缀和，前缀和数组一定是飞递减的，因为数组中的数字都是大于0的。然后遍历前缀和数组，维护一个滑动窗口，如果当前和小于目标，则滑动窗口的右指针右移扩大窗口，否则左指针右移缩小窗口，同时更新最短子数组长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 计算前缀和</span><br>        <span class="hljs-type">int</span>[] prefix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            prefix[i] = prefix[i-<span class="hljs-number">1</span>] + nums[i-<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 滑动窗口</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> n + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(right &lt;= n) &#123;<br>            <span class="hljs-keyword">if</span> (prefix[right] - prefix[left] &gt;= target) &#123;<br>                ans = Math.min(ans, right - left);<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == n + <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="优化空间复杂度"><a href="#优化空间复杂度" class="headerlink" title="优化空间复杂度"></a>优化空间复杂度</h3><p>空间复杂度可以优化，一边计算前缀和，一边收缩边界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 滑动窗口</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> n + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; n; right++) &#123;<br>            sum += nums[right];<br>            <span class="hljs-comment">// 更新左边界</span><br>            <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>                ans = Math.min(ans, right - left + <span class="hljs-number">1</span>);<br>                sum -= nums[left];<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == n + <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-interview-150">无重复字符的最长子串</a></h2><h3 id="哈希表-滑动窗口"><a href="#哈希表-滑动窗口" class="headerlink" title="哈希表+滑动窗口"></a>哈希表+滑动窗口</h3><p>用一个哈希表记录当前窗口内的字符情况。如果右指针向右移动扩大窗口范围不会造成重复字符出现，那么就扩展，否则移动左指针至窗口内不含重复字符，同时更新最大长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; n; right++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            <span class="hljs-comment">// 扩展窗口</span><br>            hash[ch]++;<br>            <span class="hljs-comment">// 保证没有重复字符</span><br>            <span class="hljs-keyword">while</span> (hash[ch] &gt; <span class="hljs-number">1</span>) &#123;<br>                hash[s.charAt(left)]--;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">// 更新最大长度</span><br>            ans = Math.max(ans, right - left + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，每个字符最多被移入和移出一次。</li><li>空间复杂度：$O(|\Sigma|)$，所有 ASCII 码在 [0,128) 内的字符。</li></ul><p>也可以用bool类型代替int，因为只需要判断有没有出现过，不需要知道有几个。也可以用hashset。</p><h2 id="串联所有单词的子串"><a href="#串联所有单词的子串" class="headerlink" title="串联所有单词的子串"></a><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/?envType=study-plan-v2&envId=top-interview-150">串联所有单词的子串</a></h2><h3 id="哈希表-滑动窗口-1"><a href="#哈希表-滑动窗口-1" class="headerlink" title="哈希表+滑动窗口"></a>哈希表+滑动窗口</h3><ol><li>初始化<ul><li>res：存储结果的列表。</li><li>m：单词列表 words 的长度，即单词的个数。</li><li>n：单词的长度（假设 words 中的单词长度一致）。</li><li>ls：字符串 s 的长度。</li></ul></li><li>外层循环：遍历从 0 到 n-1 的索引，利用滑动窗口处理子串，并确保窗口起点与单词长度对齐。</li><li>滑动窗口初始化<ul><li>在滑动窗口的初始范围内，统计窗口中单词的频率并存入 differ。</li><li>对比 differ 和 words，将 words 中的单词频率从 differ 中减去，得到初始的频率差异。</li></ul></li><li>滑动窗口更新<ul><li>每次窗口向右滑动一个单词的长度，更新窗口中新增和移除的单词频率。</li><li>如果 differ 为空，则说明当前窗口内的子串满足条件，记录起始索引。</li></ul></li><li>返回结果：返回所有满足条件的起始索引</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findSubstring</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> words.length, n = words[<span class="hljs-number">0</span>].length(), ls = s.length();<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 外层循环，确保窗口起点与单词长度对齐</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 超出字符串长度的起始位置无需处理</span><br>            <span class="hljs-keyword">if</span> (i + m * n &gt; ls) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 窗口中单词的频率并存入 differ</span><br>            Map&lt;String, Integer&gt; differ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Integer&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> s.substring(i + j * n, i + (j + <span class="hljs-number">1</span>) * n);<br>                differ.put(word, differ.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">// 对比 differ 和 words，将 words 中的单词频率从 differ 中减去</span><br>            <span class="hljs-keyword">for</span> (String word : words) &#123;<br>                differ.put(word, differ.getOrDefault(word, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (differ.get(word) == <span class="hljs-number">0</span>) &#123;<br>                    differ.remove(word);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 滑动窗口更新，每次窗口向右滑动一个单词的长度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> i; start &lt; ls - m * n + <span class="hljs-number">1</span>; start += n) &#123;<br>                <span class="hljs-keyword">if</span> (start != i) &#123;<br>                    <span class="hljs-comment">// 加入向右滑动的一个单词</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> s.substring(start + (m-<span class="hljs-number">1</span>) * n, start + m * n);<br>                    differ.put(word, differ.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">if</span> (differ.get(word) == <span class="hljs-number">0</span>) &#123;<br>                        differ.remove(word);<br>                    &#125;<br>                    <span class="hljs-comment">// 去掉左边被滑出的单词</span><br>                    word = s.substring(start - n, start);<br>                    differ.put(word, differ.getOrDefault(word, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">if</span> (differ.get(word) == <span class="hljs-number">0</span>) &#123;<br>                        differ.remove(word);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 如果频次差异为空，则说明是一个串联子串</span><br>                <span class="hljs-keyword">if</span> (differ.isEmpty()) &#123;<br>                    res.add(start);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(ls×n)，其中 ls 是输入 s 的长度，n 是 words 中每个单词的长度。需要做 n 次滑动窗口，每次需要遍历一次 s。</li><li>空间复杂度：O(m×n)，其中 m 是 words 的单词数，n 是 words 中每个单词的长度。每次滑动窗口时，需要用一个哈希表保存单词频次。</li></ul><p>这道题有点难，以后再好好想一想。</p><h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/?envType=study-plan-v2&envId=top-interview-150">最小覆盖子串</a></h2><h3 id="哈希表-滑动窗口-2"><a href="#哈希表-滑动窗口-2" class="headerlink" title="哈希表+滑动窗口"></a>哈希表+滑动窗口</h3><p>维护一个哈希表，记录字符串t的情况。滑动窗口，同时再维护一个哈希表。移动右指针，更新哈希表情况，查看能否覆盖，判断涵盖t可以使用两个数组分别统计当前s和t的字符数情况，然后每次逐个字符判断，这样每次都要花费 O(∣Σ∣) 的时间去判断是否涵盖。因此可以用一个变量less代替，即目前子串中有 less 种字母的出现次数小于 t 中字母的出现次数。若不能则继续移动右指针，否则移动左指针。</p><ol><li>初始化左右指针。</li><li>用一个哈希表统计t的字符情况。</li><li>初始化left，并用一个哈希表统计s的情况。</li><li>初始化 less 为 t 中的不同字母个数。</li><li>遍历 s，设当前枚举的子串右端点为 right，把字母 c&#x3D;s[right] 的出现次数加一。加一后，如果 cntS[c]&#x3D;cntT[c]，说明 c 的出现次数满足要求，把 less 减一。<br>如果 less&#x3D;0，说明 cntS 中的每个字母及其出现次数都大于等于 cntT 中的字母出现次数，那么：<ul><li>更新最短子串长度；</li><li>滑动窗口左边界右移，更新cntS和less。</li><li>重复上述步骤直至less&gt;0.</li></ul></li><li>如果 ansLeft&lt;0，说明没有找到符合要求的子串，返回空字符串，否则返回下标 ansLeft 到下标 ansRight 之间的子串。</li><li>可以把 cntS 和 cntT 合并成一个 cnt，定义cnt[x]&#x3D;cntT[x]−cntS[x]。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">less</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ansLeft</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, ansRight = m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 统计不同字母数</span><br>            <span class="hljs-keyword">if</span> (cnt[t.charAt(i)] == <span class="hljs-number">0</span>) &#123;<br>                less++;<br>            &#125;<br>            <span class="hljs-comment">// 更新哈希表</span><br>            cnt[t.charAt(i)]++;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历 s，滑动窗口</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; m; right++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            <span class="hljs-comment">// 更新哈希表和less</span><br>            cnt[ch]--;<br>            <span class="hljs-keyword">if</span> (cnt[ch] == <span class="hljs-number">0</span>) &#123;<br>                less--;<br>            &#125;<br>            <span class="hljs-comment">// 如果涵盖，滑动左边界</span><br>            <span class="hljs-keyword">while</span> (less == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 更新结果</span><br>                <span class="hljs-keyword">if</span> (right - left &lt; ansRight - ansLeft) &#123;<br>                    ansLeft = left;<br>                    ansRight = right;<br>                &#125;<br>                <span class="hljs-comment">// 更新哈希表</span><br>                cnt[s.charAt(left)]++;<br>                <span class="hljs-comment">// 更新less</span><br>                <span class="hljs-keyword">if</span> (cnt[s.charAt(left)] &gt; <span class="hljs-number">0</span>) &#123;<br>                    less++;<br>                &#125;<br>                left++;<br>            &#125; <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ansLeft == -<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : s.substring(ansLeft, ansRight + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m + n)</li><li>空间复杂度：$O(|\Sigma|)$</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>滑动窗口的题目通常与双指针和哈希表相关联，以后要多加复习。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>滑动窗口</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试经典 150 题-双指针</title>
    <link href="/2025/01/01/posts/hot150-2/"/>
    <url>/2025/01/01/posts/hot150-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-双指针"><a href="#LeetCode-面试经典-150-题-双指针" class="headerlink" title="LeetCode 面试经典 150 题-双指针"></a>LeetCode 面试经典 150 题-双指针</h1><h2 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a><a href="https://leetcode.cn/problems/valid-palindrome/submissions/?envType=study-plan-v2&envId=top-interview-150">验证回文串</a></h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>定义双指针指向首尾，left向右移动，right向左移动，如果遇到非字母数字字符，可以直接将其忽略，继续判断下一个字符，如果两指针所指字符都是字母数字字符且不相等，直接返回false，否则待两指针相遇，返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">// 跳过不合法字符</span><br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(left))) &#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(right))) &#123;<br>                right--;<br>            &#125;<br>            <span class="hljs-comment">// 提前退出判断</span><br>            <span class="hljs-keyword">if</span> (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">// 移动指针</span><br>            left++;<br>            right--;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a><a href="https://leetcode.cn/problems/is-subsequence/?envType=study-plan-v2&envId=top-interview-150">判断子序列</a></h2><h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h3><p>定义分别指向s和t的枚举指针，如果当前两指针所指字符相等，则两指针可以右移，否则指向t的指针右移，直到相等或走到末尾，最后判断p1是否走到末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-keyword">if</span> (m &gt; n) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (p1 &lt; m &amp;&amp; p2 &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(p1) == t.charAt(p2)) &#123;<br>                p1++;<br>            &#125;<br>            p2++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p1 == m;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>进阶：</p><p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>定义状态：构建一个长度为 n（t 的长度）的数组 dp[i][j]，该数组记录每个字符的下一个位置。</li><li>状态转移：如果 t 中位置 i 的字符就是 j，那么 dp[i][j]&#x3D;i，否则 j 出现在位置 i+1 开始往后，即 dp[i][j]&#x3D;dp[i+1][j]，因此我们要倒过来进行动态规划，从后往前枚举 i。</li><li>初始条件：dp[n][i] &#x3D; n，表示找不到字符。</li><li>返回结果：对字符串s进行检索。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-keyword">if</span> (m &gt; n) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 构建位置索引表，dp[i][c]表示从位置i开始，字符c的下一个位置</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            dp[n][i] = n;<br>        &#125;<br>        <span class="hljs-comment">// 填充dp数组，dp[i][c]表示从i开始，字符c的下一个出现位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (t.charAt(i) == j + <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                    dp[i][j] = i;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 检索</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            index = dp[index][c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (index == n) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \cdot |\Sigma| + m)$</li><li>空间复杂度：$O(n \cdot |\Sigma|)$，为动态规划数组的开销。</li></ul><h2 id="两数之和II-输入有序数组"><a href="#两数之和II-输入有序数组" class="headerlink" title="两数之和II-输入有序数组"></a><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/?envType=study-plan-v2&envId=top-interview-150">两数之和II-输入有序数组</a></h2><h3 id="双指针-2"><a href="#双指针-2" class="headerlink" title="双指针"></a>双指针</h3><p>左右指针分别指向首尾，如果当前和大于target，右指针左移，如果小于target则左指针右移，如果相等直接返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> numbers.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> numbers[left] + numbers[right];<br>            <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-interview-150">盛最多水的容器</a></h2><h3 id="双指针-3"><a href="#双指针-3" class="headerlink" title="双指针"></a>双指针</h3><p>定义双指针分别指向首尾，当前最大面积为两指针所指高度的较小值乘以它们之间的距离(right-left)，不断更新这个面积的最大值，直至两指针相遇，然后移动较低的那个指针。</p><p>如果移动高的那一边，会有两种情况：</p><ol><li>下一根柱子的高度比现在高，高度还取最小值低的那边，最大水量比原来小</li><li>下一根柱子的高度比现在低，高度比原来的最小值还小，最大水量比原来小</li></ol><p>如果移动低的那一边，会有两种情况：</p><ol><li>下一根柱子的高度比现在高，高度就可以取更高的值，最大水量不一定比原来小</li><li>下一根柱子的高度比现在低，高度比原来的最小值还小，最大水量比原来小</li></ol><p>所以应该移动低的那一边。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> Math.min(height[left], height[right]) * (right - left);<br>            ans = Math.max(ans, area);<br>            <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a href="https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-interview-150">三数之和</a></h2><h3 id="双指针-4"><a href="#双指针-4" class="headerlink" title="双指针"></a>双指针</h3><p>首先对数组进行排序，每次固定一个数x，然后用双指针去寻找和为-x的两个数。由于答案中不可以包含重复的三元组，所以在寻找时要跳过重复的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">// 遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-comment">// 跳过重复数字</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 固定当前元素，找和为0-x的两数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> - nums[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                    ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right])));<br>                    <span class="hljs-comment">// 跳过重复元素</span><br>                    <span class="hljs-keyword">for</span> (left += <span class="hljs-number">1</span>; left &lt; right &amp;&amp; nums[left] == nums[left-<span class="hljs-number">1</span>]; left++);<br>                    <span class="hljs-keyword">for</span> (right -= <span class="hljs-number">1</span>; left &lt; right &amp;&amp; nums[right] == nums[right+<span class="hljs-number">1</span>]; right--);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    left++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(logn)，排序所用的空间。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>双指针</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>致已经过去的2024和将要到来的2025</title>
    <link href="/2024/12/31/diaries/20241231/"/>
    <url>/2024/12/31/diaries/20241231/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="致已经过去的2024和将要到来的2025"><a href="#致已经过去的2024和将要到来的2025" class="headerlink" title="致已经过去的2024和将要到来的2025"></a>致已经过去的2024和将要到来的2025</h1><p>2024年又要过去了，一年又一年，去年的今天，和朋友一起去了沈阳跨年，今年是一个人咯，来回忆一下过去这一年吧。</p><p>元旦三天假去了沈阳，去了沈阳故宫、大帅府，还去滑雪。回来之后开始为自己争取一些权利，但是没有成功，并且度过了一段非常痛苦的日子。这里，我不想再过多地回忆这些，因为我能回忆到的，也只是无力、绝望。月底放假回家过年了，算是能够休整一段时间。</p><p>二月初，在过年的前夕，发生了梅西香港行事件，虽然它本应该称为“迈阿密香港行”。在此之前，我几乎从没在互联网上发表过评论，但这一次让我切切实实感受到自媒体是如何影响社会舆论，影响个体思考的。原来爱国已经变成这些人手中的赚钱工具，他们可以为了流量罔顾事实，可以给一个什么都没做的人扣上一顶帽子，然后用所谓的“证据”去证明自己的“观点”。这也让我反思，在过去那些社会事件中，我是否也有过不经思考而直接听信自媒体言论的时刻。</p><p>三月、四月、五月、六月、七月、八月，我记不起自己具体做过什么，反正就是在学校，在实验室，一天又一天，重复的、枯燥的生活。哦对了，三月份和好朋友一起去现场看了世预赛，现场看比赛真的很不一样。7月15日，阿根廷又拿下了一次美洲杯冠军！八月中旬回家了两周，带妈妈和弟弟去安阳玩了两天，去看了曹操陵、岳飞庙、殷墟……然后这两周就这样飞快地过去了，我又回到了学校，开始了研二生活。八月底九月初去了大连，终于看了陈奕迅的演唱会！</p><p>九月到现在，我终于能感受到自己做了点什么，而不是每天虚度光阴，陷入在痛苦又无意义的内耗中。我开始真正去做，而不是停留在想，当然还是有很多时候都在想。我看了《白日梦想家》，把《Stay Alive》设成了起床铃声，告诉自己不要想太多，专注当下去做就好。是的，只有每天都做了，在不断地做，才能缓解焦虑，同时也会慢慢感受到自己的进步。这个学期又要结束了，时间过得真的很快，我不想再去责怪自己过去的一年做错了多少事，养成了多少坏习惯，浪费了多少时间，因为在那个时候，我能挺过来，继续保持乐观向上的心态，已经很不容易了，不是吗？而且，也并不是一无所获的，我还写了几篇技术文章，拿到了稿费，这也是行动，不是吗？</p><p>还有就是，我越来越发现，在经过孤独的本科四年后，我已经进入到享受孤独的状态。在和别人一起玩的时候，我根本感受不到快乐，我能感受到的就是空虚。我最快乐的时候就是没有ddl，自己一个人学东西也好，躺在床上也好，只要是按照自己的心情、自己的计划来，就能感受到快乐。和别人在一起，即使是很熟悉的朋友，我也会不知道该说什么，不知道该玩什么，感觉什么都没意思。</p><p>好了，就不再对自己剖析太多了。那些社恐、讨好型人格、回避型依恋等等等等的心理疾病，或者说标签，我都希望自己能在行动中慢慢丢掉。我喜欢说，祝自己未来一切顺利，但是我知道，它不会一帆风顺的。但好在，只要我在行动，我就一定会成为比昨天更好的自己。就像14年的梅西不知道他会在21年拿到美洲杯、22年拿到世界杯那样，我能做的只有坚持，坚持学习，坚持张开嘴表达自己，坚持相信。</p><p>加油，找到自己的25号底片！</p>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试经典 150 题-数组/字符串</title>
    <link href="/2024/12/25/posts/hot150-1/"/>
    <url>/2024/12/25/posts/hot150-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-面试经典-150-题-数组-字符串"><a href="#LeetCode-面试经典-150-题-数组-字符串" class="headerlink" title="LeetCode 面试经典 150 题-数组&#x2F;字符串"></a>LeetCode 面试经典 150 题-数组&#x2F;字符串</h1><h2 id="移出元素"><a href="#移出元素" class="headerlink" title="移出元素"></a><a href="https://leetcode.cn/problems/remove-element/description/?envType=study-plan-v2&envId=top-interview-150">移出元素</a></h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>初始化左右指针指向首尾，如果右指针指向val，就不断左移，如果左指针指向val，就和右指针交换，然后左指针右移，右指针左移，直到两者相遇。最后left所指向的位置就是第一个为val的下标，也就是非val元素的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-comment">// 右指针必须指向非val元素</span><br>            <span class="hljs-keyword">while</span> (right &gt;= left &amp;&amp; nums[right] == val)&#123;<br>                right--;<br>            &#125;<br>            <span class="hljs-comment">// 左指针找到指向val的元素</span><br>            <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; nums[left] != val) &#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">// 如果左指针小于等于右指针，说明可以交换</span><br>            <span class="hljs-keyword">if</span> (left &lt;= right) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>                nums[left] = nums[right];<br>                nums[right] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>优化：实际上我们并不在乎放到right位置的值是多少，所以可以将right的值赋值给left，然后更新right指针，而不用管right的值是多少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[left] == val) &#123;<br>                nums[left] = nums[right];<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类似颜色分类时用到的方法"><a href="#类似颜色分类时用到的方法" class="headerlink" title="类似颜色分类时用到的方法"></a>类似颜色分类时用到的方法</h3><p>一边遍历，一边填入，k指向是为val的下标，i指向的是不为val的下标。</p><ol><li>初始化要填入的下标 k&#x3D;0。</li><li>从左到右遍历 nums，如果 nums[i]!&#x3D;val，则更新 nums[k]&#x3D;nums[i]，然后把 k 加一。</li><li>遍历结束，返回 k。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != val) &#123;<br>                nums[k++] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/?envType=study-plan-v2&envId=top-interview-150">删除有序数组中的重复项</a></h2><h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h3><ol><li>初始化指针k指向0，i用来遍历。</li><li>如果nums[i] !&#x3D; nums[k]，先k++，再交换两元素，然后继续遍历。</li><li>最后返回k+1。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != nums[k]) &#123;<br>                k++;<br>                nums[k] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> k + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="删除有序数组中的重复项II"><a href="#删除有序数组中的重复项II" class="headerlink" title="删除有序数组中的重复项II"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/?envType=study-plan-v2&envId=top-interview-150">删除有序数组中的重复项II</a></h2><h3 id="双指针-2"><a href="#双指针-2" class="headerlink" title="双指针"></a>双指针</h3><ol><li>处理特殊情况，n&lt;2可以直接返回。</li><li>初始化左右指针都为2，枚举右指针。</li><li>如果nums[left-2]!&#x3D;nums[right]，就可以更新nums[left]，然后左指针左移。</li><li>最后返回left。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; right &lt; n; right++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[left-<span class="hljs-number">2</span>] != nums[right]) &#123;<br>                nums[left++] = nums[right];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>对于上面的题目可以总结为：左指针永远指向待更新的位置，右指针枚举每一个元素，当满足条件时，就将右指针元素放在左指针位置，然后左指针右移。</p><h2 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a><a href="https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-interview-150">轮转数组</a></h2><h3 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h3><p>先将数组反转，然后反转数组的前k的数，再反转后n-k个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        k = k % n;  <span class="hljs-comment">// n次旋转就会旋转到最初的数组</span><br>        reverse(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        reverse(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>        reverse(nums, k, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[start];<br>            nums[start] = nums[end];<br>            nums[end] = temp;<br>            start++;<br>            end--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="H指数"><a href="#H指数" class="headerlink" title="H指数"></a><a href="https://leetcode.cn/problems/h-index/description/?envType=study-plan-v2&envId=top-interview-150">H指数</a></h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>首先我们可以将初始的 H 指数 h 设为 0，然后将引用次数排序，并且对排序后的数组从大到小遍历。</p><p>根据 H 指数的定义，如果当前 H 指数为 h 并且在遍历过程中找到当前值 citations[i]&gt;h，则说明我们找到了一篇被引用了至少 h+1 次的论文，所以将现有的 h 值加 1。继续遍历直到 h 无法继续增大。最后返回 h 作为最终答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] citations)</span> &#123;<br>        Arrays.sort(citations);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = citations.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; citations[i] &gt; h) &#123;<br>            h++;<br>            i--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)</li></ul><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>设 n 为 citations 的长度，即这名研究者发表的论文数。根据题意，h 不可能超过 n，所以对于引用次数大于 n 的论文，我们在统计的时候，可以看成是引用次数等于 n 的论文。</p><p>创建一个长为 n+1 的 cnt 数组，统计 min(citations[i],n) 的出现次数。设 s 为引用次数 ≥i 的论文数，我们需要算出满足 s≥i 的最大的 i。</p><p>从 i&#x3D;n 开始倒序循环，每次循环，把 cnt[i] 加到 s 中。由于我们是倒序循环的，只要 s≥i 成立，此时的 i 就是满足 s≥i 的最大的 i，直接返回 i 作为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] citations)</span> &#123;<br>        <span class="hljs-comment">// 计算引用次数为i的文章数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> citations.length;<br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 最多引用次数为n，因为即使大于n，h也不可能大于n</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> citation : citations) &#123;<br>            cnt[Math.min(citation, n)]++;<br>        &#125;<br>        <span class="hljs-comment">// 从后向前找到最大的文章数（文章数要大于等于引用次数）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; ; i--) &#123;<br>            s += cnt[i];    <span class="hljs-comment">// 引用次数大于等于i的文章数</span><br>            <span class="hljs-keyword">if</span> (s &gt;= i) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>设查找范围的初始左边界 left 为 0，初始右边界 right 为 n。每次在查找范围内取中点 mid，同时扫描整个数组，判断是否至少有 mid 个数大于 mid。如果有，说明要寻找的 h 在搜索区间的右边，反之则在左边。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] citations)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> citations.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n;    <br>        <span class="hljs-comment">// 二分查找</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 统计大于等于引用次数mid的文章数cnt</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (citations[i] &gt;= mid) &#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// h还可能更大</span><br>            <span class="hljs-keyword">if</span> (cnt &gt;= mid) &#123;<br>                left = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><p>复习一下股票和跳跃游戏。</p><h2 id="O-1-时间插入、删除和获取随机元素"><a href="#O-1-时间插入、删除和获取随机元素" class="headerlink" title="O(1)时间插入、删除和获取随机元素"></a><a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/?envType=study-plan-v2&envId=top-interview-150">O(1)时间插入、删除和获取随机元素</a></h2><h3 id="变长数组-哈希表"><a href="#变长数组-哈希表" class="headerlink" title="变长数组+哈希表"></a>变长数组+哈希表</h3><p>变长数组中存储元素，哈希表中存储每个元素在变长数组中的下标。</p><ul><li>插入：<ul><li>判断是否存在于哈希表，不存在则插入；</li><li>插入变长数组末尾；</li><li>将元素值和下标插入哈希表；</li></ul></li><li>删除：<ul><li>判断是否存在于哈希表，存在则获取其下标删除；</li><li>将变长数组的最后一个元素 last 移动到下标 index 处，在哈希表中将 last 的下标更新为 index；</li><li>在变长数组中删除最后一个元素，在哈希表中删除 val；</li></ul></li><li>获取随机数：<ul><li>限制下标范围在n以内；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomizedSet</span> &#123;<br>    List&lt;Integer&gt; nums;<br>    Map&lt;Integer, Integer&gt; hash;<br>    Random random;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RandomizedSet</span><span class="hljs-params">()</span> &#123;<br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        random = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 检查是否存在于哈希表</span><br>        <span class="hljs-keyword">if</span> (hash.containsKey(val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 插入</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> nums.size();<br>        nums.add(val);<br>        hash.put(val, index);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 判断是否存在于哈希表中</span><br>        <span class="hljs-keyword">if</span> (!hash.containsKey(val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 删除</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> hash.get(val);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> nums.get(n - <span class="hljs-number">1</span>);<br>        nums.set(index, last);<br>        hash.put(last, index);<br>        nums.remove(n - <span class="hljs-number">1</span>);<br>        hash.remove(val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRandom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">randomIndex</span> <span class="hljs-operator">=</span> random.nextInt(nums.size());<br>        <span class="hljs-keyword">return</span> nums.get(randomIndex);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your RandomizedSet object will be instantiated and called as such:</span><br><span class="hljs-comment"> * RandomizedSet obj = new RandomizedSet();</span><br><span class="hljs-comment"> * boolean param_1 = obj.insert(val);</span><br><span class="hljs-comment"> * boolean param_2 = obj.remove(val);</span><br><span class="hljs-comment"> * int param_3 = obj.getRandom();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：所有操作的时间复杂度都是O(1)</li><li>空间复杂度：O(n)，存储元素的数组和哈希表需要 O(n) 的空间。</li></ul><h2 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-interview-150">除自身以外数组的乘积</a></h2><h3 id="前缀积-后缀积"><a href="#前缀积-后缀积" class="headerlink" title="前缀积+后缀积"></a>前缀积+后缀积</h3><p>题目要求不能用除法，考虑前缀和的思想，prefix保存前缀积，suffix保存后缀积，对于每一个元素它最终的结果都是<code>prefix[i] * suffix[i]</code>。</p><ul><li><code>prefix[i] = prefix[i-1] * nums[i-1]</code></li><li><code>suffix[i] = prefix[i+1] * nums[i+1]</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] prefix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] suffix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 计算前缀积</span><br>        prefix[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            prefix[i] = prefix[i-<span class="hljs-number">1</span>] * nums[i-<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 计算后缀积</span><br>        suffix[n-<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            suffix[i] = suffix[i+<span class="hljs-number">1</span>] * nums[i+<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 计算结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            prefix[i] *= suffix[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> prefix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>由于输出数组不算在空间复杂度内，那么我们可以将前后缀数组用输出数组来计算。先把输出数组当作前缀数组来计算，然后再动态构造后缀数组得到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] answer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br>        <span class="hljs-comment">// 计算前缀积</span><br>        answer[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            answer[i] = answer[i-<span class="hljs-number">1</span>] * nums[i-<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 计算后缀积的同时更新结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">suf</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            answer[i] *= suf;<br>            suf *= nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>复习昨天做的题目。</p><h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a><a href="https://leetcode.cn/problems/gas-station/?envType=study-plan-v2&envId=top-interview-150">加油站</a></h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>计算从每个站点出发能否完成一圈，找到最优的起点，避免直接从每个站点暴力判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] gas, <span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> gas.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">spare</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minSpare</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE, minIndex = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            spare += gas[i] - cost[i];<br>            <span class="hljs-keyword">if</span> (spare &lt; minSpare) &#123;<br>                minSpare = spare;<br>                minIndex = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> spare &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : (minIndex + <span class="hljs-number">1</span>) % n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><a href="https://leetcode.cn/problems/candy/?envType=study-plan-v2&envId=top-interview-150">分发糖果</a></h2><h3 id="两次遍历"><a href="#两次遍历" class="headerlink" title="两次遍历"></a>两次遍历</h3><p>初始化答案数组每个都是1：</p><ul><li>当ratings[i] &gt; ratings[i-1]时，第 i 个孩子的糖果数量比第i - 1个孩子的糖果数量多；</li><li>当ratings[i] &gt; ratings[i+1]时，第 i 个孩子的糖果数量比第i + 1个孩子的糖果数量多。</li></ul><p>因此分别从左到右遍历一次，再从右向左遍历一次，更新状态方式：</p><ul><li>从左到右：如果<code>ratings[i] &gt; ratings[i-1]</code>，则<code>sweets[i] = sweets[i-1] + 1</code>；</li><li>从右到左：如果<code>ratings[i] &gt; ratings[i+1]</code>，则<code>sweets[i] = max(sweets[i], sweets[i+1] + 1)</code>；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">candy</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ratings)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> ratings.length;<br>        <span class="hljs-type">int</span>[] sweets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(sweets, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 左规则</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i-<span class="hljs-number">1</span>]) &#123;<br>                sweets[i] = sweets[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 右规则</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>]) &#123;<br>                sweets[i] = Math.max(sweets[i], sweets[i+<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 求和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            ans += sweets[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="常数空间遍历"><a href="#常数空间遍历" class="headerlink" title="常数空间遍历"></a>常数空间遍历</h3><p>翻译了一下别人的python代码，不太理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">candy</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ratings)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> ratings.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 初始化结果为 1, 因为第一个孩子至少分配一个糖果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 记录当前递增区间的糖果数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">desNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录递减区间的长度</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt;= ratings[i-<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">if</span> (desNum &gt; <span class="hljs-number">0</span>) &#123;<br>                    res += (<span class="hljs-number">1</span> + desNum) * desNum / <span class="hljs-number">2</span>;<br>                    <span class="hljs-comment">// 递减长度比先前值大,所以我们要把先前值补充</span><br>                    <span class="hljs-keyword">if</span> (pre &lt;= desNum) &#123;<br>                        res += desNum- pre + <span class="hljs-number">1</span>;<br>                    &#125;<br>                    pre = <span class="hljs-number">1</span>;<br>                    desNum = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (ratings[i] == ratings[i - <span class="hljs-number">1</span>]) &#123;<br>                    pre = <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    pre += <span class="hljs-number">1</span>;<br>                &#125;<br>                res += pre;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                desNum++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (desNum &gt; <span class="hljs-number">0</span>) &#123;<br>            res += ((<span class="hljs-number">1</span> + desNum) * desNum) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (pre &lt;= desNum) &#123;<br>                res += desNum - pre + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>复习接雨水等单调栈问题。</p><h2 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a><a href="https://leetcode.cn/problems/roman-to-integer/?envType=study-plan-v2&envId=top-interview-150">罗马数字转整数</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>设 x&#x3D;s[i−1],y&#x3D;s[i]，这是两个相邻的罗马数字。</li><li>如果 x 的数值小于 y 的数值，那么 x 的数值要取相反数。例如 IV 中的 I 相当于 −1，CM 中的 C 相当于 −100。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Character, Integer&gt; ROMAN = Map.of(<br>        <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-number">1</span>,<br>        <span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-number">5</span>,<br>        <span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-number">10</span>,<br>        <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-number">50</span>,<br>        <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">100</span>,<br>        <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-number">500</span>,<br>        <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">1000</span><br>    );<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">romanToInt</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> ROMAN.get(s.charAt(i-<span class="hljs-number">1</span>));<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> ROMAN.get(s.charAt(i));<br>            ans += x &lt; y ? -x : x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans + ROMAN.get(s.charAt(n-<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a><a href="https://leetcode.cn/problems/integer-to-roman/?envType=study-plan-v2&envId=top-interview-150">整数转罗马数字</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>硬编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[][] R = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[][]&#123;<br>        &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;II&quot;</span>, <span class="hljs-string">&quot;III&quot;</span>, <span class="hljs-string">&quot;IV&quot;</span>, <span class="hljs-string">&quot;V&quot;</span>, <span class="hljs-string">&quot;VI&quot;</span>, <span class="hljs-string">&quot;VII&quot;</span>, <span class="hljs-string">&quot;VIII&quot;</span>, <span class="hljs-string">&quot;IX&quot;</span>&#125;, <span class="hljs-comment">// 个位</span><br>        &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;XX&quot;</span>, <span class="hljs-string">&quot;XXX&quot;</span>, <span class="hljs-string">&quot;XL&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>, <span class="hljs-string">&quot;LX&quot;</span>, <span class="hljs-string">&quot;LXX&quot;</span>, <span class="hljs-string">&quot;LXXX&quot;</span>, <span class="hljs-string">&quot;XC&quot;</span>&#125;, <span class="hljs-comment">// 十位</span><br>        &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;CC&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>, <span class="hljs-string">&quot;CD&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;DC&quot;</span>, <span class="hljs-string">&quot;DCC&quot;</span>, <span class="hljs-string">&quot;DCCC&quot;</span>, <span class="hljs-string">&quot;CM&quot;</span>&#125;, <span class="hljs-comment">// 百位</span><br>        &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;MM&quot;</span>, <span class="hljs-string">&quot;MMM&quot;</span>&#125;, <span class="hljs-comment">// 千位</span><br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">intToRoman</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">return</span> R[<span class="hljs-number">3</span>][num / <span class="hljs-number">1000</span>] + R[<span class="hljs-number">2</span>][num / <span class="hljs-number">100</span> % <span class="hljs-number">10</span>] + R[<span class="hljs-number">1</span>][num / <span class="hljs-number">10</span> % <span class="hljs-number">10</span>] + R[<span class="hljs-number">0</span>][num % <span class="hljs-number">10</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(1)</li><li>空间复杂度：O(1)</li></ul><h2 id="最后一个单词的长度"><a href="#最后一个单词的长度" class="headerlink" title="最后一个单词的长度"></a><a href="https://leetcode.cn/problems/length-of-last-word/description/?envType=study-plan-v2&envId=top-interview-150">最后一个单词的长度</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>从后往前找到第一个不为空格的字符，从此开始计数，然后找到为空格的位置，计数结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLastWord</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            i--;<br>        &#125;<br>        <span class="hljs-comment">// 单词起始</span><br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            ans++;<br>            i--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h2><h3 id="按列遍历"><a href="#按列遍历" class="headerlink" title="按列遍历"></a>按列遍历</h3><p>即外层循环枚举字符串的每一位，内层循环枚举每一个字符串，当遇到不符合条件的就可以直接返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> strs.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strs[<span class="hljs-number">0</span>].length(); i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s0</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span> (String s : strs) &#123;<br>                <span class="hljs-keyword">if</span> (i == s.length() || s.charAt(i) != s0.charAt(i)) &#123;<br>                    <span class="hljs-keyword">return</span> s.substring(<span class="hljs-number">0</span>, i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(1)</li></ul><h2 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/?envType=study-plan-v2&envId=top-interview-150">反转字符串中的单词</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>首先用replaceAll和trim方法去除多余的空格，然后逆转字符串，再按照逐个单词进行翻转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 去除多余空格，并将字符串转换为字符数组</span><br>        s = s.replaceAll(<span class="hljs-string">&quot;\\s+&quot;</span>, <span class="hljs-string">&quot; &quot;</span>).trim();<br>        <span class="hljs-type">char</span>[] charArray = s.toCharArray(); <span class="hljs-comment">// 将字符串转换为字符数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> charArray.length;<br>        <br>        <span class="hljs-comment">// 反转整个字符串</span><br>        reverse(charArray, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-comment">// 按空格进行反转每个单词</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (charArray[end] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                reverse(charArray, start, end - <span class="hljs-number">1</span>);<br>                start = end + <span class="hljs-number">1</span>;<br>            &#125;<br>            end++;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 反转最后一个单词</span><br>        reverse(charArray, start, n - <span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArray); <span class="hljs-comment">// 将字符数组转换回字符串并返回</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] charArray, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-comment">// 交换字符</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> charArray[start];<br>            charArray[start] = charArray[end];<br>            charArray[end] = temp;<br>            start++;<br>            end--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="使用语言特性"><a href="#使用语言特性" class="headerlink" title="使用语言特性"></a>使用语言特性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 去除开头结尾空格</span><br>        s = s.trim();<br>        <span class="hljs-comment">// 正则匹配空格作为分隔符</span><br>        List&lt;String&gt; wordList = Arrays.asList(s.split(<span class="hljs-string">&quot;\\s+&quot;</span>));<br>        <span class="hljs-comment">// 反转</span><br>        Collections.reverse(wordList);<br>        <span class="hljs-comment">// 拼接</span><br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, wordList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>由于双端队列支持从队列头部插入的方法，因此我们可以沿着字符串一个一个单词处理，然后将单词压入队列的头部，再将队列转成字符串即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">// 去除开头结尾空格</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right &gt;= left &amp;&amp; s.charAt(right) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            right--;<br>        &#125;<br>        <span class="hljs-comment">// 定义双端队列</span><br>        Deque&lt;String&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">Character</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(left);<br>            <span class="hljs-keyword">if</span> (word.length() != <span class="hljs-number">0</span> &amp;&amp; ch == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                <span class="hljs-comment">// push到头部</span><br>                que.offerFirst(word.toString());<br>                word.setLength(<span class="hljs-number">0</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                word.append(ch);<br>            &#125;<br>            left++;<br>        &#125;<br>        que.offerFirst(word.toString());<br><br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, que);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="z字形变换"><a href="#z字形变换" class="headerlink" title="z字形变换"></a><a href="https://leetcode.cn/problems/zigzag-conversion/?envType=study-plan-v2&envId=top-interview-150">z字形变换</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>模拟这个行索引的变化，在遍历 s 中把每个字符填到正确的行。</p><ol><li>res[i] +&#x3D; c： 把每个字符 c 填入对应行；</li><li>i +&#x3D; flag： 更新当前字符 c 对应的行索引；</li><li>flag &#x3D; - flag： 在达到 Z 字形转折点时，执行反向。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">convert</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> numRows)</span> &#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span> (numRows &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">// 初始化数组</span><br>        List&lt;StringBuilder&gt; rows = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;StringBuilder&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>            rows.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>());<br>        &#125;<br>        <span class="hljs-comment">// 遍历字符串</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, flag = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            rows.get(r).append(s.charAt(i));<br>            <span class="hljs-comment">// 变向</span><br>            <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span> || r == numRows - <span class="hljs-number">1</span>) &#123;<br>                flag = -flag;<br>            &#125;<br>            <span class="hljs-comment">// 更新row</span><br>            r += flag;<br>        &#125;<br>        <span class="hljs-comment">// 合并结果</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (StringBuilder sb : rows) &#123;<br>            res.append(sb);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="找出字符串中第一个匹配的下标"><a href="#找出字符串中第一个匹配的下标" class="headerlink" title="找出字符串中第一个匹配的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/submissions/?envType=study-plan-v2&envId=top-interview-150">找出字符串中第一个匹配的下标</a></h2><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> haystack.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> needle.length();<br>        <span class="hljs-keyword">if</span> (n &gt; m) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i + n &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (haystack.substring(i, i + n).equals(needle)) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(1)</li></ul><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><ul><li>next[i] 表示在模式串的前 i 个字符中，模式串的前缀和后缀的最大匹配长度（不包括 i 本身）。</li><li>当遇到不匹配的字符时，next 数组决定我们应当将模式串向右移动多少个字符，而不需要从头开始匹配。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-keyword">if</span> (needle.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果needle为空，返回0</span><br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> haystack.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> needle.length();<br>        <br>        <span class="hljs-comment">// next数组，长度为m</span><br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <br>        <span class="hljs-comment">// 计算next数组</span><br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// next[0]始终为0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 模式串指针</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; needle.charAt(i) != needle.charAt(j)) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];  <span class="hljs-comment">// 回退到next[j-1]</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (needle.charAt(i) == needle.charAt(j)) &#123;<br>                j++;<br>            &#125;<br>            next[i] = j;<br>        &#125;<br><br>        <span class="hljs-comment">// 开始匹配</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 文本串指针</span><br>        j = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 模式串指针</span><br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;<br>                i++;<br>                j++;<br>                <span class="hljs-comment">// 如果模式串完全匹配，返回起始位置</span><br>                <span class="hljs-keyword">if</span> (j == m) &#123;<br>                    <span class="hljs-keyword">return</span> i - j;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果匹配失败，根据next数组跳转</span><br>                <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>) &#123;<br>                    j = next[j - <span class="hljs-number">1</span>];  <span class="hljs-comment">// 回溯模式串的指针</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    i++;  <span class="hljs-comment">// 如果j为0，文本串指针前进</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果没有匹配，返回-1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m + n)</li><li>空间复杂度：O(m)，m为模式串的长度。</li></ul><p>KMP不太好想，之后再看看好好理解一下，然后结合马拉车算法一起看一下。</p><h2 id="文本左右对齐"><a href="#文本左右对齐" class="headerlink" title="文本左右对齐"></a><a href="https://leetcode.cn/problems/text-justification/description/?envType=study-plan-v2&envId=top-interview-150">文本左右对齐</a></h2><h3 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h3><ul><li>当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格；</li><li>当前行不是最后一行，且只有一个单词：该单词左对齐，在行末填充空格；</li><li>当前行不是最后一行，且不只一个单词：设当前行单词数为 numWords，空格数为 numSpaces，我们需要将空格均匀分配在单词之间，则单词之间应至少有$\frac{numSpaces}{numWords-1}$个空格。对于多出来的$extraSpaces&#x3D;numSpacesmod(numWords−1)$个空格，应填在前 extraSpaces 个单词之间。因此，前 extraSpaces 个单词之间填充 avgSpaces+1 个空格，其余单词之间填充 avgSpaces 个空格。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">fullJustify</span><span class="hljs-params">(String[] words, <span class="hljs-type">int</span> maxWidth)</span> &#123;<br>        List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 遍历每个单词</span><br>        <span class="hljs-keyword">while</span> (index &lt; words.length) &#123;<br>            <span class="hljs-comment">// lineStart 和 index 标记当前行的起始和结束单词</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">lineStart</span> <span class="hljs-operator">=</span> index;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lineLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>            <span class="hljs-comment">// 每次确定一行能容纳的单词数量</span><br>            <span class="hljs-keyword">while</span> (index &lt; words.length &amp;&amp; lineLength + words[index].length() + (index - lineStart) &lt;= maxWidth) &#123;<br>                lineLength += words[index].length();<br>                index++;<br>            &#125;<br><br>            <span class="hljs-comment">// Build the line</span><br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">numWords</span> <span class="hljs-operator">=</span> index - lineStart;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">totalSpaces</span> <span class="hljs-operator">=</span> maxWidth - lineLength;<br><br>            <span class="hljs-comment">// 特殊处理最后一行或单词只有一个的行</span><br>            <span class="hljs-keyword">if</span> (index == words.length || numWords == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lineStart; i &lt; index; i++) &#123;<br>                    line.append(words[i]);<br>                    <span class="hljs-keyword">if</span> (i &lt; index - <span class="hljs-number">1</span>) &#123;<br>                        line.append(<span class="hljs-string">&quot; &quot;</span>);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">while</span> (line.length() &lt; maxWidth) &#123;<br>                    line.append(<span class="hljs-string">&quot; &quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 常规行的空格分配</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">spacesPerWord</span> <span class="hljs-operator">=</span> totalSpaces / (numWords - <span class="hljs-number">1</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">extraSpaces</span> <span class="hljs-operator">=</span> totalSpaces % (numWords - <span class="hljs-number">1</span>);<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lineStart; i &lt; index; i++) &#123;<br>                    line.append(words[i]);<br>                    <span class="hljs-keyword">if</span> (i &lt; index - <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; spacesPerWord; j++) &#123;<br>                            line.append(<span class="hljs-string">&quot; &quot;</span>);<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (extraSpaces &gt; <span class="hljs-number">0</span>) &#123;<br>                            line.append(<span class="hljs-string">&quot; &quot;</span>);<br>                            extraSpaces--;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            result.add(line.toString());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m)，其中 m 是数组 words 中所有字符串的长度之和。</li><li>空间复杂度：O(m)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>字符串的很多题目并不难，但具体分析起来会有多种情况，每一种思考起来并不容易，只能多做多复习。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 热题 100-技巧</title>
    <link href="/2024/12/23/posts/hot100-16/"/>
    <url>/2024/12/23/posts/hot100-16/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-热题-100-技巧"><a href="#LeetCode-热题-100-技巧" class="headerlink" title="LeetCode 热题 100-技巧"></a>LeetCode 热题 100-技巧</h1><h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a><a href="https://leetcode.cn/problems/single-number/description/?envType=study-plan-v2&envId=top-100-liked">只出现一次的数字</a></h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>两个相同的数字异或结果是0，因此将数组中每个数字进行异或运算，最后得到的数字就是只出现一次的那个数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            ans = ans ^ nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><a href="https://leetcode.cn/problems/majority-element/?envType=study-plan-v2&envId=top-100-liked">多数元素</a></h2><h3 id="Boyer-Moore-投票算法"><a href="#Boyer-Moore-投票算法" class="headerlink" title="Boyer-Moore 投票算法"></a>Boyer-Moore 投票算法</h3><ul><li>若记 众数 的票数为 +1 ，非众数 的票数为 −1 ，则一定有所有数字的 票数和 &gt;0 。</li><li>若数组的前 a 个数字的 票数和 &#x3D;0 ，则 数组剩余 (n−a) 个数字的 票数和一定仍 &gt;0 ，即后 (n−a) 个数字的 众数仍为 x 。</li></ul><ol><li>初始化： 票数统计 votes &#x3D; 0 ， 众数 x。</li><li>循环： 遍历数组 nums 中的每个数字 num 。</li><li>当 票数 votes 等于 0 ，则假设当前数字 num 是众数。</li><li>当 num &#x3D; x 时，票数 votes 自增 1 ；当 num !&#x3D; x 时，票数 votes 自减 1 。</li><li>返回值： 返回 x 即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">votes</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cadidates = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (votes == <span class="hljs-number">0</span>) &#123;<br>                cadidates = nums[i];<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (nums[i] == cadidates) &#123;<br>                votes++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                votes--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cadidates;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a><a href="https://leetcode.cn/problems/sort-colors/?envType=study-plan-v2&envId=top-100-liked">颜色分类</a></h2><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>直观的想法是统计0、1、2的个数，然后再遍历一遍填入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cnt1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>                cnt0++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) &#123;<br>                cnt1++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cnt0; i++) &#123;<br>            nums[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cnt0; i &lt; cnt1 + cnt0; i++) &#123;<br>            nums[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cnt0 + cnt1; i &lt; nums.length; i++) &#123;<br>            nums[i] = <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="三次覆写"><a href="#三次覆写" class="headerlink" title="三次覆写"></a>三次覆写</h3><p>遍历数组： i：代表目前为止(0 + 1 + 2) 的数量：</p><ul><li>n1: 代表目前为止 (0 + 1)的数量</li><li>n0: 代表目前为止 (0)的数量</li></ul><p>一次判断当前数字属于哪一类，然后修改对应的nums[]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cnt1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            nums[i] = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">2</span>) &#123;<br>                nums[cnt1++] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">1</span>) &#123;<br>                nums[cnt0++] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>使用三个指针（p0，p1 和 i）来实现原地排序，核心思想是 一次遍历 数组，利用指针来分别追踪0、1、2应该在的位置。</p><p>遍历数组：</p><ul><li>当 nums[i] &#x3D;&#x3D; 1 时，说明当前元素应该是 1。我们将其与 p1 指向的元素交换，并且将 p1 增加1。</li><li>当 nums[i] &#x3D;&#x3D; 0 时，说明当前元素应该是 0。我们首先将其与 p0 指向的元素交换，然后，如果 p0 &lt; p1，我们需要再交换一次，将 nums[i] 和 nums[p1] 交换，避免在处理 0 的时候，把 1 错放到 0 的位置。然后，我们将 p0 和 p1 都增加1。</li><li>当 nums[i] &#x3D;&#x3D; 2 时，我们什么也不做，只需要继续遍历。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, p1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) &#123;<br>                swap(nums, i, p1);<br>                p1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>                swap(nums, i, p0);<br>                <span class="hljs-comment">// 避免把1错放到0的位置</span><br>                <span class="hljs-keyword">if</span> (p0 &lt; p1) &#123;<br>                    swap(nums, i, p1);<br>                &#125;<br>                p0++;<br>                p1++;<br>            &#125;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[a];<br>        nums[a] = nums[b];<br>        nums[b] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a><a href="https://leetcode.cn/problems/next-permutation/?envType=study-plan-v2&envId=top-100-liked">下一个排列</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li>从后向前 查找第一个 相邻升序 的元素对 (i,j)，满足 A[i] &lt; A[j] (i &lt; j)。此时 [j,end) 必然是降序。</li><li>在 [j,end) 从后向前 查找第一个满足 A[i] &lt; A[k] 的 k。</li><li>将 A[i] 与 A[k] 交换</li><li>可以断定这时 [j,end) 必然是降序，逆置 [j,end)，使其升序</li><li>如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 从后向前 查找第一个 相邻升序 的元素对</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>, j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;<br>            i--;<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 在 [j,end) 从后向前 查找第一个满足 A[i] &lt; A[k] 的 k</span><br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (k &gt;= j &amp;&amp; nums[i] &gt;= nums[k]) &#123;<br>                k--;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>            nums[i] = nums[k];<br>            nums[k] = temp;<br>        &#125;<br><br>        <span class="hljs-comment">// 逆置 [j,end)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> j, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>            nums[left] = nums[right];<br>            nums[right] = temp;<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a><a href="https://leetcode.cn/problems/find-the-duplicate-number/?envType=study-plan-v2&envId=top-100-liked">寻找重复数</a></h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>定义 cnt[i] 表示 nums 数组中小于等于 i 的数有多少个，假设我们重复的数是 target，那么 [1,target−1]里的所有数满足 cnt[i]≤i，[target,n] 里的所有数满足 cnt[i]&gt;i，具有单调性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;    <span class="hljs-comment">// 元素范围是1~n-1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>, ans = -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 二分查找</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 数一下小于等于当前元素的有多少个</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &lt;= mid) &#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 缩小范围区间</span><br>            <span class="hljs-keyword">if</span> (cnt &lt;= mid) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>                ans = mid;  <span class="hljs-comment">// 重复的数字必定在 1 到 mid 之间。为了确保在下一次循环中我们能够找到具体的重复数字，我们将 ans 设置为 mid，并继续缩小查找区间。</span><br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>考虑第 i 位，我们记 nums 数组中二进制展开后第 i 位为 1 的数有 x 个，数字 [1,n] 这 n 个数二进制展开后第 i 位为 1 的数有 y 个，那么重复的数第 i 位为 1 当且仅当 x&gt;y。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 确定二进制最高位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bitNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>;<br>        <span class="hljs-keyword">while</span> (((n - <span class="hljs-number">1</span>) &gt;&gt; bitNum) == <span class="hljs-number">0</span>) &#123;<br>            bitNum--;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 统计每一位的1情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= bitNum; k++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-comment">// 更新x</span><br>                <span class="hljs-keyword">if</span> ((nums[i] &amp; (<span class="hljs-number">1</span> &lt;&lt; k)) != <span class="hljs-number">0</span>) &#123;<br>                    x++;<br>                &#125;<br>                <span class="hljs-comment">// 更新y</span><br>                <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span> &amp;&amp; ((i &amp; (<span class="hljs-number">1</span> &lt;&lt; k)) != <span class="hljs-number">0</span>)) &#123;<br>                    y++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 更新ans</span><br>            <span class="hljs-keyword">if</span> (x &gt; y) &#123;<br>                ans |= (<span class="hljs-number">1</span> &lt;&lt; k);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>对 nums 数组建图，每个位置 i 连一条 i→nums[i] 的边。由于存在的重复的数字 target，因此 target 这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的 target 就是这个环的入口，那么整个问题就等价于环形链表问题。</p><p>先设置慢指针 slow 和快指针 fast ，慢指针每次走一步，快指针每次走两步，根据「Floyd 判圈算法」两个指针在有环的情况下一定会相遇，此时我们再将 slow 放置起点 0，两个指针每次同时移动一步，相遇的点就是答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 快慢指针</span><br>        <span class="hljs-keyword">do</span>&#123;<br>            slow = nums[slow];<br>            fast = nums[nums[fast]];<br>        &#125; <span class="hljs-keyword">while</span> (slow != fast);<br>        <span class="hljs-comment">// 快慢指针相遇,重置慢指针</span><br>        slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>            slow = nums[slow];<br>            fast = nums[fast];<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>技巧类的题目很难想，只能多做，多积累。至此hot100的题目都做完了，其实大部分题目之前都做过，甚至做过好几遍，但是再做时可能还是理不清思路，要多复习。明天开始做hot150，但是这次不再追求每天做多少题目了，主要是对hot100里没做过的题目做一下，然后复习已经做过的，保证做过的题目一定弄透彻。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 热题 100-动态规划</title>
    <link href="/2024/12/19/posts/hot100-15/"/>
    <url>/2024/12/19/posts/hot100-15/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-热题-100-动态规划"><a href="#LeetCode-热题-100-动态规划" class="headerlink" title="LeetCode 热题 100-动态规划"></a>LeetCode 热题 100-动态规划</h1><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/?envType=study-plan-v2&envId=top-100-liked">爬楼梯</a></h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>f(n) &#x3D; f(n-1) + f(n-2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">f0</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> f0 + f1;<br>            f0 = f1;<br>            f1 = f2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>思考题</p><ol><li>如果每次可以爬 1 或 2 或 3 个台阶呢？空间优化的写法要怎么做？<ul><li>定义三个变量：f0 &#x3D; 1, f1 &#x3D; 1, f2 &#x3D; 2；</li><li>从i&#x3D;3开始计算，f3 &#x3D; f0 + f1 + f2。</li></ul></li><li>如果某些台阶不能爬呢？（输入一个数组表示不能爬的台阶编号）<ul><li>如果当前台阶不能爬，即blocked.containsKey(i)，就将当前爬法置为0。</li></ul></li></ol><h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a><a href="https://leetcode.cn/problems/pascals-triangle?envType=study-plan-v2&envId=top-100-liked">杨辉三角</a></h2><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>定义状态：dp[i][j]表示第i行第j列的数字，第i行有i+1列。</li><li>状态转移：<ul><li>当j &gt; 0且j &lt; n-1时，dp[i][j] &#x3D; dp[i-1][j-1] + dp[i-1][j]；</li><li>当j &#x3D;&#x3D; 0，dp[i][j] &#x3D; dp[i-1][j]；</li><li>当j &#x3D;&#x3D; n-1，dp[i][j] &#x3D; dp[i-1][j-1]；</li></ul></li><li>初始条件：dp[0][0] &#x3D; 1.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> numRows)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(numRows);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>            List&lt;Integer&gt; row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(i + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 每一行第一个元素一定是1</span><br>            row.add(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>                row.add(dp.get(i-<span class="hljs-number">1</span>).get(j-<span class="hljs-number">1</span>) + dp.get(i-<span class="hljs-number">1</span>).get(j));<br>            &#125;<br>            <span class="hljs-comment">// 每一行最后一个元素也是1</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>)&#123;<br>                row.add(<span class="hljs-number">1</span>);<br>            &#125;<br>            <br>            dp.add(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(1)，返回值不计入。</li></ul><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/?envType=study-plan-v2&envId=top-100-liked">打家劫舍</a></h2><h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>定义状态：dp[i]表示当前能够偷盗的最大金额。</li><li>状态转移：dp[i] &#x3D; max(dp[i-1], dp[i-2] + nums[i])。</li><li>初始条件：dp[0] &#x3D; nums[0]。</li><li>返回结果：dp[n-1]。</li><li>空间优化：用两个变量记录dp[i-1]和dp[i-2].</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">f0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> Math.max(f0 + nums[i], f1);<br>            f0 = f1;<br>            f1 = f2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍II</a></h2><h2 id="打家劫舍III"><a href="#打家劫舍III" class="headerlink" title="打家劫舍III"></a><a href="https://leetcode.cn/problems/house-robber-iii/">打家劫舍III</a></h2><h2 id="打家劫舍IV"><a href="#打家劫舍IV" class="headerlink" title="打家劫舍IV"></a><a href="https://leetcode.cn/problems/house-robber-iv/">打家劫舍IV</a></h2><h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/?envType=study-plan-v2&envId=top-100-liked">完全平方数</a></h2><h3 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h3><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p><ol><li>定义状态：f[i] 表示最少需要多少个数的平方来表示整数 i。</li><li>状态转移：枚举，从1到j*j &lt;&#x3D; i的所有j，不断更新找到使用完全平方数最少的。</li><li>初始条件f[0] &#x3D; 0.</li><li>返回结果f[n]。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">minn</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-comment">// 枚举完全平方数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j * j &lt;= i; j++) &#123;<br>                minn = Math.min(minn, f[i - j * j]);<br>            &#125;<br>            f[i] = minn + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \sqrt{n})$</li><li>空间复杂度：O(n)</li></ul><p>爬楼梯和完全平方数都有一些数学方法可以解决，有时间在看，这里主要复习动态规划的思想。</p><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&envId=top-100-liked">零钱兑换</a></h2><h3 id="动态规划-4"><a href="#动态规划-4" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>定义状态：dp[i]表示凑成金额为i需要的最少硬币个数。</li><li>状态转移：枚举硬币面值，<code>dp[i] = min(dp[i], dp[i-num] + 1)</code>。</li><li>初始条件：<code>dp[i] = amount + 1</code>,dp[0] &#x3D; 0.</li><li>返回结果：dp[n]</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> amount + <span class="hljs-number">1</span>;<br>        Arrays.fill(dp, max);<br>        <span class="hljs-comment">// 枚举硬币</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : coins) &#123;<br>            <span class="hljs-comment">// 枚举金额</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> num; i &lt;= amount; i++) &#123;<br>                dp[i] = Math.min(dp[i], dp[i-num] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> dp[amount] == max ? -<span class="hljs-number">1</span> : dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \cdot amount)$</li><li>空间复杂度：O(amount)</li></ul><p>也可以把枚举金额放在外套循环，但是就需要在循环中判断硬币的面值是否比需要凑成的金额小。</p><h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a href="https://leetcode.cn/problems/word-break/?envType=study-plan-v2&envId=top-100-liked">单词拆分</a></h2><h3 id="动态规划-5"><a href="#动态规划-5" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>定义状态：dp[i]表示前i个字符能否用列表中的单词表示。</li><li>状态转移：如果s[0:j]可以拆分，即dp[j]&#x3D;true，并且s[j:i]出现在字典中，则dp[i] &#x3D; true。如果s[0:j]不可以拆分，或者s[j:i]没有出现在字典中，则dp[i] &#x3D; false。</li><li>初始条件：长度为0的字符串可以拆分为单词，dp[0] &#x3D; true。</li><li>返回结果dp[n]。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 将单词存入哈希表以便用O(1)时间查找</span><br>        HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordDict);<br><br>        <span class="hljs-comment">// 填表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">// 枚举切分位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123;<br>                    dp[i] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n ^ 2)$，一共有 O(n) 个状态需要计算，每次计算需要枚举 O(n) 个分割点，哈希表判断一个字符串是否出现在给定的字符串列表需要 O(1) 的时间。</li><li>空间复杂度：O(n)</li></ul><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-100-liked">最长递增子序列</a></h2><h3 id="动态规划-6"><a href="#动态规划-6" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>定义状态：dp[i]表示以nums[i]为结尾的最长递增子序列长度。</li><li>状态转移：枚举j，如果nums[i] &gt; nums[j]，则更新状态<code>dp[i] = max(dp[i], dp[j] + 1)</code>。</li><li>初始条件：dp[i] &#x3D; 1，以nums[i]结尾的子序列初始长度是1.</li><li>返回结果：维护一个最大值变量，返回它。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 枚举数字</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 枚举上一个序列位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<br>                    dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 更新答案变量</span><br>            ans = Math.max(ans, dp[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(n)</li></ul><h3 id="贪心-二分查找"><a href="#贪心-二分查找" class="headerlink" title="贪心+二分查找"></a>贪心+二分查找</h3><p>可以进一步优化时间复杂度：如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</p><ul><li>维护一个数组 d[i] ，表示长度为 i 的最长上升子序列的末尾元素的最小值，用 len 记录目前最长上升子序列的长度，起始时 len 为 1，d[1]&#x3D;nums[0]。</li><li>从前往后遍历数组 nums，在遍历到 nums[i] 时：<ul><li>如果 nums[i]&gt;d[len] ，则直接加入到 d 数组末尾，并更新 len&#x3D;len+1；</li><li>否则，在 d 数组中二分查找，找到第一个比 nums[i] 小的数 d[k] ，并更新 d[k+1]&#x3D;nums[i]。如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1].</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 定义数组d并初始化</span><br>        <span class="hljs-type">int</span>[] d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];   <span class="hljs-comment">// 因为len最多是n</span><br>        d[len] = nums[<span class="hljs-number">0</span>];           <span class="hljs-comment">// 长度为1的子序列最小的末尾元素初始化为nums[0]</span><br>        <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 如果当前数字比末尾元素大，说明序列可以加长</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; d[len])&#123;<br>                d[++len] = nums[i];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 否则进行二分查找，找到该更新的位置</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, right = len, pos = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span> (d[mid] &lt; nums[i]) &#123;<br>                    pos = mid;  <span class="hljs-comment">// nums[i] 可以替代位置mid+1位置上的元素</span><br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            d[pos + <span class="hljs-number">1</span>] = nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：O(n)</li></ul><h2 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a><a href="https://leetcode.cn/problems/maximum-product-subarray?envType=study-plan-v2&envId=top-100-liked">乘积最大子数组</a></h2><h3 id="动态规划-7"><a href="#动态规划-7" class="headerlink" title="动态规划"></a>动态规划</h3><p>不满足最优子结构，考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。因此维护两个数组，一个记录最大值，一个记录最小值。如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。</p><ol><li>定义状态：fmax[i]表示以nums[i]为结尾的连续子数组的最大值，fmin[i]为最小值。</li><li>状态转移：<ul><li>fmax &#x3D; max(fmax[i-1] * nums[i], fmin[i-1] * nums[i], nums[i])</li><li>fmin &#x3D; min(fmin[i-1] * nums[i], fmax[i-1] * nums[i], nums[i])</li></ul></li><li>初始条件：fmax[0] &#x3D; fmin[0] &#x3D; nums[0]。</li><li>返回结果：维护一个最大值变量。</li><li>空间优化：可以用两个变量代替fmax[i-1]和fmin[i-1].</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fmin</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fmax</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> fmax;<br>        <span class="hljs-comment">// 状态转移</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 更新状态</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmin</span> <span class="hljs-operator">=</span> Math.min(fmin * nums[i], Math.min(fmax * nums[i], nums[i]));<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmax</span> <span class="hljs-operator">=</span> Math.max(fmax * nums[i], Math.max(fmin * nums[i], nums[i]));<br>            fmin = tmin;<br>            fmax = tmax;<br>            ans = Math.max(ans, fmax);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum?envType=study-plan-v2&envId=top-100-liked">分割等和子集</a></h2><h3 id="动态规划-8"><a href="#动态规划-8" class="headerlink" title="动态规划"></a>动态规划</h3><p>首先计算数组中所有数字之和sum，如果它是奇数，说明无法分割。否则可以转化成背包问题，即target &#x3D; sum &#x2F; 2，物品重量就是数字，如果能够找到物品使其累加之和等于sum&#x2F;2，则说明可以分割，否则无法分割。</p><ol><li>定义状态：dp包含 n 行 target+1 列，其中 dp[i][j] 表示从数组的 [0,i] 下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于 j。</li><li>状态转移：外层循环枚举物品重量，内层循环枚举和：<ul><li>如果j &gt;&#x3D; nums[i]，可以选取也可以不选取，两种情况只要有一个为 true，就有 dp[i][j]&#x3D;true。</li><li>否则，dp[i][j] &#x3D; dp[i-1][j]。</li></ul></li><li>初始条件：初始时，dp 中的全部元素都是 false。如果不选取任何正整数，则被选取的正整数之和等于 0。因此对于所有 0≤i&lt;n，都有 dp[i][0]&#x3D;true。当 i&#x3D;&#x3D;0 时，只有一个正整数 nums[0] 可以被选取，因此 dp[0][nums[0]]&#x3D;true。</li><li>返回结果：dp[n-1][target]。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 计算和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][target + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 目标为0可以凑成</span><br>            <span class="hljs-comment">// 还有一种情况无法凑成，即某个元素大于target</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <br>        dp[<span class="hljs-number">0</span>][nums[<span class="hljs-number">0</span>]] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 第0个物品可以</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= target; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= nums[i]) &#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] | dp[i-<span class="hljs-number">1</span>][j- nums[i]];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \cdot target)$</li><li>空间复杂度：$O(n \cdot target)$</li></ul><p>空间优化：</p><p>在计算 dp 的过程中，每一行的 dp 值都只与上一行的 dp 值有关，因此只需要一个一维数组即可将空间复杂度降到 O(target)。</p><p>此时状态转移方程为：dp[j]&#x3D;dp[j] ∣ dp[j−nums[i]]。第二层的循环我们需要从大到小计算，因为如果我们从小到大更新 dp 值，那么在计算 dp[j] 值的时候，dp[j−nums[i]] 已经是被更新过的状态，不再是上一行的 dp 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 计算和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxNum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            sum += nums[i];<br>            maxNum = Math.max(maxNum, nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (maxNum &gt; target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[target + <span class="hljs-number">1</span>];<br>        <br>        dp[nums[<span class="hljs-number">0</span>]] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 第0个物品可以</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= nums[i]) &#123;<br>                    dp[j] = dp[j] | dp[j- nums[i]];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[j] = dp[j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \cdot target)$</li><li>空间复杂度：O(target)</li></ul><h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a><a href="https://leetcode.cn/problems/longest-valid-parentheses/?envType=study-plan-v2&envId=top-100-liked">最长有效括号</a></h2><h3 id="动态规划-9"><a href="#动态规划-9" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>定义状态：dp[i]表示以字符s[i]为结尾的最长有效子串长度。</li><li>状态转移：<ul><li>如果<code>s[i] == &#39;(&#39;</code>，则以s[i]为结尾的字符串不可能是有效括号子串，dp[i] &#x3D; 0。</li><li>如果<code>s[i] == &#39;)&#39;</code>，需要考虑 s[i - 1] 来判断是否能够构成有效括号对：<ul><li>如果<code>s[i-1] == &#39;(&#39;</code>，则<code>dp[i] = dp[i-1] + 2</code></li><li>如果<code>s[i-1] == &#39;)&#39;</code>，则我们需要看 i - 1 - dp[i - 1] 位置上的字符 s[i - 1 - dp[i - 1]]是否与 s[i] 匹配:<ul><li>如果是右括号，那就不匹配。</li><li>如果是左括号，则匹配，那么需要看以 s[i - 1 - dp[i - 1]] 的前一个字符 s[i - 2 - dp[i - 1]] 为结尾的最长括号长度是多少，即<code>dp[i] = dp[i-1] + dp[i-2-dp[i-1]] + 2</code>，如果<code>i-2-dp[i-1] &lt; 0</code>，<code>即不存在，那么</code>dp[i] &#x3D; dp[i-1] + 2&#96;。</li></ul></li></ul></li></ul></li><li>初始条件：dp[0] &#x3D; 0，一个字符无法构成有效的括号。</li><li>发你结果：维护一个最大值变量。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 状态转移</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-comment">// 如果是右括号，则需要更新状态</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 如果前一个字符是左括号，直接匹配</span><br>                <span class="hljs-keyword">if</span> (s.charAt(i-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i &lt; <span class="hljs-number">2</span> ? <span class="hljs-number">0</span> : dp[i-<span class="hljs-number">2</span>]) + <span class="hljs-number">2</span>;<br>                &#125; <br>                <span class="hljs-comment">// 需要看 i - 1 - dp[i - 1] 位置上的字符是否匹配</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i-<span class="hljs-number">1</span>-dp[i-<span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i-<span class="hljs-number">1</span>-dp[i-<span class="hljs-number">1</span>]) == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                    dp[i] = dp[i-<span class="hljs-number">1</span>] + (i - <span class="hljs-number">2</span> - dp[i-<span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span> ? dp[i-<span class="hljs-number">2</span>-dp[i-<span class="hljs-number">1</span>]] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125;<br>                ans = Math.max(ans, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」。</p><ul><li>初始化栈，放入-1。</li><li>如果是左括号，就把其下标入栈。</li><li>如果是右括号：<ul><li>如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」</li><li>如果不为空，说明有匹配的括号，出栈，然后可以更新最大长度ans &#x3D; max(ans, i - 栈顶下标)。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 定义栈并初始化</span><br>        Deque&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        stk.push(-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 遍历元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 左括号入栈</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                stk.push(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 出栈</span><br>                stk.pop();<br>                <span class="hljs-keyword">if</span> (stk.isEmpty()) &#123;<br>                    <span class="hljs-comment">// 栈为空，将当前右括号作为最后一个未匹配的</span><br>                    stk.push(i);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 更新最大长度</span><br>                    ans = Math.max(ans, i - stk.peek());<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="不需要额外空间"><a href="#不需要额外空间" class="headerlink" title="不需要额外空间"></a>不需要额外空间</h3><p>利用两个计数器 left 和 right 。首先，我们从左到右遍历字符串，对于遇到的每个 ‘(’，我们增加 left 计数器，对于遇到的每个 ‘)’ ，我们增加 right 计数器。每当 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。当 right 计数器比 left 计数器大时，我们将 left 和 right 计数器同时变回 0。</p><p>这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的。</p><p>只需要从右往左遍历用类似的方法计算即可，只是这个时候判断条件反了过来：</p><ul><li>当 left 计数器比 right 计数器大时，我们将 left 和 right 计数器同时变回 0</li><li>当 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 从左到右</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right++;<br>            &#125;<br>            <span class="hljs-comment">// 更新计数器</span><br>            <span class="hljs-keyword">if</span> (left == right) &#123;<br>                ans = Math.max(ans, left + right);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right &gt; left) &#123;<br>                left = <span class="hljs-number">0</span>;<br>                right = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 从右到左</span><br>        left = right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right++;<br>            &#125;<br>            <span class="hljs-comment">// 更新计数器</span><br>            <span class="hljs-keyword">if</span> (left == right) &#123;<br>                ans = Math.max(ans, left + right);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>                left = <span class="hljs-number">0</span>;<br>                right = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/?envType=study-plan-v2&envId=top-100-liked">不同路径</a></h2><h3 id="动态规划-10"><a href="#动态规划-10" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>定义状态：dp[i][j]表示当前位置有多少条不同的路径。</li><li>状态转移：<code>dp[i][j] = dp[i-1][j] + dp[j-1][i]</code>。</li><li>初始条件：dp[0][j] &#x3D; 1. dp[i][0] &#x3D; 1.</li><li>返回结果：dp[m-1][n-1]</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 定义状态并初始化</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 状态转移</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>由于 f(i,j) 仅与第 i 行和第 i−1 行的状态有关，因此我们可以使用滚动数组代替代码中的二维数组，使空间复杂度降低为 O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 定义状态并初始化</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 状态转移</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[j] += dp[j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(1)</li></ul><h3 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h3><p>从左上角到右下角的过程中，我们需要移动 m+n−2 次，其中有 m−1 次向下移动，n−1 次向右移动。因此路径的总数，就等于从 m+n−2 次移动中选择 m−1 次向下移动的方案数，即组合数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> n, y = <span class="hljs-number">1</span>; y &lt; m; x++, y++) &#123;<br>            ans = ans * x / y;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m)</li><li>空间复杂度：O(1)</li></ul><h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/?envType=study-plan-v2&envId=top-100-liked">最小路径和</a></h2><h3 id="动态规划-11"><a href="#动态规划-11" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>定义状态：dp[i][j]表示走到i,j位置的最小路径和。</li><li>状态转移：<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1])</code>。</li><li>初始条件：dp[0][0] &#x3D; grid[0][0]</li><li>返回结果：dp[m-1][n-1]</li><li>空间优化：只与上一行有关，可以用滚动数组。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [n];<br>        dp[<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][i];<br>        &#125; <br>        <span class="hljs-comment">// 状态转移</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            dp[<span class="hljs-number">0</span>] += grid[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[j] = Math.min(dp[j], dp[j-<span class="hljs-number">1</span>]) + grid[i][j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(n)</li></ul><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/?envType=study-plan-v2&envId=top-100-liked">最长回文子串</a></h2><h3 id="动态规划-12"><a href="#动态规划-12" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>定义状态：dp[i][j]表示s[i:j]是否是回文的。</li><li>状态转移：$s[i] &#x3D; s[j], dp[i][j] &#x3D; \begin{cases} true &amp; j-i \leq 2 \cr dp[i+1][j - 1] &amp; else \end{cases}$</li><li>初始条件：dp[i][j] &#x3D; false.</li><li>返回结果：维护一个最大长度变量和起始点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxStart</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxLen = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-comment">// 枚举结束位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">// 枚举起始位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>                <span class="hljs-comment">// 更新状态</span><br>                <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                    dp[i][j] = j - i &lt;= <span class="hljs-number">2</span> ? <span class="hljs-literal">true</span> : dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLen) &#123;<br>                        maxLen = j - i + <span class="hljs-number">1</span>;<br>                        maxStart = i;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(maxStart, maxStart + maxLen);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n^2)$</li></ul><h3 id="中心扩散法"><a href="#中心扩散法" class="headerlink" title="中心扩散法"></a>中心扩散法</h3><p>从每一个位置出发，向两边扩散即可。遇到不是回文的时候结束。</p><ol><li>首先往左寻找与当期位置相同的字符，直到遇到不相等为止。</li><li>然后往右寻找与当期位置相同的字符，直到遇到不相等为止。</li><li>最后左右双向扩散，直到左和右不相等。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxStart</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 枚举每个中心位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-comment">// 定义左右指针</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>, right = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 向左扩展</span><br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(left) == s.charAt(i)) &#123;<br>                left--;<br>            &#125;<br>            <span class="hljs-comment">// 向右扩展</span><br>            <span class="hljs-keyword">while</span> (right &lt; n &amp;&amp; s.charAt(right) == s.charAt(i)) &#123;<br>                right++;<br>            &#125;<br>            <span class="hljs-comment">// 向两边扩展</span><br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; n &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>                left--;<br>                right++;<br>            &#125;<br>            <span class="hljs-comment">// 更新状态</span><br>            <span class="hljs-keyword">if</span> (right - left - <span class="hljs-number">1</span> &gt; maxLen) &#123;<br>                maxLen = right - left - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 因为此时left和right都更新到了</span><br>                maxStart = left + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(maxStart, maxStart + maxLen);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(1)</li></ul><h3 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h3><ol><li>预处理字符串：为了统一奇数长度和偶数长度的回文子串，使用特殊字符（如 #）在字符串之间插入。例如，字符串 “aba” 被处理为 “#a#b#a#”。</li><li>回文半径数组：定义一个数组 p，其中 p[i] 表示以 i 为中心的回文子串的半径（包括中心）。</li><li>中心扩展和边界：使用两个变量 center 和 right 分别记录当前扩展的回文子串的中心和右边界。<ul><li>如果 i 在 right 范围内，则可以利用对称性确定初始半径。</li><li>否则，通过尝试扩展来更新半径。</li></ul></li><li>扩展优化：在每次尝试扩展时，更新 center 和 right。</li><li>结果提取：遍历 p 数组，找到最大半径值及其对应的位置，从而提取最长回文子串。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 预处理字符串</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        sb.append(<span class="hljs-string">&quot;#&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            sb.append(c);<br>            sb.append(<span class="hljs-string">&quot;#&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> sb.toString();      <br><br>        <span class="hljs-comment">// 回文数组p</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br>        <span class="hljs-comment">// 中心扩展和边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">center</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, maxIndex = <span class="hljs-number">0</span>, maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-comment">// 利用对称性初始化 p[i]</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mirror</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * center - i;<br>            <span class="hljs-keyword">if</span> (i &lt; right) &#123;<br>                p[i] = Math.min(right - i, p[mirror]);<br>            &#125;<br>            <span class="hljs-comment">// 尝试扩展来更新半径</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> i - p[i] - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> i + p[i] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; b &lt; n &amp;&amp; t.charAt(a) == t.charAt(b))&#123;<br>                p[i]++;<br>                a--;<br>                b++;<br>            &#125;<br>            <span class="hljs-comment">// 在每次尝试扩展时，更新 center 和 right</span><br>            <span class="hljs-keyword">if</span> (i + p[i] &gt; right) &#123;<br>                center = i;<br>                right = i + p[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (p[i] &gt; maxLen) &#123;<br>                maxIndex = i;<br>                maxLen = p[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 提取原字符串中的最长回文子串</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> (maxIndex - maxLen) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> s.substring(start, start + maxLen);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/?envType=study-plan-v2&envId=top-100-liked">最长公共子序列</a></h2><h3 id="动态规划-13"><a href="#动态规划-13" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>定义状态：：dp[i-1][j-1]等于以text1前i个字符和text2以前j个字符的子序列长度。</li><li>状态转移：<ul><li>如果<code>text1[i] == text2[j]</code>，<code>dp[i][j] = dp[i-1][j-1] + 1</code></li><li>否则，<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code></li></ul></li><li>初始条件：dp[i][0] &#x3D; dp[0][j] &#x3D; 0；</li><li>返回结果：dp[m][n]</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> text1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> text2.length();<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 状态转移</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (text1.charAt(i-<span class="hljs-number">1</span>) == text2.charAt(j-<span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/?envType=study-plan-v2&envId=top-100-liked">编辑距离</a></h2><h3 id="动态规划-14"><a href="#动态规划-14" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>定义状态：dp[i][j]表示将word1的前i个字符转换成word2的前j个字符所需要的最少操作数。</li><li>状态转移：如果<code>word1[i-1] ！= word2[j-1]</code>，<ul><li>插入：dp[i-1][j] + 1</li><li>删除：dp[i][j-1] + 1</li><li>替换：dp[i-1][j-1] + 1</li><li>三种情况取最小值</li></ul></li><li>初始条件：dp[0][0] &#x3D; 0，无需操作，dp[0][j] &#x3D; j，dp[i][0] &#x3D; i。</li><li>返回结果：dp[m][n]</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word2.length();<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br>        <span class="hljs-comment">// 状态转移</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1.charAt(i-<span class="hljs-number">1</span>) == word2.charAt(j-<span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = Math.min(Math.min(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]), dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>                <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 热题 100-贪心算法</title>
    <link href="/2024/12/17/posts/hot100-14/"/>
    <url>/2024/12/17/posts/hot100-14/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-热题-100-贪心算法"><a href="#LeetCode-热题-100-贪心算法" class="headerlink" title="LeetCode 热题 100-贪心算法"></a>LeetCode 热题 100-贪心算法</h1><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&envId=top-100-liked">买卖股票的最佳时机</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>从左到右枚举价格，维护一个它左边元素的最小值的变量，再维护一个答案变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minPrice</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 枚举所有价格</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> price : prices) &#123;<br>            ans = Math.max(ans, price - minPrice);<br>            minPrice = Math.min(minPrice, price);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机II</a></h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>与上一题的区别是，现在可以购买多支股票，但每天只能持有一支股票。</p><ol><li>定义状态 dp[i][0] 表示第 i 天交易完后手里没有股票的最大利润，dp[i][1] 表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。</li><li>状态转移方程：<ul><li>dp[i][0]：第i天结束后手里没有股票，即可能前一天就没有股票dp[i-1][0]，或者前一天持有股票但是今天出售了，得到利润dp[i-1][1] + prices[i]。两种情况取较大值。</li><li>dp[i][1]：第i天结束后手里持有股票，即可能前一天没有但今天买入dp[i-1][0]-prices[i]，或者前一天就持有股票dp[i-1][1]，两者取较大值。</li></ul></li><li>初始条件：dp[0][0] &#x3D; 0，dp[0][1] &#x3D; -prices[0]。</li><li>返回结果：dp[n-1][0]，因为全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候 dp[n−1][0] 的收益必然是大于 dp[n−1][1] 的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 状态转移</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 第i天没有股票</span><br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>            <span class="hljs-comment">// 第i天持有股票</span><br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>空间优化：可以用两个变量保存前一天没有股票和持有股票的价格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dp0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dp1</span> <span class="hljs-operator">=</span> -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 状态转移</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 第i天没有股票</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">newDp0</span> <span class="hljs-operator">=</span> Math.max(dp0, dp1 + prices[i]);<br>            <span class="hljs-comment">// 第i天持有股票</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">newDp1</span> <span class="hljs-operator">=</span> Math.max(dp1, dp0 - prices[i]);<br>            dp0 = newDp0;<br>            dp1 = newDp1;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dp0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>只要是上升趋势的都买，就能使利益最大化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            ans += Math.max(<span class="hljs-number">0</span>, prices[i] - prices[i-<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="买卖股票的最佳时机III"><a href="#买卖股票的最佳时机III" class="headerlink" title="买卖股票的最佳时机III"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机III</a></h2><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>定义状态：buy1、sell1、buy2、sell2</li><li>状态转移<ul><li>buy1 &#x3D; max(buy1, -prices[i])；</li><li>sell1 &#x3D; max(sell1, buy1 + prices[i])；</li><li>buy2 &#x3D; max(buy2, sell1 - prices[i]);</li><li>sell2 &#x3D; max(sell2, buy2 + prices[i]);</li></ul></li><li>初始条件：<ul><li>buy1 &#x3D; -prices[0]</li><li>sell1 &#x3D; 0  表示同一天买入又卖出</li><li>buy2 &#x3D; -prices[0] 表示同一天买入又卖出又买入</li><li>sell2 &#x3D; 0  表示同一天买入又卖出又买入又卖出</li></ul></li><li>返回结果：max(0, sell1, sell2)，如果最优的情况对应的是恰好一笔交易，那么它也会因为我们在转移时允许在同一天买入并且卖出这一宽松的条件，从 sell1转移至sell2，因此最终返回sell2即可。</li></ol><p>状态更新解释：buy1 是独立的，它记录的是从开始到当前这一天中最低的买入价格。<br>sell1 的更新是基于 buy1 来计算的，即在历史上最佳买入价格的基础上，计算当前卖出的最大利润。这两者在更新时互不冲突，buy1 和 sell1 是 逐步推进 的，因此可以顺序更新 buy1 后再更新 sell1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">buy1</span> <span class="hljs-operator">=</span> -prices[<span class="hljs-number">0</span>], sell1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">buy2</span> <span class="hljs-operator">=</span> -prices[<span class="hljs-number">0</span>], sell2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 枚举价格</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            buy1 = Math.max(buy1, -prices[i]);<br>            sell1 = Math.max(sell1, buy1 + prices[i]);<br>            buy2 = Math.max(buy2, sell1 - prices[i]);<br>            sell2 = Math.max(sell2, buy2 + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sell2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="买卖股票的最佳时机IV"><a href="#买卖股票的最佳时机IV" class="headerlink" title="买卖股票的最佳时机IV"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">买卖股票的最佳时机IV</a></h2><h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><p>利用上一题的思路：</p><ol><li>定义状态：dp[j][0]表示第j次交易后不持有股票的最大利润，dp[j][1]表示第j次交易后持有股票的最大利润。</li><li>状态转移：注意，j从后向前遍历，可以避免覆盖上一轮的状态。<ul><li>dp[j][0] &#x3D; max(dp[j-1][0], dp[j-1][1] + prices[i])</li><li>dp[j][1] &#x3D; max(dp[j-1][1], dp[j-1][0] - prices[i])</li></ul></li><li>初始条件：dp[j][0] &#x3D; 0，dp[j][1] &#x3D;负无穷.</li><li>返回结果：dp[k][0]。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <br>        <span class="hljs-comment">// dp[j][0] 表示进行 j 次交易后，不持有股票的最大利润</span><br>        <span class="hljs-comment">// dp[j][1] 表示进行 j 次交易后，持有股票的最大利润</span><br>        k = Math.min(k, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>        <br>        <span class="hljs-comment">// 初始化：进行 0 次交易时，不持有股票最大利润为 0，持有股票的最大利润为负无穷</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= k; j++) &#123;<br>            dp[j][<span class="hljs-number">1</span>] = Integer.MIN_VALUE; <span class="hljs-comment">// 初始化持有股票的最大利润为负无穷</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> k; j &gt; <span class="hljs-number">0</span>; j--) &#123;<br>                dp[j][<span class="hljs-number">0</span>] = Math.max(dp[j][<span class="hljs-number">0</span>], dp[j][<span class="hljs-number">1</span>] + prices[i]); <span class="hljs-comment">// 不持有股票时的最大利润</span><br>                dp[j][<span class="hljs-number">1</span>] = Math.max(dp[j][<span class="hljs-number">1</span>], dp[j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]); <span class="hljs-comment">// 持有股票时的最大利润</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dp[k][<span class="hljs-number">0</span>]; <span class="hljs-comment">// 返回最大利润，即进行 k 次交易后，不持有股票的最大利润</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \cdot min(n,k))$</li><li>空间复杂度：$O(min(n,k))$</li></ul><h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/?envType=study-plan-v2&envId=top-100-liked">跳跃游戏</a></h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><ol><li>从左到右遍历 nums，同时维护能跳到的最远位置 mx，初始值为 0。</li><li>如果 i&gt;mx，说明无法跳到 i，返回 false。</li><li>否则，用 i+nums[i]更新 mx 的最大值。</li><li>如果循环中没有返回 false，那么最后返回 true。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; mx) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            mx = Math.max(mx, i + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>也可以在,x &gt;&#x3D; n-1时直接返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; mx &lt; n-<span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; mx) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            mx = Math.max(mx, i + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a><a href="https://leetcode.cn/problems/jump-game-ii/?envType=study-plan-v2&envId=top-100-liked">跳跃游戏II</a></h2><h3 id="反向查找出发位置"><a href="#反向查找出发位置" class="headerlink" title="反向查找出发位置"></a>反向查找出发位置</h3><p>我们的目标是到达数组的最后一个位置，因此我们可以考虑最后一步跳跃前所在的位置，该位置通过跳跃能够到达最后一个位置。</p><p>如果有多个位置通过跳跃都能够到达最后一个位置，那么我们应该如何进行选择呢？直观上来看，我们可以「贪心」地选择距离最后一个位置最远的那个位置，也就是对应下标最小的那个位置。因此，我们可以从左到右遍历数组，选择第一个满足要求的位置。</p><p>找到最后一步跳跃前所在的位置之后，我们继续贪心地寻找倒数第二步跳跃前所在的位置，以此类推，直到找到数组的开始位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 初始化位置为最后一个元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">steps</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 跳跃步数</span><br>        <span class="hljs-comment">// 反向查找</span><br>        <span class="hljs-keyword">while</span> (pos &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pos; i++) &#123;<br>                <span class="hljs-comment">// 找到可以到达pos的最远节点</span><br>                <span class="hljs-keyword">if</span> (i + nums[i] &gt;= pos) &#123;<br>                    pos = i;<br>                    steps++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> steps;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(1)</li></ul><h3 id="正向查找可到达的最大位置"><a href="#正向查找可到达的最大位置" class="headerlink" title="正向查找可到达的最大位置"></a>正向查找可到达的最大位置</h3><p>对于每一个位置i来说，所有能跳到的位置都可以作为下一个起跳点。为了尽可能使用少的跳跃次数，就应该使得下一次起跳能达到的位置尽可能远。即每次在可跳范围内选择可以使下一次跳的更远的位置：</p><ol><li>维护变量：当前所能达到的最远位置curRight，下一步所能跳到的最远位置nextRight，最少跳跃次数steps。</li><li>遍历数组，每次更新第i个位置下一步所能跳到的最远位置nextRight。</li><li>如果索引i到达了当前所能达到的最远位置curRight，就让步数+1，并更新当前最远到达的位置为nextRight.</li><li>返回跳跃次数。</li><li>注意只需要遍历到i&#x3D;n-2，不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curRight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, nextRight = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">steps</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-comment">// 更新下一跳最远位置</span><br>            nextRight = Math.max(nextRight, i + nums[i]);<br>            <span class="hljs-comment">// 更新跳跃次数</span><br>            <span class="hljs-keyword">if</span> (i == curRight) &#123;<br>                steps++;<br>                curRight = nextRight;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> steps;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a><a href="https://leetcode.cn/problems/partition-labels/?envType=study-plan-v2&envId=top-100-liked">划分字母区间</a></h2><h3 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h3><p>要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p><ol><li>遍历字符串，得到每个字母最后一次出现的下标位置。</li><li>从左到右遍历字符串，遍历的同时维护当前片段的开始下标 start 和结束下标 end，初始时 start&#x3D;end&#x3D;0。</li><li>对于每个访问到的字母 c，得到当前字母的最后一次出现的下标位置$end_c$，则当前片段的结束下标一定不会小于$end_c$，因此令 end&#x3D;max(end,$end_c$)。</li><li>当访问到下标 end 时，当前片段访问结束，当前片段的下标范围是 [start,end]，长度为 end−start+1，将当前片段的长度添加到返回值，然后令 start&#x3D;end+1，继续寻找下一个片段。</li><li>重复上述过程，直到遍历完字符串。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">partitionLabels</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">// 找到每个字符结束的位置</span><br>        <span class="hljs-type">int</span>[] last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            last[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        <span class="hljs-comment">// 从前往后找区间</span><br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            end = Math.max(end, last[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-comment">// 访问到当前区间末</span><br>            <span class="hljs-keyword">if</span> (i == end) &#123;<br>                ans.add(end - start + <span class="hljs-number">1</span>);<br>                start = end + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(|Σ∣)，|Σ∣ &#x3D; 26.</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一部分贪心算法主要是股票问题和合并区间的问题，思路并不好想，以后再多练习。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>贪心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 热题 100-堆</title>
    <link href="/2024/12/16/posts/hot100-13/"/>
    <url>/2024/12/16/posts/hot100-13/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-热题-100-堆"><a href="#LeetCode-热题-100-堆" class="headerlink" title="LeetCode 热题 100-堆"></a>LeetCode 热题 100-堆</h1><h2 id="数组中的第k个最大元素"><a href="#数组中的第k个最大元素" class="headerlink" title="数组中的第k个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-100-liked">数组中的第k个最大元素</a></h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>建立一个大小为k的小根堆，遍历数组中的元素，如果有大于堆顶的，则替换堆顶并调整堆，最终堆顶就是第k个最大的元素。</p><ul><li>小根堆操作：将以节点 i 为根的子树进行小根堆调整<ul><li>获取左右子节点索引和当前节点索引</li><li>如果左子节点存在且小于当前节点，则更新最小节点索引；如果右子节点存在且小于当前节点或左子节点，则更新最小节点索引</li><li>如果最小节点索引不等于当前节点索引，则交换当前节点和最小节点，并继续调整最小堆。</li></ul></li><li>建立小根堆： 从最后一个非叶子节点开始，依次向前调整节点，保证以每个节点为根的子树都是小根堆。</li><li></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 建立小根堆</span><br>        buildMinHeap(nums, k);<br>        <span class="hljs-comment">// 遍历剩余元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[<span class="hljs-number">0</span>]) &#123;<br>                swap(nums, i, <span class="hljs-number">0</span>);<br>                minHeapify(nums, <span class="hljs-number">0</span>, k);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">minHeapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> heapSize)</span> &#123;<br>        <span class="hljs-comment">// 获取左右子节点索引和当前节点索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">smallest</span> <span class="hljs-operator">=</span> index;<br>        <span class="hljs-comment">// 如果左子节点存在且小于当前节点，则更新最小节点索引</span><br>        <span class="hljs-keyword">if</span> (left &lt; heapSize &amp;&amp; nums[left] &lt; nums[smallest]) &#123;<br>            smallest = left;<br>        &#125;<br>        <span class="hljs-comment">// 如果右子节点存在且小于当前节点或左子节点，则更新最小节点索引</span><br>        <span class="hljs-keyword">if</span> (right &lt; heapSize &amp;&amp; nums[right] &lt; nums[smallest]) &#123;<br>            smallest = right;<br>        &#125;<br>        <span class="hljs-comment">// 如果最小节点索引不等于当前节点索引，则交换当前节点和最小节点，并继续调整最小堆</span><br>        <span class="hljs-keyword">if</span> (smallest != index) &#123;<br>            swap(nums, index, smallest);<br>            minHeapify(nums, smallest, heapSize);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildMinHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> heapSize)</span> &#123;<br>        <span class="hljs-comment">// 从最后一个非叶子节点开始，依次向前调整节点，保证以每个节点为根的子树都是小根堆</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> heapSize / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            minHeapify(nums, i, heapSize);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[a];<br>        nums[a] = nums[b];<br>        nums[b] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlong)</li><li>空间复杂度：O(logn)</li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>使用快速排序在每次调整时，都会确定一个元素的最终位置，且以该元素为界限，将数组分成了左右两个子数组，左子数组中的元素都比该元素小，右子树组中的元素都比该元素大。</p><p>这样，只要某次划分的元素恰好是第k个下标就找到了答案。并且我们只需关注第k个最大元素所在区间的排序情况，与第k个最大元素无关的区间排序都可以忽略。这样进一步减少了执行步骤。</p><ul><li>分区函数：<ul><li>选择左边界元素作为基准元素；</li><li>初始化左右指针；</li><li>开始分区：<ul><li>从左往右找到第一个大于等于基准元素的元素；</li><li>从右往左找到第一个小于等于基准元素的元素；</li><li>如果左右指针相遇，则分区完成，退出循环；</li><li>交换不符合条件的元素；</li></ul></li><li>分区完成，将基准元素放置在正确的位置上；</li><li>返回基准元素的位置。</li></ul></li><li>快速选择：<ul><li>分区并获取基准元素的位置；</li><li>将 k 转换为目标数组下标；</li><li>如果基准元素的位置就是目标位置，则返回该元素；</li><li>如果基准元素的位置小于目标位置，则在右侧继续查找；</li><li>如果基准元素的位置大于目标位置，则在左侧继续查找。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">return</span> quickSelect(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, k);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">quickSelect</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivotIndex</span> <span class="hljs-operator">=</span> partion(nums, left, right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> nums.length - k;<br>        <span class="hljs-keyword">if</span> (pivotIndex == target) &#123;<br>            <span class="hljs-keyword">return</span> nums[pivotIndex];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivotIndex &lt; target) &#123;<br>            <span class="hljs-keyword">return</span> quickSelect(nums, pivotIndex + <span class="hljs-number">1</span>, right, k);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> quickSelect(nums, left, pivotIndex - <span class="hljs-number">1</span>, k);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partion</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">// 选择左边界元素作为基准元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> nums[left];<br>        <span class="hljs-comment">// 初始化左右指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left, j = right + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 开始分区</span><br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-comment">// 从左往右找到第一个大于等于基准元素的元素</span><br>            <span class="hljs-keyword">while</span>(++i &lt; right &amp;&amp; nums[i] &lt; pivot);<br>            <span class="hljs-comment">// 从右往左找到第一个小于等于基准元素的元素</span><br>            <span class="hljs-keyword">while</span>(--j &gt; left &amp;&amp; nums[j] &gt; pivot);<br>            <span class="hljs-comment">// 分区完成</span><br>            <span class="hljs-keyword">if</span> (i &gt;= j) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 交换</span><br>            swap(nums, i, j);<br>        &#125;<br>        <span class="hljs-comment">// 将基准元素放置在正确的位置上</span><br>        swap(nums, left, j);<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[a];<br>        nums[a] = nums[b];<br>        nums[b] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)</li></ul><p>对于快排左右指针初始化及边界判断问题需要再好好想想。</p><h2 id="前k个高频元素"><a href="#前k个高频元素" class="headerlink" title="前k个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/?envType=study-plan-v2&envId=top-100-liked">前k个高频元素</a></h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>用哈希表存储统计的元素及其个数，然后按照其个数大小进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">// 统计次数</span><br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(num)) &#123;<br>                map.put(num, map.get(num) + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                map.put(num, <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 建立最小堆</span><br>        PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer a, Integer b)</span> &#123;<br>                <span class="hljs-keyword">return</span> map.get(a) - map.get(b);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (Integer key : map.keySet()) &#123;<br>            <span class="hljs-keyword">if</span> (heap.size() &lt; k) &#123;<br>                heap.add(key);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.get(key) &gt; map.get(heap.peek())) &#123;<br>                heap.remove();<br>                heap.add(key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;<br>            res[i++] = heap.remove();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogk)</li><li>空间复杂度：O(n)</li></ul><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>使用哈希表统计频率，统计完成后，创建一个数组，将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">// 统计次数</span><br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(num)) &#123;<br>                map.put(num, map.get(num) + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                map.put(num, <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 桶排序</span><br>        List&lt;Integer&gt;[] list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[nums.length + <span class="hljs-number">1</span>];   <span class="hljs-comment">// 最多出现n次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : map.keySet()) &#123;<br>            <span class="hljs-comment">// 出现次数作为下标</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> map.get(key);<br>            <span class="hljs-keyword">if</span> (list[i] == <span class="hljs-literal">null</span>) &#123;<br>                list[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>            &#125;<br>            list[i].add(key);<br>        &#125;<br><br>        <span class="hljs-comment">// 返回结果</span><br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> list.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; res.size() &lt; k; i--) &#123;<br>            <span class="hljs-keyword">if</span> (list[i] != <span class="hljs-literal">null</span>) &#123;<br>                res.addAll(list[i]);<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> res.stream().mapToInt(Integer::intValue).toArray();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a><a href="https://leetcode.cn/problems/find-median-from-data-stream/?envType=study-plan-v2&envId=top-100-liked">数据流的中位数</a></h2><p>随着 addNum 不断地添加数字，我们需要：</p><ul><li>保证 left 的大小和 right 的大小尽量相等。规定：在有奇数个数时，left 比 right 多 1 个数。</li><li>保证 left 的所有元素都小于等于 right 的所有元素。</li></ul><p>只要时时刻刻满足以上两个要求（满足中位数的定义），我们就可以用 left 中的最大值以及 right 中的最小值计算中位数。</p><p><img src="/2024/12/16/posts/hot100-13/image.png" alt="分类讨论"></p><p>即left是最大堆，right时最小堆。如果当前有奇数个元素，中位数是 left 的堆顶。如果当前有偶数个元素，中位数是 left 的堆顶和 right 的堆顶的平均值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityQueue&lt;Integer&gt; left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; b - a); <span class="hljs-comment">// 最大堆</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityQueue&lt;Integer&gt; right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(); <span class="hljs-comment">// 最小堆</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">// 加入右堆并移出堆顶至左堆</span><br>        <span class="hljs-keyword">if</span> (left.size() == right.size()) &#123;<br>            right.offer(num);<br>            left.offer(right.poll());<br>        &#125;<br>        <span class="hljs-comment">// 加入左堆并移出堆顶至右堆</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            left.offer(num);<br>            right.offer(left.poll());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 奇数个元素</span><br>        <span class="hljs-keyword">if</span> (left.size() &gt; right.size()) &#123;<br>            <span class="hljs-keyword">return</span> left.peek();<br>        &#125;<br>        <span class="hljs-comment">// 偶数个</span><br>        <span class="hljs-keyword">return</span> (left.peek() + right.peek()) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logq)，添加数字。</li><li>空间复杂度：O(q)</li></ul><p>不得不再次感叹灵神的思路太通透了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于堆，可以自己用数组模拟实现，也可以使用PriorityQueue。对于java中的各种数据结构还非常不熟悉，要一边刷题一边复习数据结构的使用。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>堆</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 热题 100-栈</title>
    <link href="/2024/12/15/posts/hot100-12/"/>
    <url>/2024/12/15/posts/hot100-12/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-热题-100-栈"><a href="#LeetCode-热题-100-栈" class="headerlink" title="LeetCode 热题 100-栈"></a>LeetCode 热题 100-栈</h1><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked">有效的括号</a></h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>遇到左括号就放入栈，遇到右括号就开始匹配。最后如果栈不为空，就说明匹配失败，否则成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        Map&lt;Character, Character&gt; pairs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>);<br>            put(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>);<br>            put(<span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>);<br>        &#125;&#125;;<br><br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (!pairs.containsKey(c)) &#123;    <span class="hljs-comment">// 左括号就入栈</span><br>                stack.push(c);<br>            &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.isEmpty() || stack.pop() != pairs.get(c)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a><a href="https://leetcode.cn/problems/min-stack/?envType=study-plan-v2&envId=top-100-liked">最小栈</a></h2><h3 id="辅助栈"><a href="#辅助栈" class="headerlink" title="辅助栈"></a>辅助栈</h3><ol><li>主栈 stack：存储所有元素。</li><li>辅助栈 minStk：存储当前栈的最小值。<ul><li>每次 push 时，将新元素与当前最小值比较，更新 minStk。</li><li>每次 pop 时，同时更新主栈和辅助栈，保证 minStk 栈顶始终是当前栈的最小值。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    Deque&lt;Integer&gt; stack;<br>    Deque&lt;Integer&gt; minStk;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        minStk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        minStk.push(Integer.MAX_VALUE);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        stack.push(val);<br>        minStk.push(Math.min(minStk.peek(), val));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        stack.pop();<br>        minStk.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> minStk.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：所有操作均为 O(1)。</li><li>空间复杂度：O(q)。其中 q 是 push 调用的次数。</li></ul><h3 id="不使用辅助栈"><a href="#不使用辅助栈" class="headerlink" title="不使用辅助栈"></a>不使用辅助栈</h3><p>在主栈中存储每个元素时，同时存储它入栈时的最小值。这样每次入栈时，当前最小值都与数据元素绑定在一起，不需要额外的辅助栈。</p><ol><li>每次入栈时：<ul><li>将新元素与当前栈的最小值（即栈顶的最小值）比较，记录较小的那个作为当前元素的“入栈最小值”。</li><li>将数据和当前最小值打包成一对存入栈中。</li></ul></li><li>每次出栈时：<ul><li>只需弹出栈顶，弹出的同时也会移除与该数据绑定的最小值。</li></ul></li><li>查询最小值：<ul><li>栈顶的“入栈最小值”即为当前栈中所有元素的最小值。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <span class="hljs-keyword">private</span> Deque&lt;<span class="hljs-type">int</span>[]&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(); <span class="hljs-comment">// 用于存储 [元素值, 当前最小值]</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 添加栈底哨兵</span><br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, Integer.MAX_VALUE&#125;);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;val, Math.min(getMin(), val)&#125;);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        stack.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek()[<span class="hljs-number">0</span>];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek()[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(1)</li><li>空间复杂度：O(q)。其中 q 是 push 调用的次数。</li></ul><h2 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a><a href="https://leetcode.cn/problems/decode-string/?envType=study-plan-v2&envId=top-100-liked">字符串解码</a></h2><h3 id="辅助栈-1"><a href="#辅助栈-1" class="headerlink" title="辅助栈"></a>辅助栈</h3><ol><li>构建辅助栈 stack， 遍历字符串 s 中每个字符 c:<ul><li>当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；</li><li>当 c 为字母时，在 res 尾部添加 c；</li><li>当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 0：<ul><li>记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；</li><li>记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × […] 字符串。</li><li>进入到新 [ 后，res 和 multi 重新记录。</li></ul></li><li>当 c 为 ] 时，stack 出栈，拼接字符串 res &#x3D; last_res + cur_multi * res，其中:<ul><li>last_res是上个 [ 到当前 [ 的字符串，例如 “3[a2[c]]” 中的 a；</li><li>cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 “3[a2[c]]” 中的 2。</li></ul></li></ul></li><li>返回字符串res。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">decodeString</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; numStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        Deque&lt;String&gt; strStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">muiti</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历字符串</span><br>        <span class="hljs-keyword">for</span> (Character c : s.toCharArray()) &#123;<br>            <span class="hljs-comment">// 如果是左括号</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 把字符串和数字加入栈</span><br>                numStack.push(muiti);<br>                strStack.push(res.toString());<br>                <span class="hljs-comment">// 清空</span><br>                muiti = <span class="hljs-number">0</span>;<br>                res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            &#125; <br>            <span class="hljs-comment">// 如果是右括号</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 拼接字符串</span><br>                <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> numStack.pop();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cur; i++) &#123;<br>                    tmp.append(res);<br>                &#125;<br>                res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(strStack.pop() + tmp);<br>            &#125;<br>            <span class="hljs-comment">// 如果是数字</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                muiti = muiti * <span class="hljs-number">10</span> + Integer.parseInt(c + <span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 如果是普通字符</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                res.append(c);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>总体思路与辅助栈法一致，不同点在于将 [ 和 ] 分别作为递归的开启与终止条件：</p><ul><li>当 s[i] &#x3D;&#x3D; ‘]’ 时，返回当前括号内记录的 res 字符串与 ] 的索引 i （更新上层递归指针位置）；</li><li>当 s[i] &#x3D;&#x3D; ‘[‘ 时，开启新一层递归，记录此 […] 内字符串 tmp 和递归后的最新索引 i，并执行 res + multi * tmp 拼接字符串。</li><li>遍历完毕后返回 res。</li></ul><ol><li>递归函数 dfs(s, index):</li></ol><ul><li>index 表示当前正在处理的位置。</li><li>通过 StringBuilder res 存储当前解码的结果。</li><li>multi 是一个临时变量，用来存储重复的次数。由于重复次数可能是多位数，所以每遇到一个数字就累加到 multi 上。</li></ul><ol start="2"><li>遍历字符串:<ul><li><p>左括号 [: 如果遇到左括号，说明接下来是一个子字符串，需要递归解码括号内的部分。</p><ul><li>递归调用 dfs(s, index + 1) 处理括号内部的内容，并更新 index 到递归调用返回的右括号位置。</li><li>tmp[1] 是括号内的解码结果，multi 是重复次数，把括号内的内容根据 multi 重复添加到结果中。</li></ul></li><li><p>右括号 ]: 如果遇到右括号，说明当前的括号已经处理完，返回当前解码结果（包含当前部分的字符串以及更新后的 index）。</p></li><li><p>数字字符: 如果是数字字符（0-9），则通过累加构建完整的重复次数 multi，因为重复次数可能是多位数（如 “10[a]” 表示重复10次）。</p></li><li><p>普通字符: 普通字符直接追加到结果中。</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">decodeString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(s, <span class="hljs-number">0</span>)[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String[] dfs(String s, <span class="hljs-type">int</span> index) &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">multi</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历字符串</span><br>        <span class="hljs-keyword">while</span> (index &lt; s.length()) &#123;<br>            <span class="hljs-type">Character</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(index);<br>            <span class="hljs-comment">// 如果是左括号</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                String[] tmp = dfs(s, index + <span class="hljs-number">1</span>);<br>                index = Integer.parseInt(tmp[<span class="hljs-number">0</span>]);<br>                <span class="hljs-keyword">while</span> (multi &gt; <span class="hljs-number">0</span>) &#123;<br>                    res.append(tmp[<span class="hljs-number">1</span>]);<br>                    multi--;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果是右括号</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;String.valueOf(index), res.toString()&#125;;<br>            &#125;<br>            <span class="hljs-comment">// 如果是数字</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                multi = multi * <span class="hljs-number">10</span> + Integer.parseInt(String.valueOf(c));<br>            &#125;<br>            <span class="hljs-comment">// 如果是普通字符</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                res.append(String.valueOf(c));<br>            &#125;<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;res.toString()&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/?envType=study-plan-v2&envId=top-100-liked">每日温度</a></h2><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>从左向右遍历元素，如果当前元素比栈顶小，直接入栈，等待出现更大元素；否则，把所有小于等于它的元素弹出，并且可以更新每一个弹出的元素的结果，即i - stk.top()，再将当前元素放入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> temperatures.length;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 找到第一个比当前温度小或相等的元素，注意等于的时候无法更新</span><br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;<br>                ans[stack.peek()] = i - stack.peek();<br>                stack.pop();<br>            &#125;<br>            stack.push(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，每个元素最多入栈和出栈一次。</li><li>空间复杂度：O(n)</li></ul><h3 id="从右往左"><a href="#从右往左" class="headerlink" title="从右往左"></a>从右往左</h3><p>如果当前元素比栈顶小，直接入栈，并且当前元素的下一个更高温度就是1；否则，把所有小于等于它的元素弹出，再将其放入，当前元素的下一个更高温度就是栈顶元素。即，找到第一个大于当前元素的栈中元素，其值应该是栈顶元素下标-当前元素下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> temperatures.length;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">// 找到第一个大于当前元素的栈中元素，注意等于的时候无法更新</span><br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[i] &gt;= temperatures[stack.peek()]) &#123;<br>                stack.pop();<br>            &#125;<br>            <span class="hljs-comment">// 栈顶元素下标-当前元素下标</span><br>            <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;<br>                ans[i] = stack.peek() - i;<br>            &#125;<br>            stack.push(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/?envType=study-plan-v2&envId=top-100-liked">柱状图中最大的矩形</a></h2><h3 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h3><ul><li>在 i 左侧的小于 h 的最近元素的下标 left，如果不存在则为 −1。求出了 left，那么 left+1 就是在 i 左侧的大于等于 h 的最近元素的下标。</li><li>在 i 右侧的小于 h 的最近元素的下标 right，如果不存在则为 n。求出了 right，那么 right−1 就是在 i 右侧的大于等于 h 的最近元素的下标。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.length;<br>        <span class="hljs-comment">// 从左往右找到每个下标左边第一个小于等于当前高度的下标</span><br>        <span class="hljs-type">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(left, -<span class="hljs-number">1</span>);<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[i] &lt;= heights[stack.peek()]) &#123;<br>                stack.pop();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;<br>                left[i] = stack.peek();<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-comment">// 从右往左找到每个下标右边第一个小于等于当前高度的下标</span><br>        <span class="hljs-type">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(right, n);<br>        stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[i] &lt;= heights[stack.peek()]) &#123;<br>                stack.pop();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;<br>                right[i] = stack.peek();<br>            &#125;<br>            stack.push(i);<br>        &#125;<br><br>        <span class="hljs-comment">// 计算</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            ans = Math.max(ans, (right[i] - left[i] - <span class="hljs-number">1</span>) * heights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>java中栈可以使用<code>Deque&lt;&gt; stk = new ArrayDuque&lt;&gt;();</code>，常用的操作有：</p><ul><li>peek()</li><li>pop()</li><li>push()</li><li>isEmpty()</li></ul><p>单调栈的部分需要再好好想想，多练习几道题。 </p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 热题 100-二分查找</title>
    <link href="/2024/12/13/posts/hot100-11/"/>
    <url>/2024/12/13/posts/hot100-11/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-热题-100-二分查找"><a href="#LeetCode-热题-100-二分查找" class="headerlink" title="LeetCode 热题 100-二分查找"></a>LeetCode 热题 100-二分查找</h1><h2 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a><a href="https://leetcode.cn/problems/search-insert-position/description/?envType=study-plan-v2&envId=top-100-liked">搜索插入位置</a></h2><h3 id="闭区间"><a href="#闭区间" class="headerlink" title="闭区间"></a>闭区间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="开区间"><a href="#开区间" class="headerlink" title="开区间"></a>开区间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, right = n;<br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid;<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix/?envType=study-plan-v2&envId=top-100-liked">搜索二维矩阵</a></h2><h3 id="z字形查找"><a href="#z字形查找" class="headerlink" title="z字形查找"></a>z字形查找</h3><p>从矩阵的右上角开始搜索，大于目标则列坐标-1，小于目标则行坐标+1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, col = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[row][col] == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][col] &lt; target) &#123;<br>                row++;<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                col--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (row &gt;= m || col &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m + n)</li><li>空间复杂度：O(1)</li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>将二维数组看成一维数组，实现时只需将 a[i] 转换成矩阵中的行号和列号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = m * n;<br>        <span class="hljs-comment">// 左闭右开</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> matrix[mid / n][mid % n];   <span class="hljs-comment">// 转换成行号和列号</span><br>            <span class="hljs-keyword">if</span> (x == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(log(mn))</li><li>空间复杂度：O(1)</li></ul><h2 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/?envType=study-plan-v2&envId=top-100-liked">在排序数组中查找元素的第一个和最后一个位置</a></h2><h3 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h3><p>其实就是lower_bound和upper_bound实现的功能，找到第一个大于等于目标的元素和第一个大于目标的元素下标。</p><p>实现lower_bound函数，右边界不断向左收缩，无需再重新实现查找右边界的函数，直接调用lower_bound，目标值设为target+1即可找到（左闭右开，最终右边界值-1）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> lowerBound(nums, target);<br>        <span class="hljs-comment">// 边界处理</span><br>        <span class="hljs-keyword">if</span> (start == n || nums[start] != target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> lowerBound(nums, target + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;start, end&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowerBound</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 向左收缩边界</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/?envType=study-plan-v2&envId=top-100-liked">搜索旋转排序数组</a></h2><h3 id="二分查找-2"><a href="#二分查找-2" class="headerlink" title="二分查找"></a>二分查找</h3><p>判断哪一部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界：</p><ul><li>如果 [left, mid - 1] 是有序数组，即<code>nums[left] &lt;= nums[mid]</code>：如果<code>target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]</code>，则在左半部分，否则在右半部分；</li><li>否则如果<code>nums[left] &gt; nums[mid]</code>，则右半部分有序：如果<code>target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]</code>，则在右半部分，否则在左半部分。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-comment">// 左半部分有序</span><br>            <span class="hljs-keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;<br>                <span class="hljs-comment">// 在左半部分</span><br>                <span class="hljs-keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;<br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 在右半部分</span><br>                <span class="hljs-keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/?envType=study-plan-v2&envId=top-100-liked">寻找旋转排序数组中的最小值</a></h2><h3 id="二分查找-3"><a href="#二分查找-3" class="headerlink" title="二分查找"></a>二分查找</h3><p>数组经过「旋转」之后，会有两种情况，第一种就是原先的升序序列，另一种是两段升序的序列。第一种的最小值在最左边。第二种最小值在第二段升序序列的第一个元素。</p><p>二分法：left和right分别指向数组首尾。计算mid:</p><ul><li>如果nums[mid] &gt; nums[right]，则最小值一定在mid右侧；</li><li>否则一定在mid或者mid的左侧。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.length;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[right]) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/?envType=study-plan-v2&envId=top-100-liked">寻找两个正序数组的中位数</a></h2><h3 id="二分查找-4"><a href="#二分查找-4" class="headerlink" title="二分查找"></a>二分查找</h3><p>中位数把数组分割成了左右两部分，并且左右两部分元素个数相等。如果两个数组元素个数为偶数，单侧元素个数为$(n1+n2) &#x2F; 2$个；否则是$(n1+n2)&#x2F;2 + 1$个，可以总结为单侧元素个数： $\lfloor \frac{(n1 + n2 + 1)}{2} \rfloor$ 。现在的问题就变为了：如何在两个有序数组中找到前 k 小的元素位置？</p><p><img src="/2024/12/13/posts/hot100-11/image.png" alt="Alt text"></p><p><img src="/2024/12/13/posts/hot100-11/image-1.png" alt="Alt text"></p><p><img src="/2024/12/13/posts/hot100-11/image-2.png" alt="Alt text"></p><ol><li>确保 nums1 是较小的数组：我们总是对较短的数组进行二分查找，减少搜索空间。</li><li>二分查找：在较短数组中查找一个合适的分割点，使得两数组的左半部分和右半部分满足合并后的中位数条件。</li><li>计算中位数：<ul><li>如果数组的总长度为奇数，中位数是左半部分的最大值。</li><li>如果数组的总长度为偶数，中位数是左半部分最大值与右半部分最小值的平均值。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br>        <span class="hljs-comment">// 确保nums1是较小的数组</span><br>        <span class="hljs-keyword">if</span> (m &gt; n) &#123;<br>            <span class="hljs-keyword">return</span> findMedianSortedArrays(nums2, nums1);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 双指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = m;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">partition1</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 第一个数组的分割点</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">partition2</span> <span class="hljs-operator">=</span> k - partition1;<br>            <span class="hljs-comment">// 获取边界值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftMax1</span> <span class="hljs-operator">=</span> partition1 == <span class="hljs-number">0</span> ? Integer.MIN_VALUE : nums1[partition1 - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rightMin1</span> <span class="hljs-operator">=</span> partition1 == m ? Integer.MAX_VALUE : nums1[partition1];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftMax2</span> <span class="hljs-operator">=</span> partition2 == <span class="hljs-number">0</span> ? Integer.MIN_VALUE : nums2[partition2 - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rightMin2</span> <span class="hljs-operator">=</span> partition2 == n ? Integer.MAX_VALUE : nums2[partition2];<br><br>            <span class="hljs-keyword">if</span> (leftMax1 &lt;= rightMin2 &amp;&amp; leftMax2 &lt;= rightMin1) &#123;<br>                <span class="hljs-keyword">if</span> ((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> (Math.max(leftMax1, leftMax2) + Math.min(rightMin1, rightMin2)) / <span class="hljs-number">2.0</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> Math.max(leftMax1, leftMax2);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leftMax1 &gt; rightMin2) &#123; <span class="hljs-comment">// 第一个数组左边元素太多了</span><br>                right = partition1 - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 第一个分组右边元素太多了</span><br>                left = partition1 + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Input arrays are not sorted.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(log(m + n))</li><li>空间复杂度：O(1)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二分查找的部分要注意初始化left和right时是定义区间为左开右闭还是闭区间，两种定义的循环判断条件是不同的。最后一道题有些难，要经常复习。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>二分查找</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 热题 100-回溯法</title>
    <link href="/2024/12/10/posts/hot100-10/"/>
    <url>/2024/12/10/posts/hot100-10/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-热题-100-回溯法"><a href="#LeetCode-热题-100-回溯法" class="headerlink" title="LeetCode 热题 100-回溯法"></a>LeetCode 热题 100-回溯法</h1><p>从这里开始要试着用java刷题了！</p><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a><a href="https://leetcode.cn/problems/permutations/?envType=study-plan-v2&envId=top-100-liked">全排列</a></h2><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>使用标记数组来处理填过的数是一个很直观的思路，为减少空间复杂度，将题目给定的 n 个数的数组 nums 划分成左右两个部分，左边的表示已经填过的数，右边表示待填的数，我们在回溯的时候只要动态维护这个数组即可。</p><ul><li>递归终止条件，index &#x3D;&#x3D; nums.size()。</li><li>递归选择：动态维护数组，将i与index交换，然后递归填下一个数，结束后再换回来。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            path.add(num);<br>        &#125;<br><br>        backtrack(path, <span class="hljs-number">0</span>, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;Integer&gt; path, <span class="hljs-type">int</span> index, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;<br>        <span class="hljs-comment">// 加入结果集</span><br>        <span class="hljs-keyword">if</span> (index == path.size()) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(path));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; path.size(); i++)&#123;<br>                Collections.swap(path, index, i);<br>                backtrack(path, index + <span class="hljs-number">1</span>, res);<br>                Collections.swap(path, index, i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times n!)$，递归的调用次数是 n!，即全排列的数量。对于每个叶子节点，复制 path 的时间复杂度是 O(n)。</li><li>空间复杂度：O(n)，除答案数组以外，递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，这里可知递归调用深度为 O(n)。</li></ul><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a><a href="https://leetcode.cn/problems/subsets/?envType=study-plan-v2&envId=top-100-liked">子集</a></h2><h3 id="回溯法-1"><a href="#回溯法-1" class="headerlink" title="回溯法"></a>回溯法</h3><ul><li>递归结束条件：index &#x3D;&#x3D; nums.size()。</li><li>递归选择：每次可以选择加入或不加入当前元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        backtrack(nums, <span class="hljs-number">0</span>, path, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (index == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 不加入当前元素</span><br>        backtrack(nums, index + <span class="hljs-number">1</span>, path, res);<br><br>        <span class="hljs-comment">// 加入当前元素</span><br>        path.add(nums[index]);<br>        backtrack(nums, index + <span class="hljs-number">1</span>, path, res);<br>        path.remove(path.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times 2^n)$，一共$2^n$个状态，每种状态需要 O(n) 的时间来构造子集。</li><li>空间复杂度：O(n)，递归栈空间。</li></ul><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>0&#x2F;1序列对应的二进制数即$[0, 2^n-1]$，可以枚举mask，构造出所有的子集。外部循环是所有可能的子集个数，内部循环指示当前子集的状态，如果mask的第i位为1，则当前数字在子集中，如果是0则不在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">mask</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; mask &lt; (<span class="hljs-number">1</span> &lt;&lt; n); mask++) &#123;<br>            path.clear();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> ((mask &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) != <span class="hljs-number">0</span>) &#123;<br>                    path.add(nums[i]);<br>                &#125;<br>            &#125;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(path));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times 2^n)$</li><li>空间复杂度：O(n)，临时数组的代价。</li></ul><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number?envType=study-plan-v2&envId=top-100-liked">电话号码的字母组合</a></h2><h3 id="回溯法-2"><a href="#回溯法-2" class="headerlink" title="回溯法"></a>回溯法</h3><ol><li>首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。</li><li>回溯过程中维护一个字符串，表示已有的字母排列。该字符串初始为空。每次取电话号码的一位数字，从哈希表中获得该数字对应的所有可能的字母，并将其中的一个字母插入到已有的字母排列后面，然后继续处理电话号码的后一位数字，直到处理完电话号码中的所有数字，即得到一个完整的字母排列。</li><li>然后进行回退操作，遍历其余的字母排列。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        <span class="hljs-comment">// 边界处理</span><br>        <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-comment">// 创建哈希表存储</span><br>        Map&lt;Character, String&gt; phoneMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, String&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>            put(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&quot;def&quot;</span>);<br>            put(<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&quot;ghi&quot;</span>);<br>            put(<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br>            put(<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&quot;mno&quot;</span>);<br>            put(<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>);<br>            put(<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&quot;tuv&quot;</span>);<br>            put(<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>);<br>        &#125;&#125;;<br><br>        backtrack(res, phoneMap, digits, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span> <span class="hljs-params">(List&lt;String&gt; res, Map&lt;Character, String&gt; phoneMap, String digits, <span class="hljs-type">int</span> index, StringBuffer combination)</span> &#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (index == digits.length()) &#123;<br>            res.add(combination.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 对于每一个数字</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> digits.charAt(index);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">letters</span> <span class="hljs-operator">=</span> phoneMap.get(digit);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : letters.toCharArray()) &#123;<br>            combination.append(ch);<br>            backtrack(res, phoneMap, digits, index + <span class="hljs-number">1</span>, combination);<br>            combination.deleteCharAt(index);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(3^m \times 4^n)$，输入包含 m 个对应 3 个字母的数字和 n 个对应 4 个字母的数字。</li><li>空间复杂度：O(m+n)，递归调用层数最大为 m+n。</li></ul><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/?envType=study-plan-v2&envId=top-100-liked">组合总和</a></h2><h3 id="回溯法-3"><a href="#回溯法-3" class="headerlink" title="回溯法"></a>回溯法</h3><p>递归终止条件：当前和等于目标，或index到结尾。</p><p>递归选择：如果不选择当前元素，就递归下一个元素；如果选择当前数字后的和不大于目标，就将其加入当前数组，并继续递归当前元素（因为可以重复选择），然后再将该元素取出，回溯。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dfs(candidates, <span class="hljs-number">0</span>, target, <span class="hljs-number">0</span>, res, path);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> curSum, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path)</span> &#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (curSum == target) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index == candidates.length) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 不选择当前元素</span><br>        dfs(candidates, index + <span class="hljs-number">1</span>, target, curSum, res, path);<br><br>        <span class="hljs-comment">// 选择当前元素</span><br>        <span class="hljs-keyword">if</span> (curSum + candidates[index] &lt;= target)&#123;<br>            path.add(candidates[index]);<br>            dfs(candidates, index, target, curSum + candidates[index], res, path);  <span class="hljs-comment">// 可重复选择</span><br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(2^n \cdot \frac{target}{min(candidates)})$<ul><li>深度：递归的深度在最坏情况下是$O(\frac{target}{min(candidates)})$，因为每次选择一个元素时，目标值 target 会减去某个候选元素的值，直到 curSum 达到 target。</li><li>宽度：搜索树的每一层最多有 $O(2^n)$ 分支，其中 nn 是 candidates 的长度。</li></ul></li><li>空间复杂度：O(target)，返回值不计入。path 长度和递归深度至多为 O(target)。</li></ul><p>剪枝优化：可以对candidates进行排序，这样后面的数字就无需再进行判断。</p><h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/?envType=study-plan-v2&envId=top-100-liked">括号生成</a></h2><h3 id="回溯法-4"><a href="#回溯法-4" class="headerlink" title="回溯法"></a>回溯法</h3><p>递归结束：左括号剩余数&#x3D;右括号剩余数&#x3D;0</p><p>递归选择：用变量记录当前的左括号和右括号剩余数，如果当前左括号剩余数大于0那就可以继续生成左括号，如果右括号数剩余数大于左括号剩余数那就可以生成右括号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        dfs(n, n, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(), res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, StringBuffer str, List&lt;String&gt; res)</span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>) &#123;<br>            res.add(str.toString());<br>        &#125;<br><br>        <span class="hljs-comment">// 选择左括号</span><br>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>            str.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            dfs(left-<span class="hljs-number">1</span>, right, str, res);<br>            str.deleteCharAt(str.length() - <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 选择右括号</span><br>        <span class="hljs-keyword">if</span> (right &gt; left) &#123;<br>            str.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            dfs(left, right-<span class="hljs-number">1</span>, str, res);<br>            str.deleteCharAt(str.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：分析回溯问题的时间复杂度，有一个通用公式：路径长度×搜索树的叶子数。第n个卡特兰数$O(\frac{4^n}{n\sqrt{n}})$,在回溯过程中，每个答案需要 O(n) 的时间复制到答案数组中，因此时间复杂度为$O(\frac{4^n}{\sqrt{n}})$。</li><li>空间复杂度：O(n)，递归栈深度。</li></ul><h2 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a><a href="https://leetcode.cn/problems/word-search/?envType=study-plan-v2&envId=top-100-liked">单词搜索</a></h2><h3 id="回溯法-5"><a href="#回溯法-5" class="headerlink" title="回溯法"></a>回溯法</h3><ol><li>定义一个标记数组，标记当前位置是否访问过。</li><li>遍历板子的每个位置，每次从单词的第一个字符开始进行回溯搜索。</li><li>如果当前索引到最后，则递归结束，找到了整个单词，返回true。</li><li>否则检查边界条件、当前位置是否访问过、是否匹配，如果有一个不满足就返回false。</li><li>标记当前位置已访问过，继续搜索上下左右四个位置。</li><li>回溯，将当前位置标记为false。</li><li>返回递归搜索的结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span>[][] visited;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (dfs(board, word, i, j, <span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-comment">// 找到单词</span><br>        <span class="hljs-keyword">if</span> (index == word.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 超出边界或不匹配</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= m || j &lt; <span class="hljs-number">0</span> || j &gt;= n || visited[i][j] == <span class="hljs-literal">true</span> || board[i][j] != word.charAt(index)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 上下左右四个方向搜索</span><br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(board, word, i-<span class="hljs-number">1</span>, j, index + <span class="hljs-number">1</span>) || dfs(board, word, i+<span class="hljs-number">1</span>, j, index + <span class="hljs-number">1</span>) || dfs(board, word, i, j-<span class="hljs-number">1</span>, index + <span class="hljs-number">1</span>) || dfs(board, word, i, j+<span class="hljs-number">1</span>, index + <span class="hljs-number">1</span>);<br><br>        visited[i][j] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 回溯</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(mn\cdot3^L)$，L是单词长度。除了递归入口，其余递归至多有 3 个分支（因为至少有一个方向是之前走过的），所以每次递归（回溯）的时间复杂度为$O(3^L)$。</li><li>空间复杂度：$O(m \times n + L)$</li></ul><p>优化点：</p><ol><li>统计word中字母出现的次数，如果某个字母出现的次数比整个板子该字母出现的次数多，则直接返回false。</li><li>设 word 的第一个字母在 board 中出现了 x 次，word 的最后一个字母在 board 中出现了 y 次。如果 y&lt;x，我们可以把 word 反转，相当于从 word 的最后一个字母开始搜索，这样更容易在一开始就满足 board[i][j] !&#x3D; word[k]，不会往下递归，递归的总次数更少。</li></ol><h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/description/?envType=study-plan-v2&envId=top-100-liked">分割回文串</a></h2><h3 id="选或不选"><a href="#选或不选" class="headerlink" title="选或不选"></a>选或不选</h3><ul><li>递归结束：index &#x3D;&#x3D; n。</li><li>是否要把 s[i] 当成分割出的子串的最后一个字符。注意 s[n−1] 一定是最后一个字符，一定要选。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res;<br>    List&lt;String&gt; path;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dfs(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 回溯</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (index == n) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 不选</span><br>        <span class="hljs-keyword">if</span> (index &lt; n - <span class="hljs-number">1</span>) &#123;<br>            dfs(s, index + <span class="hljs-number">1</span>, start);<br>        &#125;<br><br>        <span class="hljs-comment">// 选</span><br>        <span class="hljs-keyword">if</span> (isPalindrome(s, start, index)) &#123;<br>            path.add(s.substring(start, index + <span class="hljs-number">1</span>));<br>            dfs(s, index + <span class="hljs-number">1</span>, index + <span class="hljs-number">1</span>);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否是回文串</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(left++) != s.charAt(right--)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n2^n)$，每次都是选或不选，递归次数为一个满二叉树的节点个数，即$2^n$，再算上判断回文和加入答案时需要 O(n) 的时间。</li><li>空间复杂度：O(n)</li></ul><h3 id="枚举结束的位置"><a href="#枚举结束的位置" class="headerlink" title="枚举结束的位置"></a>枚举结束的位置</h3><ul><li>递归结束：index &#x3D;&#x3D; n。</li><li>枚举结束位置：从index开始向后枚举</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res;<br>    List&lt;String&gt; path;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dfs(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 回溯</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (index == n) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 枚举子串的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> index; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (isPalindrome(s, index, j)) &#123;<br>                path.add(s.substring(index, j + <span class="hljs-number">1</span>));<br>                dfs(s, j + <span class="hljs-number">1</span>);<br>                path.remove(path.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否是回文串</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(left++) != s.charAt(right--)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n2^n)$</li><li>空间复杂度：O(n)</li></ul><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a><a href="https://leetcode.cn/problems/n-queens/?envType=study-plan-v2&envId=top-100-liked">N皇后</a></h2><h3 id="回溯法-6"><a href="#回溯法-6" class="headerlink" title="回溯法"></a>回溯法</h3><ul><li>递归结束条件：index &#x3D;&#x3D; n。</li><li>递归选择：如果当前位置放置皇后，不产生冲突，则放置，否则置空。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res;<br>    List&lt;String&gt; board;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        board = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">dots</span> <span class="hljs-operator">=</span> String.join(<span class="hljs-string">&quot;&quot;</span>, Collections.nCopies(n, <span class="hljs-string">&quot;.&quot;</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            board.add(dots);<br>        &#125;<br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board.size();<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(board));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 逐列放置皇后</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>            <span class="hljs-keyword">if</span> (isValid(row, col)) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">rowString</span> <span class="hljs-operator">=</span> board.get(row);<br>                board.set(row, rowString.substring(<span class="hljs-number">0</span>, col) + <span class="hljs-string">&#x27;Q&#x27;</span> + rowString.substring(col + <span class="hljs-number">1</span>));<br>                dfs(row + <span class="hljs-number">1</span>);<br>                board.set(row, rowString); <span class="hljs-comment">// 回溯</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board.size();<br>        <span class="hljs-comment">// 检查行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">if</span> (board.get(i).charAt(col) == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 检查45度角</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row-<span class="hljs-number">1</span>, j = col-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>            <span class="hljs-keyword">if</span> (board.get(i).charAt(j) == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 检查135度角</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row-<span class="hljs-number">1</span>, j = col+<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;<br>            <span class="hljs-keyword">if</span> (board.get(i).charAt(j) == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \cdot n!)$，决策为n!，每次判断是否合法为O(n)，实际运行时间会小于这个上界，因为很多分支会被提前剪掉。</li><li>空间复杂度：$O(n^2)$，递归深度是O(n)，board是$O(n^2)$。</li></ul><p>空间优化:</p><ul><li>可以使用位运算来表示皇后的位置，将空间复杂度优化到 O(N)</li><li>使用三个整数分别记录列、主对角线、副对角线的占用情况</li></ul><p>时间优化:</p><ul><li>当前的 isValid 检查可以通过位运算优化</li><li>可以维护已占用的列和对角线信息，避免重复检查</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;String&gt;&gt; res;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cols;      <span class="hljs-comment">// 列占用情况</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> diag1;     <span class="hljs-comment">// 主对角线占用情况</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> diag2;     <span class="hljs-comment">// 副对角线占用情况</span><br>    <br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.cols = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.diag1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.diag2 = <span class="hljs-number">0</span>;<br>        <br>        dfs(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row, List&lt;String&gt; board)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(board));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>            <span class="hljs-comment">// 使用位运算检查位置是否可用</span><br>            <span class="hljs-keyword">if</span> (isAvailable(row, col)) &#123;<br>                <span class="hljs-comment">// 标记占用</span><br>                markQueen(row, col, <span class="hljs-literal">true</span>);<br>                <span class="hljs-comment">// 构建当前行字符串</span><br>                <span class="hljs-type">char</span>[] rowChars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n];<br>                Arrays.fill(rowChars, <span class="hljs-string">&#x27;.&#x27;</span>);<br>                rowChars[col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                board.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(rowChars));<br>                <br>                dfs(row + <span class="hljs-number">1</span>, board);<br>                <br>                <span class="hljs-comment">// 回溯</span><br>                board.remove(board.size() - <span class="hljs-number">1</span>);<br>                markQueen(row, col, <span class="hljs-literal">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAvailable</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-keyword">return</span> ((cols &amp; (<span class="hljs-number">1</span> &lt;&lt; col)) |<br>                (diag1 &amp; (<span class="hljs-number">1</span> &lt;&lt; (row + col))) |<br>                (diag2 &amp; (<span class="hljs-number">1</span> &lt;&lt; (row - col + n - <span class="hljs-number">1</span>)))) == <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">markQueen</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">boolean</span> place)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> place ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        cols ^= (<span class="hljs-number">1</span> &lt;&lt; col);<br>        diag1 ^= (<span class="hljs-number">1</span> &lt;&lt; (row + col));<br>        diag2 ^= (<span class="hljs-number">1</span> &lt;&lt; (row - col + n - <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n!)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>回溯法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 热题 100-图论</title>
    <link href="/2024/12/08/posts/hot100-9/"/>
    <url>/2024/12/08/posts/hot100-9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-热题-100-图论"><a href="#LeetCode-热题-100-图论" class="headerlink" title="LeetCode 热题 100-图论"></a>LeetCode 热题 100-图论</h1><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-100-liked">岛屿数量</a></h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>对于每一个位置，如果它是1，就以它为中心，向四周扩展，并更新结果。需要对已经遍历过的岛屿进行标记，防止重复遍历。需要定义一个函数，判断是否越界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    ans++;<br>                    <span class="hljs-built_in">dfs</span>(grid, i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span></span>&#123;<br>        <span class="hljs-comment">// 位置不合法，直接返回</span><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isArea</span>(grid, row, col))&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 避免重复遍历</span><br>        <span class="hljs-keyword">if</span>(grid[row][col] != <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        grid[row][col] = <span class="hljs-string">&#x27;2&#x27;</span>; <span class="hljs-comment">// 标记已访问过</span><br>        <span class="hljs-comment">// 递归遍历上下左右四个方向</span><br>        <span class="hljs-built_in">dfs</span>(grid, row - <span class="hljs-number">1</span>, col);<br>        <span class="hljs-built_in">dfs</span>(grid, row + <span class="hljs-number">1</span>, col);<br>        <span class="hljs-built_in">dfs</span>(grid, row, col - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(grid, row, col + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isArea</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span></span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; n)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(mn)$</li><li>空间复杂度：$O(mn)$，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 MN。</li></ul><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>扫描整个二维网格。如果一个位置为 1，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的 1 都会被标记为 2。直到队列为空，搜索结束。最终岛屿的数量就是我们进行广度优先搜索的次数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    ans++;<br>                    grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                    <span class="hljs-comment">// 定义队列</span><br>                    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;  <span class="hljs-comment">// 存储坐标</span><br>                    que.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>                    <span class="hljs-comment">// 广度优先搜索</span><br>                    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>                        <span class="hljs-keyword">auto</span> rc = que.<span class="hljs-built_in">front</span>();<br>                        que.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-type">int</span> row = rc.first, col = rc.second;<br>                        <span class="hljs-comment">// 向四个方向扩展</span><br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isArea</span>(grid, row<span class="hljs-number">-1</span>, col) &amp;&amp; grid[row<span class="hljs-number">-1</span>][col] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                            que.<span class="hljs-built_in">push</span>(&#123;row<span class="hljs-number">-1</span>, col&#125;);<br>                            grid[row<span class="hljs-number">-1</span>][col] = <span class="hljs-string">&#x27;2&#x27;</span>; <br>                        &#125;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isArea</span>(grid, row+<span class="hljs-number">1</span>, col) &amp;&amp; grid[row+<span class="hljs-number">1</span>][col] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                            que.<span class="hljs-built_in">push</span>(&#123;row+<span class="hljs-number">1</span>, col&#125;);<br>                            grid[row+<span class="hljs-number">1</span>][col] = <span class="hljs-string">&#x27;2&#x27;</span>; <br>                        &#125;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isArea</span>(grid, row, col<span class="hljs-number">-1</span>) &amp;&amp; grid[row][col<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                            que.<span class="hljs-built_in">push</span>(&#123;row, col<span class="hljs-number">-1</span>&#125;);<br>                            grid[row][col<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>; <br>                        &#125;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isArea</span>(grid, row, col+<span class="hljs-number">1</span>) &amp;&amp; grid[row][col+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                            que.<span class="hljs-built_in">push</span>(&#123;row, col+<span class="hljs-number">1</span>&#125;);<br>                            grid[row][col+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>; <br>                        &#125;                                                 <br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isArea</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span></span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; n)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(min(m, n))，最坏情况下整个网格均为陆地，广度优先每次向外扩展一圈，直到超出网格边界或不为1，那么最坏情况下，超过较短边界的时候程序就会结束。</li></ul><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>如果一个位置为 1，则将其与相邻四个方向上的 1 在并查集中进行合并。最终岛屿的数量就是并查集中连通分量的数目。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<br>    vector&lt;<span class="hljs-type">int</span>&gt; rank;<br>    <span class="hljs-type">int</span> count;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid) &#123;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-comment">// 初始化并查集</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    parent.<span class="hljs-built_in">push_back</span>(i * n + j);<br>                    count++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    parent.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>                &#125;<br>                rank.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(parent[i] != i)&#123;<br>            parent[i] = <span class="hljs-built_in">find</span>(parent[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-type">int</span> rootx = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-type">int</span> rooty = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-comment">// 按秩合并</span><br>        <span class="hljs-keyword">if</span>(rootx != rooty)&#123;<br>            <span class="hljs-keyword">if</span>(rank[rootx] &lt; rank[rooty])&#123;<br>                <span class="hljs-built_in">swap</span>(rootx, rooty);<br>            &#125;<br>            parent[rooty] = rootx;<br>            <span class="hljs-keyword">if</span>(rank[rootx] == rank[rooty])&#123;<br>                rank[rootx] += <span class="hljs-number">1</span>;<br>            &#125;<br>            count--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(grid)</span></span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                    <span class="hljs-comment">// 向上下左右四个方向扩展</span><br>                    <span class="hljs-type">int</span> x = i * n + j;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isIsland</span>(grid, i<span class="hljs-number">-1</span>, j))&#123;<br>                        uf.<span class="hljs-built_in">unite</span>(x, (i<span class="hljs-number">-1</span>) * n + j);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isIsland</span>(grid, i+<span class="hljs-number">1</span>, j))&#123;<br>                        uf.<span class="hljs-built_in">unite</span>(x, (i+<span class="hljs-number">1</span>) * n + j);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isIsland</span>(grid, i, j<span class="hljs-number">-1</span>))&#123;<br>                        uf.<span class="hljs-built_in">unite</span>(x, i * n + (j<span class="hljs-number">-1</span>));<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isIsland</span>(grid, i, j+<span class="hljs-number">1</span>))&#123;<br>                        uf.<span class="hljs-built_in">unite</span>(x, i * n + (j+<span class="hljs-number">1</span>));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> uf.<span class="hljs-built_in">getCount</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span></span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; n &amp;&amp; grid[row][col] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><h2 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a><a href="https://leetcode.cn/problems/rotting-oranges/?envType=study-plan-v2&envId=top-100-liked">腐烂的橘子</a></h2><h3 id="广度优先搜索-1"><a href="#广度优先搜索-1" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><ul><li>初始化队列，将所有腐烂橘子加入队列，并统计新鲜橘子的个数。</li><li>如果没有新鲜橘子，直接返回 0。</li><li>按层级向四个方向传播，更改橘子标记并更新新鲜橘子数量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que; <span class="hljs-comment">// 用于存储腐烂橘子的位置</span><br>        <span class="hljs-type">int</span> freshCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// 新鲜橘子数量</span><br>        <br>        <span class="hljs-comment">// 初始化队列并统计新鲜橘子</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">2</span>)&#123;<br>                    que.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>)&#123;<br>                    freshCount++;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果没有新鲜橘子，直接返回 0</span><br>        <span class="hljs-keyword">if</span> (freshCount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 四个方向</span><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; directions = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-type">int</span> time = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// BFS 开始传播腐烂</span><br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">bool</span> spread = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 本轮是否有扩展</span><br>            <span class="hljs-keyword">while</span>(size--)&#123;<br>                <span class="hljs-keyword">auto</span> rc = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <br>                <span class="hljs-type">int</span> x = rc.first, y = rc.second;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> dir : directions)&#123;<br>                    <span class="hljs-type">int</span> i = x + dir.first, j = y + dir.second;<br>                    <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>)&#123;<br>                        freshCount--;<br>                        grid[i][j] = <span class="hljs-number">2</span>;<br>                        que.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>                        spread = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(spread)&#123;<br>                time++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果还有新鲜橘子，返回 -1；否则返回时间</span><br>        <span class="hljs-keyword">return</span> freshCount ? <span class="hljs-number">-1</span> : time;        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><h2 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a><a href="https://leetcode.cn/problems/course-schedule/?envType=study-plan-v2&envId=top-100-liked">课程表</a></h2><h3 id="深度优先搜索-1"><a href="#深度优先搜索-1" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>判断能否修完所有的课程，就是判断图中是否存在环，当图中存在环时，就没有拓扑排序。</p><ol><li>建图：把每个 prerequisites[i]&#x3D;[a,b] 看成一条有向边 b→a，构建一个有向图 g。</li><li>创建长为 numCourses 的颜色数组 colors，所有元素值初始化成 0。</li><li>遍历 colors，如果 colors[i]&#x3D;0，则调用递归函数 dfs(i)。</li><li>执行 dfs(x)：<ol><li>首先标记 colors[x]&#x3D;1，表示节点 x 正在访问中。</li><li>然后遍历 x 的邻居 y。如果 colors[y]&#x3D;1，则找到环，返回 true。如果 colors[y]&#x3D;0（没有访问过）且 dfs(y) 返回了 true，那么 dfs(x) 也返回 true。</li><li>如果没有找到环，那么先标记 colors[x]&#x3D;2，表示 x 已经完全访问完毕，然后返回 false。</li></ol></li><li>如果 dfs(i) 返回 true，那么找到了环，返回 false。</li><li>如果遍历完所有节点也没有找到环，返回 true。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edges;<br>    vector&lt;<span class="hljs-type">int</span>&gt; visited;<br>    <span class="hljs-type">bool</span> valid = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        edges.<span class="hljs-built_in">resize</span>(numCourses);<br>        visited.<span class="hljs-built_in">resize</span>(numCourses);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; info : prerequisites)&#123;<br>            edges[info[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(info[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses &amp;&amp; valid; i++)&#123;<br>            <span class="hljs-keyword">if</span>(visited[i] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">dfs</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> valid;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>        visited[u] = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 标记为正在访问中</span><br>        <span class="hljs-comment">// 访问它的邻居节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : edges[u])&#123;<br>            <span class="hljs-keyword">if</span>(visited[v] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">dfs</span>(v);<br>                <span class="hljs-keyword">if</span>(!valid)&#123;<br>                    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 结束递归 </span><br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(visited[v] == <span class="hljs-number">1</span>)&#123;<br>                valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        visited[u] = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(V+E)，V是节点数，E是边数，访问一个节点会对其所有邻居进行遍历。每条边最多访问一次。</li><li>空间复杂度：O(V+E)，Visited存储v个节点，edges存储e条边。</li></ul><h3 id="广度优先搜索-2"><a href="#广度优先搜索-2" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。</p><p>使用一个队列来进行广度优先搜索。初始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，取出队首的节点 u：</p><ul><li>将 u 放入答案中；</li><li>移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。</li></ul><p>由于我们只需要判断是否存在一种拓扑排序，因此省去存放答案数组，而是只用一个变量记录被放入答案数组的节点个数。在广度优先搜索结束之后，我们判断该变量的值是否等于课程数，就能知道是否存在一种拓扑排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edges;<br>    vector&lt;<span class="hljs-type">int</span>&gt; inDegree;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        edges.<span class="hljs-built_in">resize</span>(numCourses);<br>        inDegree.<span class="hljs-built_in">resize</span>(numCourses);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; info : prerequisites)&#123;<br>            edges[info[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(info[<span class="hljs-number">0</span>]);<br>            inDegree[info[<span class="hljs-number">0</span>]]++;<br>        &#125;<br>        <span class="hljs-comment">// 定义队列存放所有入度为0的节点</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; que;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)&#123;<br>            <span class="hljs-keyword">if</span>(inDegree[i] == <span class="hljs-number">0</span>)&#123;<br>                que.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 记录已经遍历过的节点数</span><br>        <span class="hljs-type">int</span> visited = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            visited++;<br>            <span class="hljs-type">int</span> u = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 所有邻居节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : edges[u])&#123;<br>                inDegree[v]--;<br>                <span class="hljs-keyword">if</span>(inDegree[v] == <span class="hljs-number">0</span>)&#123;<br>                    que.<span class="hljs-built_in">push</span>(v);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> numCourses == visited;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(V+E)</li><li>空间复杂度：O(V+E)</li></ul><h2 id="实现前缀树"><a href="#实现前缀树" class="headerlink" title="实现前缀树"></a><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/?envType=study-plan-v2&envId=top-100-liked">实现前缀树</a></h2><h3 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h3><ul><li>初始化：创建一棵 26 叉树，一开始只有一个根节点 root。26 叉树的每个节点包含一个长为 26 的儿子节点列表 son，以及一个布尔值 end，表示是否为终止节点。</li></ul><p>记住这道题的代码模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    Node* son[<span class="hljs-number">26</span>]&#123;&#125;;<br>    <span class="hljs-type">bool</span> end = <span class="hljs-literal">false</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Node* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>    <span class="hljs-built_in">Trie</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        Node* cur = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : word)&#123;<br>            <span class="hljs-comment">// 创建新节点</span><br>            <span class="hljs-keyword">if</span>(cur-&gt;son[c-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nullptr</span>)&#123;<br>                cur-&gt;son[c-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>            &#125;<br>            cur = cur-&gt;son[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        cur-&gt;end = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(word) == <span class="hljs-number">2</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(prefix) != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(string word)</span></span>&#123;<br>        Node* cur = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : word)&#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;son[c-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            cur = cur-&gt;son[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur-&gt;end ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;    <span class="hljs-comment">// 如果整个单词到叶子节点则返回2，否则返回1</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Trie* obj = new Trie();</span><br><span class="hljs-comment"> * obj-&gt;insert(word);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;search(word);</span><br><span class="hljs-comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：初始化为 O(1)，insert 为 O(n∣Σ∣)，其余为 O(n)，其中 n 是 word 的长度，∣Σ∣&#x3D;26 是字符集合的大小。注意创建一个节点需要 O(∣Σ∣) 的时间（如果用的是数组）。</li><li>空间复杂度：O(qn∣Σ∣)。其中 q 是 insert 的调用次数。</li></ul><p>图论部分的题目之前刷的比较少，明天先不刷hot100，先学习一下<a href="https://leetcode.cn/circle/discuss/01LUak/">图论部分</a>和<a href="https://leetcode.cn/circle/discuss/YiXPXW/">网格图</a>。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 热题 100-二叉树</title>
    <link href="/2024/12/04/posts/hot100-8/"/>
    <url>/2024/12/04/posts/hot100-8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-热题-100-二叉树"><a href="#LeetCode-热题-100-二叉树" class="headerlink" title="LeetCode 热题 100-二叉树"></a>LeetCode 热题 100-二叉树</h1><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/?envType=study-plan-v2&envId=top-100-liked">二叉树的中序遍历</a></h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-built_in">dfs</span>(root, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; ans)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, ans);<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, ans);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)，空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li></ul><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>采用迭代写法，需要借助栈结构来实现：</p><ul><li>前序遍历；出栈顺序：根-左-右；入栈顺序：右-左-根；</li><li>中序遍历；出栈顺序：左-根-右；入栈顺序：右-根-左；</li><li>后序遍历；出栈顺序：左-右-根；入栈顺序：根-右-左；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        stack&lt;TreeNode*&gt; stk;<br>        <span class="hljs-keyword">while</span>(root || !stk.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-comment">// 不断把左子树压入栈</span><br>            <span class="hljs-keyword">while</span>(root)&#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            <span class="hljs-comment">// 出栈，遍历</span><br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            root = root-&gt;right;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><ol><li>若 cur &#x3D;&#x3D; null，则过程停止，否则继续下面的过程；</li><li>若 cur 无左子树，则访问当前元素，并令 cur &#x3D; cur.right；</li><li>若 cur 有左子树，则找到 cur 左子树上最右的节点，记作 mostRight：<ul><li>若 mostRight.right &#x3D;&#x3D; null，则令 mostRight.right &#x3D; cur，即让 mostRight 的 right 指针指向当前节点 cur，然后令 cur &#x3D; cur.left；</li><li>若 mostRight.right &#x3D;&#x3D; cur， 说明我们已经遍历完的左子树，则访问当前元素，并令 mostRight.right &#x3D; null，即让 mostRight 的 right 指针指向空，然后令 cur &#x3D; cur.right。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span>(root)&#123;<br>            <span class="hljs-comment">// 左子树为空，遍历该节点，并继续遍历右子树</span><br>            <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">nullptr</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                root = root-&gt;right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 找到最右边的节点</span><br>                TreeNode* predecessor = root-&gt;left;<br>                <span class="hljs-keyword">while</span>(predecessor-&gt;right &amp;&amp; predecessor-&gt;right != root)&#123;<br>                    predecessor = predecessor-&gt;right;<br>                &#125;<br>                <span class="hljs-comment">// 如果它的右指针为空，则指向root，继续遍历左子树</span><br>                <span class="hljs-keyword">if</span>(predecessor-&gt;right == <span class="hljs-literal">nullptr</span>)&#123;<br>                    predecessor-&gt;right = root;<br>                    root = root-&gt;left;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">// 左子树已经遍历完，断开链接</span><br>                    ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                    predecessor-&gt;right = <span class="hljs-literal">nullptr</span>;<br>                    root = root-&gt;right;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，每个节点会被访问两次。</li><li>空间复杂度：O(1)</li></ul><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&envId=top-100-liked">二叉树的最大深度</a></h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>当前节点为空则返回0，否则递归计算左右子树最大深度，取较大值，再+1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)，此时树为一条链。</li></ul><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量 ans 来维护拓展的次数，该二叉树的最大深度即为 ans。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-comment">// 对当前层进行扩展</span><br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            ans += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)，队列消耗的空间。</li></ul><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/?envType=study-plan-v2&envId=top-100-liked">翻转二叉树</a></h2><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>root为空，则无需交换，直接返回。否则递归交换左右子树，然后再将左右子树交换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        TreeNode* left = <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        TreeNode* right = <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        root-&gt;left = right;<br>        root-&gt;right = left;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)，最坏情况下，树形成链状，空间复杂度为 O(N)。</li></ul><blockquote><p>[!NOTE]<br>之后再练练几种遍历的迭代和Morris写法。</p></blockquote><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/?envType=study-plan-v2&envId=top-100-liked">对称二叉树</a></h2><h3 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h3><p>检查左右子树是否相等:</p><ul><li>左右子树有一个为空，不相等；都为空，相等。</li><li>检查左右子树值以及左子树的右子树和右子树的左子树是否相等，以及左子树的左子树和右子树的右子树。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSameTree</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* leftTree, TreeNode* rightTree)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(leftTree == <span class="hljs-literal">nullptr</span> || rightTree == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> leftTree == rightTree;<br>        &#125;<br>        <span class="hljs-keyword">return</span> leftTree-&gt;val == rightTree-&gt;val &amp;&amp; <span class="hljs-built_in">isSameTree</span>(leftTree-&gt;right, rightTree-&gt;left) &amp;&amp; <span class="hljs-built_in">isSameTree</span>(leftTree-&gt;left, rightTree-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h3><p>用广度优先搜索的方法，如果当前左子树不等于右子树，直接返回false，否则按照左子树的左子树、右子树的右子树、左子树的右子树、右子树的左子树的顺序加入队列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root-&gt;left);<br>        que.<span class="hljs-built_in">push</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* leftTree = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            TreeNode* rightTree = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(leftTree == <span class="hljs-literal">nullptr</span> &amp;&amp; rightTree == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(leftTree == <span class="hljs-literal">nullptr</span> || rightTree == <span class="hljs-literal">nullptr</span> || leftTree-&gt;val != rightTree-&gt;val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            que.<span class="hljs-built_in">push</span>(leftTree-&gt;left);<br>            que.<span class="hljs-built_in">push</span>(rightTree-&gt;right);<br>            que.<span class="hljs-built_in">push</span>(leftTree-&gt;right);<br>            que.<span class="hljs-built_in">push</span>(rightTree-&gt;left);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/?envType=study-plan-v2&envId=top-100-liked">二叉树的直径</a></h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。</p><p>经过一个节点的最长路径应该等于它左子树的最大深度+右子树最大深度.即，dfs返回的是最大深度而不是直径，最大深度等于左子树深度和右子树深度的较大值+1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> maxLeft = <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> maxRight = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        ans = <span class="hljs-built_in">max</span>(ans, maxLeft + maxRight);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(maxLeft, maxRight) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/?envType=study-plan-v2&envId=top-100-liked">二叉树的层序遍历</a></h2><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>可以当做层序遍历的模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; cur;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                cur.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(cur);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/?envType=study-plan-v2&envId=top-100-liked">将有序数组转换为二叉搜索树</a></h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>将中点作为根节点，中点左侧作为左子树，右侧作为右子树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>());<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left == right)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid], <span class="hljs-built_in">dfs</span>(nums, left, mid), <span class="hljs-built_in">dfs</span>(nums, mid+<span class="hljs-number">1</span>, right));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(logn)</li></ul><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/?envType=study-plan-v2&envId=top-100-liked">验证二叉搜索树</a></h2><h3 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h3><p>对于一棵二叉树，如果其左子树不为空且节点值小于根节点，并且其右子树不为空且节点值大于根节点，递归左右子树也都满足，则是二叉搜索树。逻辑错误！只检查了当前节点与它的左右子节点的关系（根节点与直接左右子节点之间的比较），但对于整个树的有效性来说，还需要确保每个子树的节点都满足二叉搜索树的性质，也就是说子树的节点值必须大于它的左子树所有节点的值，且小于它的右子树所有节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(root, LONG_MIN, LONG_MAX);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">long</span> <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> <span class="hljs-type">long</span> upper)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt;= lower || root-&gt;val &gt;= upper)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(root-&gt;left, lower, root-&gt;val) &amp;&amp; <span class="hljs-built_in">helper</span>(root-&gt;right, root-&gt;val, upper);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 迭代实现中序遍历</span><br>        stack&lt;TreeNode*&gt; stk;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> inorder = LONG_MIN;<br><br>        <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || root != <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">nullptr</span>)&#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 判断中序遍历的当前节点值是否满足条件</span><br>            <span class="hljs-keyword">if</span>(root-&gt;val &lt;= inorder)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            inorder = root-&gt;val;<br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="二叉搜索树中第k小的元素"><a href="#二叉搜索树中第k小的元素" class="headerlink" title="二叉搜索树中第k小的元素"></a><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/?envType=study-plan-v2&envId=top-100-liked">二叉搜索树中第k小的元素</a></h2><h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>考虑中序遍历，用一个变量来计数，遍历到的第k个元素就是第k小的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; stk;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || root != <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">nullptr</span>)&#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 更新变量</span><br>            cnt++;<br>            <span class="hljs-keyword">if</span>(cnt == k)&#123;<br>                <span class="hljs-keyword">return</span> root-&gt;val;<br>            &#125;<br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>如果二叉搜索树经常被修改（插入&#x2F;删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？</p><p>平衡二叉搜索树具有如下性质：</p><ul><li>平衡二叉搜索树中每个结点的左子树和右子树的高度最多相差 1；</li><li>平衡二叉搜索树的子树也是平衡二叉搜索树；</li><li>一棵存有 n 个结点的平衡二叉搜索树的高度是 O(logn)。</li></ul><p>晚上再看二叉平衡树的做法。</p><p><a href="https://leetcode.cn/problems/balance-a-binary-search-tree/solutions/241897/jiang-er-cha-sou-suo-shu-bian-ping-heng-by-leetcod/">将二叉搜索树变平衡</a></p><h2 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/?envType=study-plan-v2&envId=top-100-liked">二叉树的右视图</a></h2><h3 id="深度优先搜索-1"><a href="#深度优先搜索-1" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>先递归右子树，再递归左子树，当某个深度首次到达时，对应的节点就在右视图中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> depth)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 某个深度首次达到</span><br>        <span class="hljs-keyword">if</span>(depth == ans.<span class="hljs-built_in">size</span>())&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        &#125;<br>        <span class="hljs-comment">// 先递归右子树，保证首次遇到的是最右边的节点</span><br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, depth + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="广度优先搜索-1"><a href="#广度优先搜索-1" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>用层序遍历的方法，但在每次放入队列节点时，先放入右子树节点，这样对每一层遍历时，取出的第一个节点就是最右边的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?envType=study-plan-v2&envId=top-100-liked">二叉树展开为链表</a></h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>很容易按照先序遍历的顺序链接成链表。用一个数组存放先序遍历的节点指针，然后对每一个节点，将其左子树置空，将其右子树置为下一个节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;TreeNode*&gt; vec;<br>        stack&lt;TreeNode*&gt; stk;<br>        TreeNode* node = root;<br>        <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || node)&#123;<br>            <span class="hljs-keyword">while</span>(node)&#123;<br>                vec.<span class="hljs-built_in">push_back</span>(node);    <span class="hljs-comment">// 先序遍历</span><br>                stk.<span class="hljs-built_in">push</span>(node);<br>                node = node-&gt;left;<br>            &#125;<br>            node = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            node = node-&gt;right;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            vec[i<span class="hljs-number">-1</span>]-&gt;left = <span class="hljs-literal">nullptr</span>;<br>            vec[i<span class="hljs-number">-1</span>]-&gt;right = vec[i];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><p>按照右子树 - 左子树 - 根的顺序 DFS 这棵树。DFS 的同时，记录当前链表的头节点为 head。一开始 head 是空节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* head;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 递归右子树、左子树</span><br>        <span class="hljs-built_in">flatten</span>(root-&gt;right);<br>        <span class="hljs-built_in">flatten</span>(root-&gt;left);<br>        <span class="hljs-comment">// 头插法</span><br>        root-&gt;left = <span class="hljs-literal">nullptr</span>;<br>        root-&gt;right = head;<br>        head = root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="寻找前驱节点"><a href="#寻找前驱节点" class="headerlink" title="寻找前驱节点"></a>寻找前驱节点</h3><p>对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;left)&#123;<br>                TreeNode* next = cur-&gt;left;<br>                <span class="hljs-comment">// 找到最右边的节点</span><br>                TreeNode* pre = next;<br>                <span class="hljs-keyword">while</span>(pre-&gt;right)&#123;<br>                    pre = pre-&gt;right;<br>                &#125;<br>                <span class="hljs-comment">// 当前节点右子树赋给前驱节点右子树</span><br>                pre-&gt;right = cur-&gt;right;<br>                cur-&gt;left = <span class="hljs-literal">nullptr</span>;<br>                cur-&gt;right = next;<br>            &#125;<br>            cur = cur-&gt;right;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?envType=study-plan-v2&envId=top-100-liked">从前序与中序遍历序列构造二叉树</a></h2><h3 id="递归-5"><a href="#递归-5" class="headerlink" title="递归"></a>递归</h3><p>利用递归和分治策略，通过遍历数组的信息来确定二叉树的结构。用哈希表预处理中序遍历的数组，这样之后可以在O(1)的时间内找到它。从 Preorder 中可以直接确定子树的根节点，而通过 Inorder 可以确定根节点在整棵树中的位置，从而区分左子树和右子树的范围。</p><p>二叉树的根节点是 Preorder 的第一个元素。在 Inorder 中找到根节点的位置：</p><pre><code class="hljs">该位置的左侧为左子树的元素。该位置的右侧为右子树的元素。</code></pre><p>根据子树的大小（Inorder 左侧元素个数）确定 Preorder 中对应的子树范围，递归处理。当当前的子树范围为空时，返回空指针。</p><p>总结为：</p><ol><li>确定根节点</li><li>划分左右子树</li><li>构建左右子树</li><li>连接子树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = preorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 哈希表预处理中序数组</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            hash[inorder[i]] = i;<br>        &#125;<br><br>        <span class="hljs-comment">// 定义递归函数处理</span><br>        function&lt;TreeNode*(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;] (<span class="hljs-type">int</span> preLeft, <span class="hljs-type">int</span> preRight, <span class="hljs-type">int</span> inLeft, <span class="hljs-type">int</span> inRight) -&gt; TreeNode* &#123;<br>            <span class="hljs-comment">// 递归结束</span><br>            <span class="hljs-keyword">if</span>(preLeft == preRight)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>             <span class="hljs-comment">// O(1)时间在中序遍历中找到根节点</span><br>            <span class="hljs-type">int</span> leftSize = hash[preorder[preLeft]] - inLeft;<br>            <span class="hljs-comment">// 递归遍历左右子树</span><br>            TreeNode* leftTree = <span class="hljs-built_in">dfs</span>(preLeft+<span class="hljs-number">1</span>, preLeft+<span class="hljs-number">1</span>+leftSize, inLeft, inLeft+leftSize);<br>            TreeNode* rightTree = <span class="hljs-built_in">dfs</span>(preLeft+<span class="hljs-number">1</span>+leftSize, preRight, inLeft+leftSize+<span class="hljs-number">1</span>, inRight);<br>            <span class="hljs-comment">// 连接子树</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[preLeft], leftTree, rightTree);<br>        &#125;;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, n, <span class="hljs-number">0</span>, n);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="迭代-3"><a href="#迭代-3" class="headerlink" title="迭代"></a>迭代</h3><ul><li>用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</li><li>依次枚举前序遍历中除了第一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 index，并将当前节点作为最后一个弹出的节点的右儿子；如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</li><li>无论是哪一种情况，我们最后都将当前的节点入栈。</li></ul><p>看不太明白……</p><h2 id="路径总和III"><a href="#路径总和III" class="headerlink" title="路径总和III"></a><a href="https://leetcode.cn/problems/path-sum-iii/?envType=study-plan-v2&envId=top-100-liked">路径总和III</a></h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><ol><li>定义 rootSum(p,val) 表示以节点 p 为起点向下且满足路径总和为 val 的路径数目。对二叉树上每个节点 p 求出 rootSum(p,targetSum)，然后对这些路径数目求和即为返回结果。</li><li>对节点 p 求 rootSum(p,targetSum) 时，以当前节点 p 为目标路径的起点递归向下进行搜索。对左子树和右子树进行递归搜索。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 对每一个节点都要遍历</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-built_in">rootSum</span>(root, targetSum);<br>        <span class="hljs-comment">// 不包含当前节点</span><br>        ans += <span class="hljs-built_in">pathSum</span>(root-&gt;left, targetSum);<br>        ans += <span class="hljs-built_in">pathSum</span>(root-&gt;right, targetSum);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rootSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;val == targetSum)&#123;<br>            res++;<br>        &#125;<br><br>        res += <span class="hljs-built_in">rootSum</span>(root-&gt;left, targetSum - root-&gt;val);<br>        res += <span class="hljs-built_in">rootSum</span>(root-&gt;right, targetSum - root-&gt;val);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(n)，递归栈空间。</li></ul><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><ol><li>遍历每个节点，更新当前路径的前缀和。</li><li>检查哈希表中是否存在满足条件的前缀和，如果存在，累加路径数。注意哈希表初始时应把0加入，要想把任意路径和都表示成两个前缀和的差，必须添加一个 0，否则当路径是前缀时（从根节点开始的路径），没法减去一个数。</li><li>递归左右子树。</li><li>回溯时移除当前节点路径和，恢复状态。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; cnt&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>        function&lt;<span class="hljs-type">void</span>(TreeNode*, <span class="hljs-type">long</span> <span class="hljs-type">long</span>)&gt; dfs = [&amp;] (TreeNode* node, <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum) &#123;<br>            <span class="hljs-comment">// 递归结束</span><br>            <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            sum += node-&gt;val;<br>            <span class="hljs-comment">// 查找是否存在</span><br>            ans += cnt.<span class="hljs-built_in">contains</span>(sum - targetSum) ? cnt[sum - targetSum] : <span class="hljs-number">0</span>;<br>            cnt[sum]++;<br>            <span class="hljs-comment">// 递归左右子树</span><br>            <span class="hljs-built_in">dfs</span>(node-&gt;left, sum);<br>            <span class="hljs-built_in">dfs</span>(node-&gt;right, sum);<br>            <span class="hljs-comment">// 还原</span><br>            cnt[sum]--;<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked">二叉树的最近公共祖先</a></h2><h3 id="递归-6"><a href="#递归-6" class="headerlink" title="递归"></a>递归</h3><p><img src="/2024/12/04/posts/hot100-8/image.png" alt="Alt text"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回当前节点</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span> || root == p || root == q)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">// 在左右子树中查找</span><br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br><br>        <span class="hljs-comment">// 左右都找到了，则说明当前节点是最近公共祖先</span><br>        <span class="hljs-keyword">if</span>(left &amp;&amp; right)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-comment">// 否则返回一棵子树的结果</span><br>        <span class="hljs-keyword">return</span> left ? left : right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/?envType=study-plan-v2&envId=top-100-liked">二叉树中的最大路径和</a></h2><h3 id="递归-7"><a href="#递归-7" class="headerlink" title="递归"></a>递归</h3><p>如果当前节点为空，返回0.定义函数dfs用于计算从某个节点到叶子节点的路径和，它等于左子树最大路径和和右子树最大路径和的较大值再+1.函数内部更新全局最大路径和，当前路径和等于左子树最大路径和+右子树最大路径和+当前节点值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = INT_MIN;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 递归计算左右子树</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(root-&gt;left), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(root-&gt;right), <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 更新答案</span><br>        ans = <span class="hljs-built_in">max</span>(ans, left + right + root-&gt;val);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + root-&gt;val;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二叉树部分的题目之前大部分都做过，但是在思考递归时还是有些混乱，要经常复习。遗留问题：二叉平衡树，二叉树的迭代+Morris遍历。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 热题 100-链表</title>
    <link href="/2024/11/29/posts/hot100-7/"/>
    <url>/2024/11/29/posts/hot100-7/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-热题-100-链表"><a href="#LeetCode-热题-100-链表" class="headerlink" title="LeetCode 热题 100-链表"></a>LeetCode 热题 100-链表</h1><h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&envId=top-100-liked">相交链表</a></h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p><img src="/2024/11/29/posts/hot100-7/image.png" alt="相交链表"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-comment">// 初始化两个指针</span><br>        ListNode* p = headA;<br>        ListNode* q = headB;<br>        <span class="hljs-comment">// 循环直至p==q</span><br>        <span class="hljs-keyword">while</span>(p != q)&#123;<br>            <span class="hljs-comment">// p、q向后走</span><br>            p = p ? p-&gt;next : headB;<br>            q = q ? q-&gt;next : headA;<br>        &#125;<br>        <span class="hljs-comment">// 相交，则走到相交起始节点处；不相交，都走到空</span><br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(1)</li></ul><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/?envType=study-plan-v2&envId=top-100-liked">反转链表</a></h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode* next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>如果当前链表为空，或者只剩下一个未反转，直接返回head。否则，先递归反转后续的所有节点，得到反转后的头，就是该链表新的头。再将当前节点next的next指向当前节点，注意将当前节点的next置空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 递归反转后边的节点</span><br>        ListNode* newHead = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/?envType=study-plan-v2&envId=top-100-liked">回文链表</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>先将链表从中间分开，然后反转后半部分链表，再一一比较两个链表的节点。从中间分开可以用快慢指针，即慢指针走一步，快指针走两步，当快指针走到最后时，慢指针刚好指向中间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 找到中点</span><br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast)&#123;<br>                fast = fast-&gt;next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 反转链表</span><br>        ListNode* mid = slow;<br>        ListNode* half = <span class="hljs-built_in">reverseList</span>(mid);<br>        <span class="hljs-keyword">while</span>(half)&#123;<br>            <span class="hljs-keyword">if</span>(head-&gt;val != half-&gt;val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            head = head-&gt;next;<br>            half = half-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 反转链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode* next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a><a href="https://leetcode.cn/problems/reorder-list/description/">重排链表</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>和上题思路一样，找到中点，将后半部分反转，注意将中间断开，然后按照归并排序合并的方法重组链表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 找到中点</span><br>        ListNode* mid = <span class="hljs-built_in">findMid</span>(head);<br>        <span class="hljs-comment">// 逆转后半部分</span><br>        ListNode* half = <span class="hljs-built_in">reverseList</span>(mid);<br>        <span class="hljs-comment">// 合并</span><br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span>(half-&gt;next)&#123;<br>            ListNode* n1 = cur-&gt;next;<br>            ListNode* n2 = half-&gt;next;<br>            cur-&gt;next = half;<br>            half-&gt;next = n1;<br>            cur = n1;<br>            half = n2;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到中点</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">findMid</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-comment">// 反转链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode* next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked">环形链表</a></h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>定义快慢指针，如果两指针能够相遇，则说明存在环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br><br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-keyword">if</span>(slow == fast)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/?envType=study-plan-v2&envId=top-100-liked">环形链表II</a></h2><h3 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>假设入环点距链表头为a，相遇点距入环点为b，相遇点到最后是c，则有<code>a + n(b + c) = 2(a + b)</code>，得到<code>a = c + (n-1)(b+c)</code>，即从链表头到入环点的距离等于从相遇点出发走了n-1次环的距离，即如果定义一个指针从链表头出发，一个指针从相遇点出发，每次都向后走一步，他们最终会相遇，相遇的地点就是入环点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br><br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-comment">// 存在环</span><br>            <span class="hljs-keyword">if</span>(slow == fast)&#123;<br>                ListNode* ptr = head;<br>                <span class="hljs-keyword">while</span>(ptr != slow)&#123;<br>                    ptr = ptr-&gt;next;<br>                    slow = slow-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> ptr;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，在最初判断快慢指针是否相遇时，slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度。</li><li>空间复杂度：O(1)</li></ul><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/?envType=study-plan-v2&envId=top-100-liked">合并两个有序链表</a></h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>不断比较两链表的节点值，将较小的节点加入新链表，继续向后遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* cur = dummy;<br><br>        <span class="hljs-keyword">while</span>(list1 &amp;&amp; list2)&#123;<br>            <span class="hljs-keyword">if</span>(list1-&gt;val &lt; list2-&gt;val)&#123;<br>                cur-&gt;next = list1;<br>                list1 = list1-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur-&gt;next = list2;<br>                list2 = list2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">// 链接剩余部分</span><br>        <span class="hljs-keyword">while</span>(list1)&#123;<br>            cur-&gt;next = list1;<br>            list1 = list1-&gt;next;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(list2)&#123;<br>            cur-&gt;next = list2;<br>            list2 = list2-&gt;next;<br>            cur = cur-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(1)</li></ul><h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/?envType=study-plan-v2&envId=top-100-liked">两数相加</a></h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>模拟从个位加到最高位即可，注意维护进位标志，如果最后的进位是1，还需要再加一个新节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* cur = dummy;<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(l1 &amp;&amp; l2)&#123;<br>            <span class="hljs-type">int</span> sum = l1-&gt;val + l2-&gt;val + carry;<br>            carry = sum / <span class="hljs-number">10</span>;<br>            ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            cur-&gt;next = node;<br>            cur = cur-&gt;next;<br>            l1 = l1-&gt;next;<br>            l2 = l2-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">// 剩余部分</span><br>        <span class="hljs-keyword">while</span>(l1)&#123;<br>            <span class="hljs-type">int</span> sum = l1-&gt;val + carry;<br>            carry = sum / <span class="hljs-number">10</span>;<br>            ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            cur-&gt;next = node;<br>            cur = cur-&gt;next;<br>            l1 = l1-&gt;next;            <br>        &#125;<br>        <span class="hljs-keyword">while</span>(l2)&#123;<br>            <span class="hljs-type">int</span> sum = l2-&gt;val + carry;<br>            carry = sum / <span class="hljs-number">10</span>;<br>            ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            cur-&gt;next = node;<br>            cur = cur-&gt;next;<br>            l2 = l2-&gt;next;            <br>        &#125;<br>        <span class="hljs-comment">// 判断进位</span><br>        <span class="hljs-keyword">if</span>(carry)&#123;<br>            ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(carry);<br>            cur-&gt;next = node;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，n为两链表长度的较大值。</li><li>空间复杂度：O(1)，不计入返回结果的空间复杂度。</li></ul><h2 id="删除链表的倒数第n个结点"><a href="#删除链表的倒数第n个结点" class="headerlink" title="删除链表的倒数第n个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/?envType=study-plan-v2&envId=top-100-liked">删除链表的倒数第n个结点</a></h2><h3 id="快慢指针-2"><a href="#快慢指针-2" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>最简单的方法是遍历一遍链表，得到链表的长度，然后从头走len-n步即找到倒数第n个节点。考虑只遍历一次链表：让一个指针先走n步，然后两指针同时走，当先走的指针走到空时，即它又走了len-n步，那么从头出发的指针也走了len-n步，它所指向的就是倒数第n个结点。这样能够找到要删除的节点，但是要删除节点，应该找到它的前一个节点。为了方便处理删除头结点的情况，定义一个哑节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义哑节点，方便处理要删除的节点是头结点</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next = head;<br><br>        <span class="hljs-comment">// 先走n步</span><br>        ListNode* fast = dummy;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            fast = fast-&gt;next;<br>        &#125;<br><br>        <span class="hljs-comment">// 同时走，找到要删除的节点的前一个节点</span><br>        ListNode* slow = dummy;<br>        <span class="hljs-keyword">while</span>(fast-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        slow-&gt;next = slow-&gt;next-&gt;next;  <span class="hljs-comment">// 删除节点</span><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>如果要delete这个结点，可以先将它保存，再delete掉。</p><h2 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/?envType=study-plan-v2&envId=top-100-liked">两两交换链表中的节点</a></h2><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>定义哑节点方便操作，作为pre，定义当前指针left和下一个指针right，同时保存再下一个指针next，先让pre-&gt;next指向right，right-&gt;next指向left，left-&gt;next指向next。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next = head;<br>        ListNode* pre = dummy;<br>        ListNode* left = head;<br><br>        <span class="hljs-comment">// 至少要有两个节点</span><br>        <span class="hljs-keyword">while</span>(left &amp;&amp; left-&gt;next)&#123;<br>            ListNode* right = left-&gt;next;<br>            ListNode* next = right-&gt;next;<br>            pre-&gt;next = right;<br>            right-&gt;next = left;<br>            left-&gt;next = next;<br><br>            pre = left;<br>            left = next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>递归结束：head为空或者head-&gt;next为空，返回head。</p><p>否则，先交换后面的链表，即递归调用<code>swapPairs(head-&gt;next-&gt;next)</code>，然后将head-&gt;next指向返回的链表头，而原来的next指向head，再返回next。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode* suff = <span class="hljs-built_in">swapPairs</span>(head-&gt;next-&gt;next);<br>        ListNode* newHead = head-&gt;next;<br>        head-&gt;next = suff;<br>        newHead-&gt;next = head;<br>        <br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="k个一组翻转链表"><a href="#k个一组翻转链表" class="headerlink" title="k个一组翻转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group?envType=study-plan-v2&envId=top-100-liked">k个一组翻转链表</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>首先统计链表节点个数，然后k 个一组处理，</p><p><img src="/2024/11/29/posts/hot100-7/image-1.png" alt="Alt text"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 统计结点个数</span><br>        <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            n++;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        ListNode* p0 = dummy;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        cur = head;<br><br>        <span class="hljs-keyword">for</span>(; n &gt;= k; n-= k)&#123;<br>            <span class="hljs-comment">// k个一组翻转链表</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>                ListNode* nxt = cur-&gt;next;<br>                cur-&gt;next = pre;<br>                pre = cur;<br>                cur = nxt;<br>            &#125;<br><br>            <span class="hljs-comment">// 重新链接</span><br>            ListNode* nxt = p0-&gt;next;<br>            nxt-&gt;next = cur;<br>            p0-&gt;next = pre;<br>            p0 = nxt;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/?envType=study-plan-v2&envId=top-100-liked">随机链表的复制</a></h2><h3 id="回溯-哈希表"><a href="#回溯-哈希表" class="headerlink" title="回溯+哈希表"></a>回溯+哈希表</h3><p>定义一个哈希表，用于存储节点的副本，如果这个节点已经存在，就直接返回，如果不存在，就复制一份，然后递归复制它的next和random。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;Node*, Node*&gt; cache;    <span class="hljs-comment">// 哈希表</span><br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果不存在，就创建</span><br>        <span class="hljs-keyword">if</span>(!cache.<span class="hljs-built_in">count</span>(head))&#123;<br>            Node* newHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head-&gt;val);<br>            cache[head] = newHead;<br>            <span class="hljs-comment">// 递归创建指针副本</span><br>            newHead-&gt;next = <span class="hljs-built_in">copyRandomList</span>(head-&gt;next);<br>            newHead-&gt;random = <span class="hljs-built_in">copyRandomList</span>(head-&gt;random);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cache[head];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n),其中 n 是链表的长度。对于每个节点，我们至多访问其「后继节点」和「随机指针指向的节点」各一次，均摊每个点至多被访问两次。</li><li>空间复杂度：O(n)，哈希表空间开销。</li></ul><h3 id="迭代-节点拆分"><a href="#迭代-节点拆分" class="headerlink" title="迭代+节点拆分"></a>迭代+节点拆分</h3><ol><li>把每个节点复制一份链接在原节点的后边。</li><li>复制节点的random就是原节点的random的next。</li><li>分离链表。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(!head)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">// 复制链表节点</span><br>        <span class="hljs-keyword">for</span>(Node* cur = head; cur != <span class="hljs-literal">NULL</span>; cur = cur-&gt;next-&gt;next)&#123;<br>            cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur-&gt;val, cur-&gt;next, <span class="hljs-literal">NULL</span>);    <span class="hljs-comment">// random暂时置空</span><br>        &#125;<br><br>        <span class="hljs-comment">// 链接random</span><br>        <span class="hljs-keyword">for</span>(Node* cur = head; cur; cur = cur-&gt;next-&gt;next)&#123;<br>            <span class="hljs-comment">// 注意cur-&gt;random需要不为空才能这样操作</span><br>            <span class="hljs-keyword">if</span>(cur-&gt;random)&#123;<br>                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;<br>            &#125;      <br>        &#125;<br><br>        <span class="hljs-comment">// 分离链表</span><br>        Node* newHead = head-&gt;next;<br>        <span class="hljs-keyword">for</span>(Node* cur = head; cur; cur = cur-&gt;next)&#123;<br>            Node* copy = cur-&gt;next;<br>            cur-&gt;next = copy-&gt;next;<br>            <span class="hljs-comment">// 需要注意copy的next不能为空</span><br>            copy-&gt;next = copy-&gt;next ? copy-&gt;next-&gt;next : <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)，不计入返回值。</li></ul><h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a><a href="https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&envId=top-100-liked">排序链表</a></h2><h3 id="归并排序（递归）"><a href="#归并排序（递归）" class="headerlink" title="归并排序（递归）"></a>归并排序（递归）</h3><ol><li>分割环节：找到链表中心链节点，从中心节点将链表断开，并递归进行分割。</li><li>归并环节：将递归后的链表进行两两归并，完成一遍后每个子链表长度加倍。重复进行归并操作，直到得到完整的链表。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeSort</span>(head);<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeSort</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 先找到链表的中间结点的前一个节点</span><br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 断开链接</span><br>        ListNode* mid = slow-&gt;next;<br>        slow-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br>        ListNode* left = head;<br>        ListNode* right = mid;<br><br>        <span class="hljs-comment">// 递归排序两部分并合并</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">mergeSort</span>(left), <span class="hljs-built_in">mergeSort</span>(right));<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* left, ListNode* right)</span></span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* cur = dummy;<br>        <span class="hljs-keyword">while</span>(left &amp;&amp; right)&#123;<br>            <span class="hljs-keyword">if</span>(left-&gt;val &lt; right-&gt;val)&#123;<br>                cur-&gt;next = left;<br>                left = left-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur-&gt;next = right;<br>                right = right-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 链接剩余部分</span><br>        cur-&gt;next = left ? left : right;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)，递归需要 O(logn) 的栈开销。</li></ul><h3 id="归并排序（迭代）"><a href="#归并排序（迭代）" class="headerlink" title="归并排序（迭代）"></a>归并排序（迭代）</h3><p>具体算法：</p><ol><li>遍历链表，获取链表长度 length。</li><li>初始化步长 step&#x3D;1。</li><li>循环直到 step≥length。</li><li>每轮循环，从链表头节点开始。</li><li>分割出两段长为 step 的链表，合并，把合并后的链表插到新链表的末尾。重复该步骤，直到链表遍历完毕。</li><li>把 step 扩大一倍。回到第 4 步。</li></ol><p>迭代的方法有些难理解，晚上有时间再看吧。</p><h2 id="合并k个有序链表"><a href="#合并k个有序链表" class="headerlink" title="合并k个有序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/?envType=study-plan-v2&envId=top-100-liked">合并k个有序链表</a></h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>如果只剩一个链表，就结束递归。然后合并两个链表，按照归并排序的方式合并。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = lists.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeSort</span>(lists, <span class="hljs-number">0</span>, k<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(left == right)&#123;<br>            <span class="hljs-keyword">return</span> lists[left];<br>        &#125;<br>        <span class="hljs-comment">// 递归合并</span><br>        <span class="hljs-type">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">mergeSort</span>(lists, left, mid), <span class="hljs-built_in">mergeSort</span>(lists, mid+<span class="hljs-number">1</span>, right));<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* leftList, ListNode* rightList)</span></span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* cur = dummy;<br>        <span class="hljs-keyword">while</span>(leftList &amp;&amp; rightList)&#123;<br>            <span class="hljs-keyword">if</span>(leftList-&gt;val &lt; rightList-&gt;val)&#123;<br>                cur-&gt;next = leftList;<br>                leftList = leftList-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur-&gt;next = rightList;<br>                rightList = rightList-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        cur-&gt;next = leftList ? leftList : rightList;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogk)，其中 k 为 lists 的长度，n 为所有链表的节点数之和。每个节点参与链表合并的次数为 O(logk) 次，一共有 n 个节点，所以总的时间复杂度为 O(nlogk)。</li><li>空间复杂度：O(logk)，递归栈消耗的空间。</li></ul><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>维护当前每个链表没有被合并的元素的最前面一个，k 个链表就最多有 k 个满足这样条件的元素，每次在这些元素里面选取 val 属性最小的元素合并到答案中。在选取最小元素的时候，可以用优先队列来优化这个过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-comment">// 最小堆</span><br>        <span class="hljs-keyword">auto</span> cmp = [&amp;](<span class="hljs-type">const</span> ListNode* a, ListNode* b)&#123;<br>            <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;<br>        &#125;;<br>        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">heap</span>(cmp);<br>        <span class="hljs-comment">// 将每个链表的第一个节点放入最小堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> head : lists)&#123;<br>            <span class="hljs-keyword">if</span>(head) heap.<span class="hljs-built_in">push</span>(head);<br>        &#125;        <br><br>        <span class="hljs-comment">// 初始化一个哑节点</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* cur = dummy;<br><br>        <span class="hljs-keyword">while</span>(!heap.<span class="hljs-built_in">empty</span>())&#123;<br>            ListNode* node = heap.<span class="hljs-built_in">top</span>();<br>            heap.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(node-&gt;next)&#123;<br>                heap.<span class="hljs-built_in">push</span>(node-&gt;next);<br>            &#125;<br>            <span class="hljs-comment">// 将当前堆中最小节点链接到答案</span><br>            cur-&gt;next = node;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogk)，其中 k 为 lists 的长度，n 为所有链表的节点数之和。</li><li>空间复杂度：O(k)，最小堆中最多包含k个元素。</li></ul><h2 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a><a href="https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked">LRU缓存</a></h2><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="/2024/11/29/posts/hot100-7/image-2.png" alt="双向链表"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> value;<br>    Node* prev;<br>    Node* next;<br><br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> v = <span class="hljs-number">0</span>) : <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">value</span>(v) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) : <span class="hljs-built_in">capacity</span>(capacity) &#123;<br>        dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        dummy-&gt;prev = dummy;<br>        dummy-&gt;next = dummy;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        Node* node = <span class="hljs-built_in">getNode</span>(key);<br>        <span class="hljs-keyword">return</span> node ? node-&gt;value : <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        Node* node = <span class="hljs-built_in">getNode</span>(key);<br>        <span class="hljs-comment">// 如果已经存在，就更新value</span><br>        <span class="hljs-keyword">if</span>(node)&#123;<br>            node-&gt;value = value;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// new一个新节点加入哈希表</span><br>            hash[key] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>            <span class="hljs-built_in">pushFront</span>(hash[key]);<br>            <span class="hljs-comment">// 如果超出容量</span><br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">size</span>() &gt; capacity)&#123;<br>                <span class="hljs-comment">// 去掉最后一本书</span><br>                Node* backNode = dummy-&gt;prev;<br>                hash.<span class="hljs-built_in">erase</span>(backNode-&gt;key);<br>                <span class="hljs-built_in">remove</span>(backNode);<br>                <span class="hljs-keyword">delete</span> backNode;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> capacity;<br>    Node* dummy;<br>    unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; hash;<br><br>    <span class="hljs-comment">// 删除一个节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node* x)</span></span>&#123;<br>        x-&gt;prev-&gt;next = x-&gt;next;<br>        x-&gt;next-&gt;prev = x-&gt;prev;<br>    &#125;<br><br>    <span class="hljs-comment">// 在链表头添加一个节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushFront</span><span class="hljs-params">(Node* x)</span></span>&#123;<br>        x-&gt;prev = dummy;<br>        x-&gt;next = dummy-&gt;next;<br>        x-&gt;prev-&gt;next = x;<br>        x-&gt;next-&gt;prev = x;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取key对应的节点，同时移到表头</span><br>    <span class="hljs-function">Node* <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">auto</span> it = hash.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-comment">// 如果不存在</span><br>        <span class="hljs-keyword">if</span>(it == hash.<span class="hljs-built_in">end</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        Node* node = it-&gt;second;<br>        <span class="hljs-built_in">remove</span>(node);   <span class="hljs-comment">// 移出</span><br>        <span class="hljs-built_in">pushFront</span>(node);    <span class="hljs-comment">// 放到最上面</span><br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：所有操作均为 O(1)。</li><li>空间复杂度：O(min(p,capacity))，其中 p 为 put 的调用次数。</li></ul><p>之后有时间可以练一下<a href="https://leetcode.cn/problems/lfu-cache/description/">LFU缓存</a>。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 热题 100-矩阵</title>
    <link href="/2024/11/27/posts/hot100-6/"/>
    <url>/2024/11/27/posts/hot100-6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-热题-100-矩阵"><a href="#LeetCode-热题-100-矩阵" class="headerlink" title="LeetCode 热题 100-矩阵"></a>LeetCode 热题 100-矩阵</h1><h2 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a><a href="https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-100-liked">矩阵置零</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>一个直观的解决方案是使用  O(mn) 的额外空间：即用一个$m \times n$的数组保存原数组。</li><li>一个简单的改进方案是使用 O(m + n) 的额外空间：即用两个标记数组分别记录每一行和每一列是否有零出现。</li></ul><p>可以用矩阵的第一行和第一列代替方法一中的两个标记数组，以达到 O(1) 的额外空间。但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 0。因此我们需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 0。首先预处理出两个标记变量，接着使用其他行与列去处理第一行与第一列，然后反过来使用第一行与第一列去更新其他行与列，最后使用两个标记变量更新第一行与第一列即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> col0 = <span class="hljs-literal">false</span>, row0 = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 初始化两个变量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)&#123;<br>                col0 = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>)&#123;<br>                row0 = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化第一行和第一列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>)&#123;<br>                    matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                    matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 置0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(!matrix[i][<span class="hljs-number">0</span>] || !matrix[<span class="hljs-number">0</span>][j])&#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 处理第一行和第一列</span><br>        <span class="hljs-keyword">if</span>(col0)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(row0)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(1)</li></ul><p>这是世界上最无聊的题目。</p><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-100-liked">螺旋矩阵</a></h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>对矩阵进行模拟，每次更新边界位置，初始时向右走，当i &#x3D;&#x3D; right，开始调整方向向下走，此时对i进行枚举，当i &#x3D;&#x3D; down，调整方向向左走，枚举j，当i &#x3D;&#x3D; left，调整方向向上走，对i进行枚举，当i &#x3D;&#x3D; up，再次向右走。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-comment">// 定义边界</span><br>        <span class="hljs-type">int</span> up = <span class="hljs-number">0</span>, down = m<span class="hljs-number">-1</span>, left = <span class="hljs-number">0</span>, right = n<span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 向右走</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left; i &lt;= right; i++)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[up][i]);<br>            &#125;<br>            <span class="hljs-comment">// 向下走</span><br>            up += <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 判断边界</span><br>            <span class="hljs-keyword">if</span>(up &gt; down)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = up; i &lt;= down; i++)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[i][right]);<br>            &#125;<br>            <span class="hljs-comment">// 向左走</span><br>            right -= <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(right &lt; left)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = right; i &gt;= left; i--)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[down][i]);<br>            &#125;<br>            <span class="hljs-comment">// 向上走</span><br>            down -= <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(down &lt; up)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = down; i &gt;= up; i--)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[i][left]);<br>            &#125;<br>            <span class="hljs-comment">// 向右走</span><br>            left += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(1)，不计返回的答案数组。</li></ul><h2 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/?envType=study-plan-v2&envId=top-100-liked">旋转图像</a></h2><h3 id="模拟-1"><a href="#模拟-1" class="headerlink" title="模拟"></a>模拟</h3><p>对于位置(i,j)上的元素，其旋转后会放置在(j,n-i-1)的位置上，而原本(j,n-i-1)的位置上，会旋转到(n-i-1,n-j-1)；(n-i-1,n-j-1)会旋转到(n-j-1, i)，(n-j-1, i)会旋转到(i, j)。因此只需要一个临时变量存储循环中的元素即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>; j++)&#123;<br>                <span class="hljs-type">int</span> temp = matrix[i][j];<br>                matrix[i][j] = matrix[n-j<span class="hljs-number">-1</span>][i];<br>                matrix[n-j<span class="hljs-number">-1</span>][i] = matrix[n-i<span class="hljs-number">-1</span>][n-j<span class="hljs-number">-1</span>];<br>                matrix[n-i<span class="hljs-number">-1</span>][n-j<span class="hljs-number">-1</span>] = matrix[j][n-i<span class="hljs-number">-1</span>];<br>                matrix[j][n-i<span class="hljs-number">-1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(1)</li></ul><h3 id="置换-水平翻转"><a href="#置换-水平翻转" class="headerlink" title="置换+水平翻转"></a>置换+水平翻转</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 置换</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[j][i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 水平翻转</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n/<span class="hljs-number">2</span>; j++)&#123;<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[i][n-j<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(1)</li></ul><h2 id="搜索二维矩阵II"><a href="#搜索二维矩阵II" class="headerlink" title="搜索二维矩阵II"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/?envType=study-plan-v2&envId=top-100-liked">搜索二维矩阵II</a></h2><h3 id="Z字形查找"><a href="#Z字形查找" class="headerlink" title="Z字形查找"></a>Z字形查找</h3><p>z字形查找方法，从矩阵右上角进行搜索:</p><ul><li>matrix[i][j] &#x3D;&#x3D; target，搜索完成。</li><li>matrix[i][j] &gt; target，j–。</li><li>matrix[i][j] &lt; target，i++。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">// 初始化下标为右上角</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j] == target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &gt; target)&#123;<br>                j--;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                i++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>矩阵</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 热题 100-普通数组</title>
    <link href="/2024/11/26/posts/hot100-5/"/>
    <url>/2024/11/26/posts/hot100-5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-热题-100-普通数组"><a href="#LeetCode-热题-100-普通数组" class="headerlink" title="LeetCode 热题 100-普通数组"></a>LeetCode 热题 100-普通数组</h1><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked">最大子数组和</a></h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>划分阶段：按子数组结尾的位置划分阶段。</li><li>定义状态：dp[i]表示以nums[i]结尾的最大子数组和。</li><li>状态转移方程：dp[i] &#x3D; max(dp[i-1], 0) + nums[i]。</li><li>初始条件：dp[0] &#x3D; nums[0]。</li><li>返回结果：维护一个最大和变量。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> sum = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            sum = <span class="hljs-built_in">max</span>(sum, <span class="hljs-number">0</span>) + nums[i];<br>            ans = <span class="hljs-built_in">max</span>(ans, sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>终于能够不看提示和题解写出来了o(╥﹏╥)o，但是线段树的部分又忘了。</p><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>维护四个变量：</p><ul><li>lSum：以l为左端点的最大子段和，lSum要么等于左子区间的lSum，要么等于左子区间的iSum+右子区间的lSum，取较大值。</li><li>rSum：以r为右端点的最大子段和，rSum要么等于右子区间的rSum，要么等于右子区间的iSum+左子区间的rSum，取较大值。</li><li>mSum：[l,r]区间内的最大和，它要么等于左子区间的mSum，要么等于右子区间的mSum，要么横跨两区间，即左子区间的rSum + 右子区间的lSum，三者取较大值。</li><li>iSum：[l,r]区间的和，等于左子区间的iSum + 右子区间iSum。</li></ul><ol><li>用结构体定义线段树的这4个状态；</li><li>定义线段树的pushup操作：即给定状态left和right，计算合并后的状态。</li><li>定义获取子区间的和的函数：给定数组和左右下标，递归计算左右子区间状态，返回合并后的状态。</li><li>返回结果：get(nums, 0, nums.size() - 1).mSum;</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Status</span>&#123;<br>        <span class="hljs-type">int</span> lSum, rSum, mSum, iSum;<br>    &#125;;<br><br>    <span class="hljs-comment">// 定义线段树的pushup操作</span><br>    <span class="hljs-function">Status <span class="hljs-title">pushUp</span><span class="hljs-params">(Status left, Status right)</span></span>&#123;<br>        <span class="hljs-type">int</span> lSum = <span class="hljs-built_in">max</span>(left.lSum, left.iSum + right.lSum);<br>        <span class="hljs-type">int</span> rSum = <span class="hljs-built_in">max</span>(right.rSum, right.iSum + left.rSum);<br>        <span class="hljs-type">int</span> mSum = <span class="hljs-built_in">max</span>(&#123;left.mSum, right.mSum, left.rSum + right.lSum&#125;);<br>        <span class="hljs-type">int</span> iSum = left.iSum + right.iSum;<br><br>        <span class="hljs-keyword">return</span> (Status)&#123;lSum, rSum, mSum, iSum&#125;; <br>    &#125;<br>    <span class="hljs-comment">// 获取区间和</span><br>    <span class="hljs-function">Status <span class="hljs-title">get</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(left == right)&#123;<br>            <span class="hljs-keyword">return</span> (Status)&#123;nums[left], nums[left], nums[left], nums[left]&#125;;<br>        &#125;<br><br>        <span class="hljs-comment">// 递归计算左右子区间</span><br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        Status lSub = <span class="hljs-built_in">get</span>(nums, left, mid);<br>        Status rSub = <span class="hljs-built_in">get</span>(nums, mid+<span class="hljs-number">1</span>, right);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pushUp</span>(lSub, rSub);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>).mSum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，把递归的过程看作是一颗二叉树的先序遍历。</li><li>空间复杂度：O(logn)，递归会使用 O(logn) 的栈空间，故渐进空间复杂度为 O(logn)。</li></ul><h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/?envType=study-plan-v2&envId=top-100-liked">合并区间</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>先将所有区间安装起始时间升序排序，将第一个区间放入结果集，然后逐个遍历区间，如果当前区间的开始时间小于等于结果集中最后一个区间的结束时间，则将两区间合并，修改前一个区间的结束时间为两个区间结束时间的较大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 排序</span><br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>());<br>        ans.<span class="hljs-built_in">push_back</span>(intervals[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 逐个遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-comment">// 合并区间</span><br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &lt;= ans.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>])&#123;<br>                ans.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(intervals[i][<span class="hljs-number">1</span>], ans.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(intervals[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)，排序消耗的时间。</li><li>空间复杂度：O(logn)，结果不计入，排序所需要的空间复杂度。</li></ul><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p>排序小技巧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 假如按照第1个数排序</span><br><span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b) &#123;<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a><a href="https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&envId=top-100-liked">轮转数组</a></h2><h3 id="直观解法"><a href="#直观解法" class="headerlink" title="直观解法"></a>直观解法</h3><p>(下标 + k) % n就是新的位置。但是不能直接进行赋值，因为会覆盖还没有经过轮转的数字。可以用一个额外的数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; arr = nums;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> index = (i + k) % n;<br>            nums[index] = arr[i];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="逆转数组"><a href="#逆转数组" class="headerlink" title="逆转数组"></a>逆转数组</h3><p>考虑将数组逆转，然后对于0<del>k-1及k</del>n-1的位置再进行逆转。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">begin</span>() + (k % n));<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + (k % n), nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>上面的解法是根据力扣提示做出来的，最后一个提示没太明白。</p><h3 id><a href="#" class="headerlink" title></a></h3><p>将元素放置在其正确的位置，并在附加变量中跟踪已经存在的元素或被覆盖的元素。</p><p>从位置 0 开始，最初令 temp&#x3D;nums[0]。根据规则，位置 0 的元素会放至 (0+k)modn 的位置，令 x&#x3D;(0+k)modn，此时交换 temp 和 nums[x]，完成位置 x 的更新。然后，我们考察位置 x，并交换 temp 和 nums[(x+k)modn]，从而完成下一个位置的更新。不断进行上述过程，直至回到初始位置 0。</p><p>从 0 开始不断遍历，最终回到起点 0 的过程中，我们遍历了多少个元素？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        k = k % n;<br>        <span class="hljs-type">int</span> count = <span class="hljs-built_in">gcd</span>(k, n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; start &lt; count; start++)&#123;<br>            <span class="hljs-type">int</span> cur = start;<br>            <span class="hljs-type">int</span> prev = nums[start];<br>            <span class="hljs-keyword">do</span>&#123;<br>                <span class="hljs-type">int</span> next = (cur + k) % n;<br>                <span class="hljs-built_in">swap</span>(prev, nums[next]);<br>                cur = next;<br>            &#125;<span class="hljs-keyword">while</span>(start != cur);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>这种解法不太好理解，之后再好好想想。</p><h2 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/?envType=study-plan-v2&envId=top-100-liked">除自身以外数组的乘积</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>计算前缀积和后缀积即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">suffix</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            prefix[i] = prefix[i<span class="hljs-number">-1</span>] * nums[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            suffix[i] = suffix[i+<span class="hljs-number">1</span>] * nums[i+<span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            ans[i] = prefix[i] * suffix[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="优化空间"><a href="#优化空间" class="headerlink" title="优化空间"></a>优化空间</h3><p>由于结果数组不计入空间复杂度，因此可以用结果数组直接保存前后缀积。即先计算后缀积，然后一边计算前缀积，一边得到最终结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">suffix</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            suffix[i] = suffix[i+<span class="hljs-number">1</span>] * nums[i+<span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            suffix[i] *= pre;<br>            pre *= nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> suffix;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a><a href="https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&envId=top-100-liked">缺失的第一个正数</a></h2><h3 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h3><p>对数组进行一次遍历，对于遍历到的数 x&#x3D;nums[i]，如果 x∈[1,N]，我们就知道 x 应当出现在数组中的 x−1 的位置，因此交换 nums[i] 和 nums[x−1]，这样 x 就出现在了正确的位置。在完成交换后，新的 nums[i] 可能还在 [1,N] 的范围内，我们需要继续进行交换操作，直到 $x \notin [1,N]$。</p><p>注意到上面的方法可能会陷入死循环。如果 nums[i] 恰好与 nums[x−1] 相等，那么就会无限交换下去。此时我们有 nums[i]&#x3D;x&#x3D;nums[x−1]，说明 x 已经出现在了正确的位置。因此我们可以跳出循环，开始遍历下一个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-comment">// 只考虑1~n之间的数，不断交换</span><br>            <span class="hljs-keyword">while</span>(nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i] - <span class="hljs-number">1</span>]); <br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找到不在位的数字</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != i + <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 热题 100-子串</title>
    <link href="/2024/11/25/posts/hot100-4/"/>
    <url>/2024/11/25/posts/hot100-4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-热题-100-子串"><a href="#LeetCode-热题-100-子串" class="headerlink" title="LeetCode 热题 100-子串"></a>LeetCode 热题 100-子串</h1><h2 id="和为k的子数组"><a href="#和为k的子数组" class="headerlink" title="和为k的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked">和为k的子数组</a></h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>数组不是单调的话，不要用滑动窗口，考虑用前缀和。前缀和i到j-1之间为<code>prefix[j] - prefix[i] = k</code>，即<code>prefix[i] = prefix[j] - k</code>，即遍历所有的j，统计prefix[i]出现的次数。</p><p>两次遍历做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 计算前缀和</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt;  <span class="hljs-title">prefix</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            prefix[i+<span class="hljs-number">1</span>] = prefix[i] + nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 统计次数</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> sj : prefix)&#123;<br>            ans += hash.<span class="hljs-built_in">contains</span>(sj - k) ? hash[sj - k] : <span class="hljs-number">0</span>;<br>            hash[sj]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>一次遍历：计算前缀和的同时遍历前缀和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, prefix = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 初始化哈希表</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-comment">// 一边计算前缀和，一边遍历前缀和</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : nums)&#123;<br>            prefix += x;<br>            ans += hash.<span class="hljs-built_in">contains</span>(prefix - k) ? hash[prefix - k] : <span class="hljs-number">0</span>;<br>            hash[prefix]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&envId=top-100-liked">滑动窗口最大值</a></h2><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p><img src="/2024/11/25/posts/hot100-4/image.png" alt="双端队列"></p><p>及时去掉无用数据，保证双端队列有序：</p><ol><li>入（元素进入队尾，同时维护队列单调性）</li><li>出（元素离开队首）</li><li>记录&#x2F;维护答案（根据队首）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        deque&lt;<span class="hljs-type">int</span>&gt; que;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-comment">// 入</span><br>            <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[que.<span class="hljs-built_in">back</span>()] &lt;= nums[i])&#123;<br>                que.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            que.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-comment">// 出</span><br>            <span class="hljs-keyword">if</span>(i - que.<span class="hljs-built_in">front</span>() + <span class="hljs-number">1</span> &gt; k)&#123;<br>                que.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            <span class="hljs-comment">// 记录答案</span><br>            <span class="hljs-keyword">if</span>(i &gt;= k<span class="hljs-number">-1</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums[que.<span class="hljs-built_in">front</span>()]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(min(k,U))，其中 U 是 nums 中的不同元素个数（本题至多为 20001）.</li></ul><h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked">最小覆盖子串</a></h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>维护一个s的窗口子串，如果它涵盖t中所有字符，就将左指针右移，即将最左边的元素移出窗口。判断涵盖t可以使用两个数组分别统计当前s和t的字符数情况，然后每次逐个字符判断，这样每次都要花费 O(∣Σ∣) 的时间去判断是否涵盖。因此可以用一个变量less代替，即目前子串中有 less 种字母的出现次数小于 t 中字母的出现次数。</p><ol><li>初始化左右指针。</li><li>用一个哈希表统计t的字符情况。</li><li>初始化left，并用一个哈希表统计s的情况。</li><li>初始化 less 为 t 中的不同字母个数。</li><li>遍历 s，设当前枚举的子串右端点为 right，把字母 c&#x3D;s[right] 的出现次数加一。加一后，如果 cntS[c]&#x3D;cntT[c]，说明 c 的出现次数满足要求，把 less 减一。</li><li>如果 less&#x3D;0，说明 cntS 中的每个字母及其出现次数都大于等于 cntT 中的字母出现次数，那么：<ul><li>更新最短子串长度；</li><li>滑动窗口左边界右移，更新cntS和less。</li><li>重复上述步骤直至less&gt;0.</li></ul></li><li>如果 ansLeft&lt;0，说明没有找到符合要求的子串，返回空字符串，否则返回下标 ansLeft 到下标 ansRight 之间的子串。</li></ol><p>可以把 cntS 和 cntT 合并成一个 cnt，定义cnt[x]&#x3D;cntT[x]−cntS[x]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> n = t.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> ansLeft = <span class="hljs-number">-1</span>, ansRight = m;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">128</span>]&#123;&#125;;<br>        <span class="hljs-type">int</span> less = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : t)&#123;<br>            <span class="hljs-keyword">if</span>(cnt[c] == <span class="hljs-number">0</span>)&#123;<br>                less++;<br>            &#125;<br>            cnt[c]++;<br>        &#125;<br><br>        <span class="hljs-comment">// 滑动窗口</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; m; right++)&#123;<br>            <span class="hljs-type">char</span> c = s[right];<br>            cnt[c]--;<br>            <span class="hljs-keyword">if</span>(cnt[c] == <span class="hljs-number">0</span>)&#123;<br>                less--;<br>            &#125;<br><br>            <span class="hljs-comment">// 窗口子串涵盖t，不断更新长度</span><br>            <span class="hljs-keyword">while</span>(less == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">if</span>(right - left &lt; ansRight - ansLeft)&#123;<br>                    ansLeft = left;<br>                    ansRight = right;<br>                &#125;<br>                <span class="hljs-type">char</span> x = s[left];   <span class="hljs-comment">// 左端点</span><br>                <span class="hljs-keyword">if</span>(cnt[x] == <span class="hljs-number">0</span>)&#123;<br>                    less++;         <span class="hljs-comment">// 移出之后不一样的字母会多</span><br>                &#125;<br>                cnt[x]++;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ansLeft &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;&quot;</span> : s.<span class="hljs-built_in">substr</span>(ansLeft, ansRight - ansLeft + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(∣Σ∣)</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>子串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 热题 100-滑动窗口</title>
    <link href="/2024/11/22/posts/hot100-3/"/>
    <url>/2024/11/22/posts/hot100-3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-热题-100-滑动窗口"><a href="#LeetCode-热题-100-滑动窗口" class="headerlink" title="LeetCode 热题 100-滑动窗口"></a>LeetCode 热题 100-滑动窗口</h1><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-100-liked">无重复字符的最长子串</a></h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>使用哈希表+滑动窗口。如果当前字符没有在哈希表中出现过，就将其加入哈希表，右指针继续向右，right-left+1是当前长度，不断更新最大长度；否则不断向右滑动左窗口，直至遇到哈希表内没有当前元素，再把当前元素加入哈希表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-comment">// 定义左右指针</span><br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(right &lt; n)&#123;<br>            <span class="hljs-comment">// 如果没有出现过</span><br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">find</span>(s[right]) == hash.<span class="hljs-built_in">end</span>())&#123;<br>                hash[s[right]] = <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                hash[s[right]]++;<br>            &#125;<br>            <span class="hljs-comment">// 移动左指针直至没有重复元素</span><br>            <span class="hljs-keyword">while</span>(hash[s[right]] &gt; <span class="hljs-number">1</span>)&#123;<br>                hash[s[left]]--;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">// 更新最大长度</span><br>            ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/?envType=study-plan-v2&envId=top-100-liked">找到字符串中所有字母异位词</a></h2><h3 id="定长滑动窗口"><a href="#定长滑动窗口" class="headerlink" title="定长滑动窗口"></a>定长滑动窗口</h3><p>假设p的长度为n，枚举s的所有长为n的子串，如果该子串字母出现次数与p相同，则说明它是p的异位词，可以加入结果集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = p.<span class="hljs-built_in">length</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        array&lt;<span class="hljs-type">int</span>, 26&gt; cntP&#123;&#125;;<br>        array&lt;<span class="hljs-type">int</span>, 26&gt; cntS&#123;&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : p)&#123;<br>            cntP[ch - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-comment">// 滑动窗口</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; s.<span class="hljs-built_in">length</span>(); right++)&#123;<br>            <span class="hljs-comment">// 更新窗口内的哈希值</span><br>            cntS[s[right] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-type">int</span> left = right - n + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 窗口长度不足</span><br>            <span class="hljs-keyword">if</span>(left &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 判断是否是异位词</span><br>            <span class="hljs-keyword">if</span>(cntS == cntP)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(left);<br>            &#125;<br>            cntS[s[left] - <span class="hljs-string">&#x27;a&#x27;</span>]--;  <span class="hljs-comment">// 移动左指针</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(∣Σ∣m+n)</li><li>空间复杂度：O(∣Σ∣)</li></ul><h3 id="不定长滑动窗口"><a href="#不定长滑动窗口" class="headerlink" title="不定长滑动窗口"></a>不定长滑动窗口</h3><p>枚举子串的右端点，如果其中一种字母的出现次数大于p的这种字母的出现次数，则右移子串的左端点。如果子串的长度等于p的长度，则说明子串的每种字母的出现次数，和 p 的每种字母的出现次数都相同，因为（如果出现次数 s 的小于 p 的，不可能长度一样）</p><p>代码实现时，可以把 cntS 和 cntP 合并成一个 cnt：</p><ul><li>对于 p 的字母 c，把 cnt[p] 加一。</li><li>对于 s′的字母 c，把 cnt[c] 减一。</li><li>如果 cnt[c]&lt;0，说明窗口中的字母 c 的个数比 p 的多，右移左端点。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> n = p.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-comment">// 统计p出现次数</span><br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">26</span>]&#123;&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : p)&#123;<br>            cnt[ch - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-comment">// 滑动窗口</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; m; right++)&#123;<br>            <span class="hljs-comment">// 更新出现次数</span><br>            <span class="hljs-type">char</span> ch = s[right] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            cnt[ch]--;<br>            <span class="hljs-comment">// 当前字母出现次数过多</span><br>            <span class="hljs-keyword">while</span>(cnt[ch] &lt; <span class="hljs-number">0</span>)&#123;<br>                cnt[s[left] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">// 子串和p长度相等</span><br>            <span class="hljs-keyword">if</span>(right - left + <span class="hljs-number">1</span> == n)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m + n)</li><li>空间复杂度：O(∣Σ∣)</li></ul><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p>C++中的数组类型是继承了c语言的特性，在使用数组的时候要注意数组越界操作问题。为了更安全的对数组进行操作，C++提出了数组模板类array。array内存空间为连续的一段地址，适用于提前已知所要存储的数据类型和数量、进行大量的查、改操作，不适用于含有大量交换、删除、增加数据的操作，该容器无法动态改变大小，所以说提前已知存储数据类型和数量。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>滑动窗口</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈（矩形面积/贡献法/最小字典序）</title>
    <link href="/2024/11/20/posts/monoStack/"/>
    <url>/2024/11/20/posts/monoStack/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="单调栈（矩形面积-贡献法-最小字典序）"><a href="#单调栈（矩形面积-贡献法-最小字典序）" class="headerlink" title="单调栈（矩形面积&#x2F;贡献法&#x2F;最小字典序）"></a>单调栈（矩形面积&#x2F;贡献法&#x2F;最小字典序）</h1><p>如果当前元素比栈顶小，直接入栈；否则，把所有小于等于它的元素弹出，再将其放入。因此，栈中的元素一定是有序的，称之为单调栈。</p><h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/description/">每日温度</a></h2><h3 id="从右向左"><a href="#从右向左" class="headerlink" title="从右向左"></a>从右向左</h3><p>如果当前元素比栈顶小，直接入栈，并且当前元素的下一个更高温度就是1；否则，把所有小于等于它的元素弹出，再将其放入，当前元素的下一个更高温度就是栈顶元素。即，找到第一个大于当前元素的栈中元素，其值应该是栈顶元素下标-当前元素下标。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = temperatures.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-comment">// 找到第一个大于当前温度的元素</span><br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[i] &gt;= temperatures[stk.<span class="hljs-built_in">top</span>()])&#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-comment">// 栈顶元素下标-当前元素下标</span><br>            <span class="hljs-keyword">if</span>(!stk.<span class="hljs-built_in">empty</span>())&#123;<br>                ans[i] = stk.<span class="hljs-built_in">top</span>() - i;<br>            &#125;<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，每个元素最多入栈和出栈一次。</li><li>空间复杂度：O(n)，返回值不计入，仅考虑栈的最大空间消耗。</li></ul><h3 id="从左向右"><a href="#从左向右" class="headerlink" title="从左向右"></a>从左向右</h3><p>从左向右遍历元素，如果当前元素比栈顶小，直接入栈，等待出现更大元素；否则，把所有小于等于它的元素弹出，并且可以更新每一个弹出的元素的结果，即<code>i - stk.top()</code>，再将当前元素放入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = temperatures.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br><br>        <span class="hljs-comment">// 从左向右遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-comment">// 找到第一个比当前温度小或相等的元素，注意等于的时候无法更新</span><br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[stk.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-comment">// 更新</span><br>                ans[stk.<span class="hljs-built_in">top</span>()] = i - stk.<span class="hljs-built_in">top</span>();<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">接雨水</a></h2><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>对于接雨水问题，也可以用单调栈的方法。从左往右遍历，如果当前元素比栈顶小，直接入栈，因为当前无法接雨水，直到当前元素比栈顶大，当前坑可以接的水为：取栈顶的下一个元素作为left，当前元素为right，宽度就是<code>right - left - 1</code>，高度为左右高度的较小值-栈顶柱子的高度，即<code>min(height[left], height[i]) - height[stk.top()]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 从左往右遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-comment">// 找到第一个小于当前温度的栈顶</span><br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; height[stk.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> bottom = stk.<span class="hljs-built_in">top</span>();<br>                stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 前面没有柱子了，无法接水</span><br>                <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">empty</span>())&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> left = stk.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-type">int</span> dh = <span class="hljs-built_in">min</span>(height[left], height[i]) - height[bottom];<br>                ans += dh * (i - left - <span class="hljs-number">1</span>);<br>            &#125;<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="商品折扣后的最终价格"><a href="#商品折扣后的最终价格" class="headerlink" title="商品折扣后的最终价格"></a><a href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/description/">商品折扣后的最终价格</a></h2><h3 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h3><p>从左向右遍历，当前元素大于栈顶，就入栈，否则不断出栈，并更新当前出栈元素的折扣价，即<code>prices[stk.top()] - prices[i]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">finalPrices</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans = prices;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br><br>        <span class="hljs-comment">// 从左向右遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; prices[i] &lt;= prices[stk.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> j = stk.<span class="hljs-built_in">top</span>();<br>                stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 更新价格</span><br>                ans[j] = prices[j] - prices[i];<br>            &#125;<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>不得不说<a href="https://www.bilibili.com/video/BV1VN411J7S7/?vd_source=57ec244afa109ba4ee6346389a5f32f7">灵神</a>讲得太好了，我居然也能看过视频之后自己把题目做出来了╰(<em>°▽°</em>)╯ 后面再多做几道题练习一下~</p><h2 id="下一个更大元素I"><a href="#下一个更大元素I" class="headerlink" title="下一个更大元素I"></a><a href="https://leetcode.cn/problems/next-greater-element-i/?envType=problem-list-v2&envId=qUFw3TKu">下一个更大元素I</a></h2><h3 id="单调栈-2"><a href="#单调栈-2" class="headerlink" title="单调栈"></a>单调栈</h3><ul><li>先将nums2所有数字存到哈希表中，这样可以通过O(1)的时间找到其索引。</li><li>用单调栈的方法处理nums2，找其下一个更大元素的下标，存到数组里。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n1 = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n2 = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 单调栈处理nums2</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mono</span><span class="hljs-params">(n2, <span class="hljs-number">-1</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n2; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[stk.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> j = stk.<span class="hljs-built_in">top</span>();<br>                stk.<span class="hljs-built_in">pop</span>();<br>                mono[j] = i;<br>            &#125;<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-comment">// 哈希表处理nums2</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n2; i++)&#123;<br>            hash[nums2[i]] = i;<br>        &#125;<br>        <span class="hljs-comment">// 遍历nums1</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n1)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n1; i++)&#123;<br>            <span class="hljs-type">int</span> index = hash[nums1[i]];<br>            ans[i] = mono[index] == <span class="hljs-number">-1</span> ? <span class="hljs-number">-1</span> : nums2[mono[index]];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n1 + n2)</li><li>空间复杂度：O(n2)</li></ul><p>上面的解法是自己写出来的，力扣官方题解省略了哈希表存储nums2的部分，节省了空间。灵神的做法是省去了存储nums2中其他元素的方法，只存nums1中存在的元素。</p><h2 id="下一个更大元素"><a href="#下一个更大元素" class="headerlink" title="下一个更大元素"></a><a href="https://leetcode.cn/problems/next-greater-element-ii/?envType=problem-list-v2&envId=qUFw3TKu">下一个更大元素</a></h2><h3 id="单调栈-3"><a href="#单调栈-3" class="headerlink" title="单调栈"></a>单调栈</h3><p>和上一题的区别是，这道题的数组可以循环，也就是说，先找到数组元素下标后边的第一个比它大的元素，如果没有，可以从下标0开始找。可以把 nums 复制一份，拼在 nums 右边，这样就把环形数组变成一般数组了。例如 [1,2,1] 变成 [1,2,1,1,2,1]。无需真的把数组复制一份，而是用下标模 n 的方式取到对应的元素值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i++)&#123;<br>            <span class="hljs-type">int</span> x = nums[i % n];<br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; x &gt; nums[stk.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> j = stk.<span class="hljs-built_in">top</span>();<br>                stk.<span class="hljs-built_in">pop</span>();<br>                ans[j] = x; <span class="hljs-comment">// 只需记录元素值而不是下标</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(i &lt; n)&#123;<br>                stk.<span class="hljs-built_in">push</span>(i);<br>            &#125;            <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="链表中的下一个更大节点"><a href="#链表中的下一个更大节点" class="headerlink" title="链表中的下一个更大节点"></a><a href="https://leetcode.cn/problems/next-greater-node-in-linked-list/?envType=problem-list-v2&envId=qUFw3TKu">链表中的下一个更大节点</a></h2><h3 id="单调栈-4"><a href="#单调栈-4" class="headerlink" title="单调栈"></a>单调栈</h3><p>可以先遍历一遍链表得到其长度，确定答案数组的大小。然后将每个节点保存在栈中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextLargerNodes</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        unordered_map&lt;ListNode*, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>        ListNode* node = head;<br>        <span class="hljs-keyword">while</span>(node)&#123;<br>            hash[node] = n++;<br>            node = node-&gt;next;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        stack&lt;ListNode*&gt; stk;<br>        node = head;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(node)&#123;<br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; node-&gt;val &gt; stk.<span class="hljs-built_in">top</span>()-&gt;val)&#123;<br>                <span class="hljs-type">int</span> i = hash[stk.<span class="hljs-built_in">top</span>()];<br>                stk.<span class="hljs-built_in">pop</span>();<br>                ans[i] = node-&gt;val;<br>            &#125;<br>            stk.<span class="hljs-built_in">push</span>(node);<br>            node = node-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>上面是自己写的解法，官方题解省略了第一次遍历得到长度以及哈希表，在栈中存储的是节点的值和它的索引。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextLargerNodes</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; stk;<br><br>        ListNode* node = head;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(node)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);   <span class="hljs-comment">// 这样到最后也能知道ans的长度</span><br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>().first &lt; node-&gt;val)&#123;<br>                ans[stk.<span class="hljs-built_in">top</span>().second] = node-&gt;val;<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            stk.<span class="hljs-built_in">emplace</span>(node-&gt;val, index);<br>            index++;<br>            node = node-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路是一样的，但是节省了空间。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单调栈的题目大概做了6道，基本的思路已经理解并且能够自己做出来不太复杂的题目。先到这里，以后再刷。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>单调栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 热题 100-双指针</title>
    <link href="/2024/11/19/posts/hot100-2/"/>
    <url>/2024/11/19/posts/hot100-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-热题-100-双指针"><a href="#LeetCode-热题-100-双指针" class="headerlink" title="LeetCode 热题 100-双指针"></a>LeetCode 热题 100-双指针</h1><h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked">移动零</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一个指针逐个遍历元素，如果它所指的元素是0，就定义一个新的指针，不断后移直到其所指不为0，交换两指针元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; nums[j] == <span class="hljs-number">0</span>) j++;<br>                <span class="hljs-keyword">if</span>(j &lt; n)&#123;<br>                    <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$，在最坏情况下（比如数组中大部分元素都是0），对于每个 i，都可能需要遍历到数组末尾。</li><li>空间复杂度：O(1)</li></ul><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</p><p>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p><p>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(right &lt; n)&#123;<br>            <span class="hljs-keyword">if</span>(nums[right] != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">swap</span>(nums[left], nums[right]);<br>                left++;<br>            &#125;<br>            right++;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&envId=top-100-liked">盛最多水的容器</a></h2><h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h3><p>找到<code>(j - i ) * min(height[i], height[j])</code>的最大值。左指针指向最左边，右指针指向最右边，这样就可以保证每次移动时(j-i)一定是减小的，每次移动较低的那个指针。</p><p>如果移动高的那一边，会有两种情况：</p><p>1、下一根柱子的高度比现在高，高度还取最小值低的那边，最大水量比原来小</p><p>2、下一根柱子的高度比现在低，高度比原来的最小值还小，最大水量比原来小</p><p>如果移动低的那一边，会有两种情况：</p><p>1、下一根柱子的高度比现在高，高度就可以取更高的值，最大水量不一定比原来小</p><p>2、下一根柱子的高度比现在低，高度比原来的最小值还小，最大水量比原来小</p><p>所以应该移动低的那一边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> cur = (right - left) * <span class="hljs-built_in">min</span>(height[left], height[right]);<br>            ans = <span class="hljs-built_in">max</span>(ans, cur);<br><br>            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;<br>                left++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a href="https://leetcode.cn/problems/3sum/?envType=study-plan-v2&envId=top-100-liked">三数之和</a></h2><h3 id="双指针-2"><a href="#双指针-2" class="headerlink" title="双指针"></a>双指针</h3><ol><li>首先对数组进行排序；</li><li>跳过相等的数字，固定一个数字，此时转化为寻找两数之和等于<code>0-nums[i]</code>的问题；</li><li>定义左右指针，分别指向<code>i+1</code>和<code>n-1</code>；</li><li>左右指针都需要跳过重复元素，因为题目要求不能包含重复的三元组。</li><li>如果当前两数之和等于target，将当前组合加入结果集，否则如果大于target，右指针左移，否则左指针右移。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br>        <span class="hljs-comment">// 排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++)&#123;<br>            <span class="hljs-comment">// 跳过重复元素</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 固定元素，找两数之和</span><br>            <span class="hljs-type">int</span> target = <span class="hljs-number">0</span> - nums[i];<br>            <span class="hljs-comment">// 对撞指针</span><br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-type">int</span> sum = nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;);<br>                    <span class="hljs-comment">// 跳过重复元素</span><br>                    <span class="hljs-keyword">for</span>(left += <span class="hljs-number">1</span>; left &lt; right &amp;&amp; nums[left] == nums[left<span class="hljs-number">-1</span>]; left++);<br>                    <span class="hljs-keyword">for</span>(right -= <span class="hljs-number">1</span>; right &gt; left &amp;&amp; nums[right] == nums[right+<span class="hljs-number">1</span>]; right--);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>                    right--;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    left++;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(logn)，忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。</li></ul><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/?envType=study-plan-v2&envId=top-100-liked">接雨水</a></h2><h3 id="双指针-3"><a href="#双指针-3" class="headerlink" title="双指针"></a>双指针</h3><p>用前后缀去思考，即当前这个位置能接的水的量，取决于前后缀最大值中的较小值，以及当前柱子的高度。因此可以用两个数组去保存每个位置的前缀最大值和后缀最大值，但空间可以进一步优化，即两指针分别从左右两端出发，如果前缀最大值比后缀最大值小，那么更新前面的木桶，即<code>ans += preMax - height[left]</code>，否则更新后面的木桶，即<code>ans += sufMax - height[right]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> preMax = <span class="hljs-number">0</span>, sufMax = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            preMax = <span class="hljs-built_in">max</span>(preMax, height[left]);<br>            sufMax = <span class="hljs-built_in">max</span>(sufMax, height[right]);<br><br>            <span class="hljs-keyword">if</span>(preMax &lt; sufMax)&#123;<br>                ans += preMax - height[left];<br>                left++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans += sufMax - height[right];<br>                right--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>这道题还有单调栈的做法，之前做过，但是现在又不记得了，明天把<a href="https://leetcode.cn/circle/discuss/9oZFK9/">单调栈专题</a>的部分好好学习一下。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>hot100中双指针的题目之前全都做过，但是现在又不记得了，前面几道题自己思考或者看过提示之后还能写出来，接雨水这道题也有印象是和前后缀有关，但是无法形成具体的思路。要多加复习！</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>双指针</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 热题 100-哈希表</title>
    <link href="/2024/11/18/posts/hot100-1/"/>
    <url>/2024/11/18/posts/hot100-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-热题-100-哈希表"><a href="#LeetCode-热题-100-哈希表" class="headerlink" title="LeetCode 热题 100-哈希表"></a>LeetCode 热题 100-哈希表</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a href="https://leetcode.cn/problems/two-sum/submissions/581272991/?envType=study-plan-v2&envId=top-100-liked">两数之和</a></h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N) 降低到 O(1)。</p><p>创建一个哈希表，对于每一个 x，首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义哈希表</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">find</span>(target - nums[i]) != hash.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-keyword">return</span> &#123;i, hash[target - nums[i]]&#125;;<br>            &#125;<br>            hash[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked">字母异位词分组</a></h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>把每个单词进行排序，异位词排序后的结果是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        unordered_map&lt;string, vector&lt;string&gt;&gt; hash;<br>        <span class="hljs-keyword">for</span>(string&amp; s : strs)&#123;<br>            string sortedS = s;<br>            <span class="hljs-built_in">sort</span>(sortedS.<span class="hljs-built_in">begin</span>(), sortedS.<span class="hljs-built_in">end</span>());<br>            hash[sortedS].<span class="hljs-built_in">push_back</span>(s);<br>        &#125;<br><br>        <span class="hljs-comment">// 返回结果</span><br>        vector&lt;vector&lt;string&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;[_, value] : hash)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(value);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nklogk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。</li><li>空间复杂度：O(nk)</li></ul><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>对于每个字符串，首先使用哈希表统计每个字母出现的频率，然后将频率表转换为字符串作为键。这样处理完之后就得到与上一种方法类似的哈希表。最后将哈希表中的结果移到结果数组中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        unordered_map&lt;string, vector&lt;string&gt;&gt; hash;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> string&amp; s : strs)&#123;<br>            <span class="hljs-comment">// 统计字符数</span><br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : s)&#123;<br>                cnt[ch - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            &#125;<br>            <span class="hljs-comment">// 将频率转换成字符串</span><br>            string freq;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)&#123;<br>                freq += <span class="hljs-string">&#x27;#&#x27;</span> + <span class="hljs-built_in">to_string</span>(cnt[i]);<br>            &#125;<br>            hash[freq].<span class="hljs-built_in">push_back</span>(s);<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        vector&lt;vector&lt;string&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; [_, value] : hash)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(value);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nk)</li><li>空间复杂度：O(nk)</li></ul><h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-100-liked">最长连续序列</a></h2><h3 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h3><ol><li>先将数组存储到集合中进行去重，用变量curLen和ans记录当前序列和最长序列的长度。</li><li>遍历集合，判断当前元素num的num-1是否在集合中，如果不在集合中，说明num是序列的起始，如果在集合中，直接跳过。</li><li>对于起始元素num，判断num+1,num+2,…是否在集合中，并更新序列长度，最后更新ans。</li><li>返回ans。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 用集合进行去重</span><br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num : nums)&#123;<br>            set.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-comment">// 遍历集合</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num : set)&#123;<br>            <span class="hljs-comment">// 确定序列起始</span><br>            <span class="hljs-keyword">if</span>(!set.<span class="hljs-built_in">count</span>(num - <span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-type">int</span> curLen = <span class="hljs-number">1</span>, curNum = num;<br>                <span class="hljs-keyword">while</span>(set.<span class="hljs-built_in">count</span>(curNum + <span class="hljs-number">1</span>))&#123;<br>                    curNum++;<br>                    curLen++;<br>                &#125;<br>                <span class="hljs-comment">// 更新最大长度</span><br>                ans = <span class="hljs-built_in">max</span>(ans, curLen);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>在刷剑指offer时还用过并查集的方法，这里仅复习一遍思路，因为其实现起来要比上面的方法复杂一些。简单理解，每个序列的起始相当于并查集的父亲。具体见<a href="https://csxuanyang.github.io/2024/07/25/posts/LCR116/#LCR119-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97">这里</a>。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-hot100</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07.04 第 088 ~ 100 题（第 13 ~ 16 天）</title>
    <link href="/2024/11/14/posts/0704/"/>
    <url>/2024/11/14/posts/0704/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="07-04-第-088-100-题（第-13-16-天）"><a href="#07-04-第-088-100-题（第-13-16-天）" class="headerlink" title="07.04 第 088 ~ 100 题（第 13 ~ 16 天）"></a>07.04 第 088 ~ 100 题（第 13 ~ 16 天）</h1><h2 id="买股票的最佳时机"><a href="#买股票的最佳时机" class="headerlink" title="买股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">买股票的最佳时机</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>初步考虑每次结算出在第i天买入在第j天售出所能获得的利润，且j&gt; i，维护一个变量记录最大值。但是这样的时间复杂度是O(n)，无法通过所有的测试用例，因此进行优化。</p><p>假设股票在第i天售出，那么需要知道前i-1天中股票价格的最小值，用一个变量维护，因此只需一次遍历即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minPrice = prices[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            minPrice = <span class="hljs-built_in">min</span>(minPrice, prices[i<span class="hljs-number">-1</span>]);<br>            ans = <span class="hljs-built_in">max</span>(ans, prices[i] - minPrice);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="买股票的最佳时机II"><a href="#买股票的最佳时机II" class="headerlink" title="买股票的最佳时机II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买股票的最佳时机II</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>只要是上升趋势的都买，就能使利益最大化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(prices[i] &gt; prices[i<span class="hljs-number">-1</span>])&#123;<br>                ans += prices[i] - prices[i<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/submissions/">最长递增子序列</a></h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>划分阶段：按子序列结束的位置划分阶段。</li><li>定义状态：dp[i]表示以nums[i]结尾的最大递增子序列长度。</li><li>状态转移方程：枚举0 ~ i-1之间的数，如果nums[i] &gt; nums[j]，则dp[i]才可能从dp[j]转移过来。即<code>dp[i] = max(dp[i], dp[j] + 1)</code>。</li><li>初始条件：每个以nums[i]结尾的初始递增子序列长度为1，即它本身。</li><li>返回结果：维护一个最大值变量。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j])&#123;<br>                   dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>); <br>                &#125;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n ^ 2)$</li><li>空间复杂度：O(n)</li></ul><h3 id="贪心-二分查找"><a href="#贪心-二分查找" class="headerlink" title="贪心+二分查找"></a>贪心+二分查找</h3><ul><li>维护一个数组 d[i] ，表示长度为 i 的最长上升子序列的末尾元素的最小值，用 len 记录目前最长上升子序列的长度，起始时 len 为 1，d[1]&#x3D;nums[0]。</li><li>从前往后遍历数组 nums，在遍历到 nums[i] 时：<ul><li>如果 nums[i]&gt;d[len] ，则直接加入到 d 数组末尾，并更新 len&#x3D;len+1；</li><li>否则，在 d 数组中二分查找，找到第一个比 nums[i] 小的数 d[k] ，并更新 d[k+1]&#x3D;nums[i]。如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1].</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 定义d数组并初始化</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        d[len] = nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 遍历数字</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; d[len])&#123;<br>                d[++len] = nums[i];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 二分查找到第一个比nums[i]小的</span><br>                <span class="hljs-type">int</span> left = <span class="hljs-number">1</span>, right = len, pos = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>                    <span class="hljs-type">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(d[mid] &lt; nums[i])&#123;<br>                        pos = mid;<br>                        left = mid + <span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        right = mid - <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>                d[pos + <span class="hljs-number">1</span>] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul><p>也可以进行空间优化，在原地将找到的第一个比x小的数修改为x。在当前序列中找到一个位置，能够用 x 来代替（如果 x 比当前的位置的元素小）。这种做法是为了保持序列的最小性，有助于后续找到更长的递增子序列。</p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">最长公共子序列</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照两个字符串的结尾位置进行阶段划分。</li><li>定义状态：dp[i][j]等于以text1前i个字符和text2以前j个字符的子序列长度。</li><li>状态转移方程：<ul><li>如果<code>text1[i-1] == text2[j-1]</code>，则<code>dp[i][j] = dp[i-1][j-1] + 1</code>；</li><li>否则<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>。</li></ul></li><li>初始条件：<ul><li>dp[i][0] &#x3D; dp[0][j] &#x3D; 0；</li></ul></li><li>返回结果：dp[size1][size2]。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> size1 = text1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> size2 = text2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(size1 + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(size2 + <span class="hljs-number">1</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size1; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= size2; j++)&#123;<br>                <span class="hljs-keyword">if</span>(text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[size1][size2];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n^2)$</li></ul><h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按位置划分阶段。</li><li>定义状态：dp[i][j]表示从(0,0)走到(i,j)的最小路径和。</li><li>状态转移方程：<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1] + grid[i][j])</code>。</li><li>初始条件：dp[0][0] &#x3D; grid[0][0]。</li><li>返回结果：dp[m-1][n-1]。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>] + grid[<span class="hljs-number">0</span>][j];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]) + grid[i][j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(m \times n)$</li><li>空间复杂度：$O(m \times n)$</li></ul><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">编辑距离</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照两个字符串的结尾位置进行阶段划分。</li><li>定义状态：dp[i][j]word1的前i个字符和word2的前j个字符表示最小操作数。</li><li>状态转移方程：<ul><li>如果<code>word1[i-1] == word2[j-1]</code>，无需操作，<code>dp[i][j] = dp[i-1][j-1]</code>。</li><li>否则，要么插入，要么删除，要么替换，即<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</code>。</li></ul></li><li>初始条件：dp[i][0] &#x3D; i，dp[0][j] &#x3D; j。</li><li>返回结果：dp[size1][size2]。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> size1 = word1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> size2 = word2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(size1 + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(size2 + <span class="hljs-number">1</span>));<br><br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= size1; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= size2; j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size1; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= size2; j++)&#123;<br>                <span class="hljs-keyword">if</span>(word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(&#123;dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]&#125;) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[size1][size2];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(m \times n)$</li><li>空间复杂度：$O(m \times n)$</li></ul><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">不同路径</a></h2><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>划分阶段：按位置划分阶段。</li><li>定义状态：dp[i][j]表示机器人走到位置(i,j)总共有多少条不同的路径。</li><li>状态转移方程：dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1](i,j &gt; 0)。</li><li>初始条件：dp[0][0] &#x3D; 1.</li><li>返回结果：dp[m-1][n-1]。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 循环遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>                    dp[i][j] += dp[i<span class="hljs-number">-1</span>][j];<br>                &#125;<br>                <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span>)&#123;<br>                    dp[i][j] += dp[i][j<span class="hljs-number">-1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>f(i,j) 仅与第 i 行和第 i−1 行的状态有关，因此我们可以使用滚动数组代替代码中的二维数组，使空间复杂度降低为 O(n)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                dp[j] += dp[j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(n)</li></ul><h3 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h3><p><img src="/2024/11/14/posts/0704/image.png" alt="组合数公式"></p><p>$C_{m+n-2}^{m-1} &#x3D; \frac{(m+n-2)!}{(m-1)! (n-1)!} &#x3D; \frac{(m+n-2)(m+n-3 … n)}{(m-1)!}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = n, y = <span class="hljs-number">1</span>; y &lt; m; x++, y++)&#123;<br>            ans = ans * x / y;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m)</li><li>空间复杂度：O(1)</li></ul><h2 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a><a href="https://leetcode.cn/problems/maximum-product-subarray/">乘积最大子数组</a></h2><h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><p>这里的定义并不满足「最优子结构」,当前位置的最优解未必是由前一个位置的最优解转移得到的。根据正负性进行分类讨论：</p><ul><li>当前位置如果是一个负数，那么就希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且希望这个积尽可能「负得更多」，即尽可能小。可以再维护一个 $f_{min}(i)$，它表示以第 i 个元素结尾的乘积最小子数组的乘积。fmin[i] &#x3D; min(nums[i], fmin[i-1]* nums[i], fmax[i-1]* nums[i])。</li><li>fmax[i] &#x3D; max(nums[i], fmax[i-1]* nums[i], fmin[i-1]* nums[i])。</li></ul><p>可以进行空间优化，即用两个变量来维护fmin[i-1]和fmax[i-1]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span> fmin = nums[<span class="hljs-number">0</span>], fmax = nums[<span class="hljs-number">0</span>], ans = nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> tmax = fmax, tmin = fmin;<br>            fmax = <span class="hljs-built_in">max</span>(&#123;tmax * nums[i], tmin * nums[i], nums[i]&#125;);<br>            fmin = <span class="hljs-built_in">min</span>(&#123;tmin * nums[i], tmax * nums[i], nums[i]&#125;);<br>            ans = <span class="hljs-built_in">max</span>(ans, fmax);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h2><h3 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>定义状态：dp[i]表示当前能偷取的最大数值。</li><li>状态转移方程：要么偷，即<code>dp[i] = dp[i-2] + nums[i]</code>，因为不能偷相邻的，要么不偷，即<code>dp[i] = dp[i-1]</code>。两者取较大。</li><li>初始条件：dp[0] &#x3D; nums[0]，如果n &gt; 1则dp[1] &#x3D; nums[1]。</li><li>返回结果：max(dp[n-1], dp[n-2])。</li></ol><p>空间优化：只用两个变量保存dp[i-1]和dp[i-2]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span> prepre = nums[<span class="hljs-number">0</span>], pre = <span class="hljs-built_in">max</span>(prepre, nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> tpre = pre;<br>            pre = <span class="hljs-built_in">max</span>(prepre + nums[i], tpre);<br>            prepre = tpre;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(prepre, pre);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">随机链表的复制</a></h2><h3 id="回溯-哈希表"><a href="#回溯-哈希表" class="headerlink" title="回溯 + 哈希表"></a>回溯 + 哈希表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;Node*, Node*&gt; cachedNode;<br><br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果还没有为当前结点创建过副本</span><br>        <span class="hljs-keyword">if</span>(!cachedNode.<span class="hljs-built_in">count</span>(head))&#123;<br>            Node* newHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head-&gt;val);<br>            cachedNode[head] = newHead;<br>            newHead-&gt;next = <span class="hljs-built_in">copyRandomList</span>(head-&gt;next);<br>            newHead-&gt;random = <span class="hljs-built_in">copyRandomList</span>(head-&gt;random);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cachedNode[head];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="迭代-节点拆分"><a href="#迭代-节点拆分" class="headerlink" title="迭代 + 节点拆分"></a>迭代 + 节点拆分</h3><ol><li>首先将该链表中每一个节点拆分为两个相连的节点，例如对于链表 A→B→C，我们可以将其拆分为 A→A′→B→B ′→C→C ′。对于任意一个原节点 S，其拷贝节点 S ′即为其后继节点。</li><li>这样，我们可以直接找到每一个拷贝节点S′的随机指针应当指向的节点，即为其原节点 S 的随机指针指向的节点 T 的后继节点T′。需要注意原节点的随机指针可能为空，我们需要特别判断这种情况。</li><li>当我们完成了拷贝节点的随机指针的赋值，我们只需要将这个链表按照原节点与拷贝节点的种类进行拆分即可，只需要遍历一次。同样需要注意最后一个拷贝节点的后继节点为空，我们需要特别判断这种情况。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 边界处理</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">// 复制每个节点</span><br>        <span class="hljs-keyword">for</span>(Node* node = head; node != <span class="hljs-literal">NULL</span>; node = node-&gt;next-&gt;next)&#123;<br>            Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(node-&gt;val);<br>            newNode-&gt;next = node-&gt;next;<br>            node-&gt;next = newNode;<br>        &#125;<br>        <span class="hljs-comment">// 随机指针</span><br>        <span class="hljs-keyword">for</span>(Node* node = head; node != <span class="hljs-literal">NULL</span>; node = node-&gt;next-&gt;next)&#123;<br>            Node* newNode = node-&gt;next;<br>            newNode-&gt;random = (node-&gt;random != <span class="hljs-literal">NULL</span>) ? node-&gt;random-&gt;next : <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">// 复原链表，拆分</span><br>        Node* newHead = head-&gt;next;<br>        <span class="hljs-keyword">for</span>(Node* node = head; node != <span class="hljs-literal">NULL</span>; node = node-&gt;next)&#123;<br>            Node* newNode = node-&gt;next;<br>            node-&gt;next = node-&gt;next-&gt;next;<br>            newNode-&gt;next = (newNode-&gt;next != <span class="hljs-literal">NULL</span>) ? newNode-&gt;next-&gt;next : <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">二叉树的序列化与反序列化</a></h2><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>之前在刷剑指offer的时候用先序遍历做过，这里用层次遍历做。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span>;<br><br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span> (node) &#123;<br>                ans += <span class="hljs-built_in">to_string</span>(node-&gt;val) + <span class="hljs-string">&quot;,&quot;</span>;<br>                que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans += <span class="hljs-string">&quot;#,&quot;</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (data == <span class="hljs-string">&quot;#&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-function">stringstream <span class="hljs-title">s</span><span class="hljs-params">(data)</span></span>;<br>        string strNode;<br>        <span class="hljs-built_in">getline</span>(s, strNode, <span class="hljs-string">&#x27;,&#x27;</span>);<br><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(strNode));<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getline</span>(s, strNode, <span class="hljs-string">&#x27;,&#x27;</span>)) &#123;<br>                <span class="hljs-keyword">if</span> (strNode != <span class="hljs-string">&quot;#&quot;</span>) &#123;<br>                    node-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(strNode));<br>                    que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getline</span>(s, strNode, <span class="hljs-string">&#x27;,&#x27;</span>)) &#123;<br>                <span class="hljs-keyword">if</span> (strNode != <span class="hljs-string">&quot;#&quot;</span>) &#123;<br>                    node-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(strNode));<br>                    que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec ser, deser;</span><br><span class="hljs-comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组</a></h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>定义两个指针，右指针不断向右滑动，直至窗口内的和大于等于目标，则尝试收缩窗口，直到 sum &lt; target，并更新最小长度，移动左指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = INT_MAX;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; n; ++right) &#123;<br>            sum += nums[right];  <span class="hljs-comment">// 增加右边界的值</span><br><br>            <span class="hljs-comment">// 尝试收缩窗口，直到 sum &lt; target</span><br>            <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>                ans = <span class="hljs-built_in">min</span>(ans, right - left + <span class="hljs-number">1</span>);<br>                sum -= nums[left++];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果没有找到满足条件的子数组，返回 0</span><br>        <span class="hljs-keyword">return</span> ans == INT_MAX ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="前缀和-二分查找"><a href="#前缀和-二分查找" class="headerlink" title="前缀和+二分查找"></a>前缀和+二分查找</h3><p>这道题保证了数组中每个元素都为正，所以前缀和一定是递增的，得到前缀和之后，对于每个开始下标 i，可通过二分查找得到大于或等于 i 的最小下标 bound，使得 sums[bound]−sums[i−1]≥s，并更新子数组的最小长度（此时子数组的长度是 bound−(i−1)）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = INT_MAX;<br><br>        <span class="hljs-comment">// 求前缀和</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sums</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            sums[i] = sums[i<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-1</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// 以每一个i-1为起点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;=n; i++)&#123;<br>            <span class="hljs-type">int</span> tmp = target + sums[i<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">auto</span> bound = <span class="hljs-built_in">lower_bound</span>(sums.<span class="hljs-built_in">begin</span>(), sums.<span class="hljs-built_in">end</span>(), tmp);<br>            <span class="hljs-keyword">if</span>(bound != sums.<span class="hljs-built_in">end</span>())&#123;<br>                ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(bound - sums.<span class="hljs-built_in">begin</span>()) - (i<span class="hljs-number">-1</span>));<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == INT_MAX ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul><h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a href="https://leetcode.cn/problems/word-break/">单词拆分</a></h2><h3 id="动态规划-4"><a href="#动态规划-4" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>划分阶段：按照单词结尾位置进行阶段划分。</li><li>定义状态： 能否拆分为单词表的单词，可以分解为：前i个字符构成的字符串，能否分解为单词；剩余字符串，能否分解为单词。dp[i]表示前i个字符组成的字符串是否可以拆分成单词表的单词。</li><li>状态转移数组：如果s[0:j]可以拆分，即dp[j]&#x3D;true，并且s[j:i]出现在字典中，则dp[i] &#x3D; true。如果s[0:j]不可以拆分，或者s[j:i]没有出现在字典中，则dp[i] &#x3D; false。</li><li>初始条件：长度为0的字符串可以拆分为单词，dp[0] &#x3D; true。</li><li>返回结果：dp[n]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 存入哈希表便于查找</span><br>        unordered_set&lt;string&gt; words;<br>        <span class="hljs-keyword">for</span>(string&amp; str : wordDict)&#123;<br>            words.<span class="hljs-built_in">insert</span>(str);<br>        &#125;<br><br>        <span class="hljs-comment">// 填表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-comment">// 枚举j</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                string sub = s.<span class="hljs-built_in">substr</span>(j, i - j);<br>                <span class="hljs-keyword">if</span>(dp[j] &amp;&amp; words.<span class="hljs-built_in">count</span>(sub) != <span class="hljs-number">0</span>)&#123;<br>                    dp[i] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(n)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，<a href="https://github.com/datawhalechina/leetcode-notes/tree/main">leetcode算法笔记</a>从基础算法篇到面试篇下的内容都刷完了，题目较多地涉及到递归、二叉树、滑动窗口、动态规划等内容，虽然有很多题在剑指offer里都做过，但再次遇到时还是会思路不清晰。之后计划跟着灵神的题单继续刷，记得每周日把这一周刷得题目再复习一遍，然后可以参加一些周赛或者双周赛。白日梦想家停止幻想的关键就在于行动，加油！</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>面试篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07.03 第 075 ~ 087 题（第 09 ~ 12 天）</title>
    <link href="/2024/11/10/posts/0703/"/>
    <url>/2024/11/10/posts/0703/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="07-03-第-075-087-题（第-09-12-天）"><a href="#07-03-第-075-087-题（第-09-12-天）" class="headerlink" title="07.03 第 075 ~ 087 题（第 09 ~ 12 天）"></a>07.03 第 075 ~ 087 题（第 09 ~ 12 天）</h1><h2 id="二叉树的完全性检验"><a href="#二叉树的完全性检验" class="headerlink" title="二叉树的完全性检验"></a><a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">二叉树的完全性检验</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果当前节点不为空，且左子树为空，右子树不为空，则返回false。否则递归判断左右子树是否是完全二叉树。这种思路是错误的，因为如果左子树是完全二叉树，但是没有右子树，而右子树不为空，这棵树也不是完全二叉树。</p><p>使用广度优先搜索，即层序遍历实现。用一个bool变量标记是否出现过空节点，一旦出现过空节点，再出现非空节点，直接返回false即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isCompleteTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">bool</span> foundNull = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)&#123;<br>                foundNull = <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(foundNull)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br><br>                que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="二叉树直径"><a href="#二叉树直径" class="headerlink" title="二叉树直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">二叉树直径</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>链：从子树中的叶子节点到当前节点的路径。把最长链的长度，作为 dfs 的返回值。根据这一定义，空节点的链长是 −1，叶子节点的链长是 0。</p><p>直径：等价于由两条（或者一条）链拼成的路径。我们枚举每个 node，假设直径在这里「拐弯」，也就是计算由左右两条从下面的叶子节点到 node 的链的节点值之和，去更新答案的最大值。</p><p>dfs返回链长，当前节点到其他节点的最长路径是左子树链长和右子树链长的较大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftLen = <span class="hljs-built_in">dfs</span>(root-&gt;left) + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightLen = <span class="hljs-built_in">dfs</span>(root-&gt;right) + <span class="hljs-number">1</span>;<br>        ans = <span class="hljs-built_in">max</span>(ans, leftLen + rightLen);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftLen, rightLen);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="二叉树的最大宽度"><a href="#二叉树的最大宽度" class="headerlink" title="二叉树的最大宽度"></a><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/description/">二叉树的最大宽度</a></h2><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>左子节点编号<code>2 * i</code>，右子节点为<code>2 * i + 1</code>，不断把每一层的左右子节点加入，并更新每一层的宽度，即最后一个节点的下标值-第一个节点的下标值+1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">widthOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">1</span>;<br>        vector&lt;pair&lt;TreeNode*, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;&gt; arr;<br>        arr.<span class="hljs-built_in">emplace_back</span>(root, <span class="hljs-number">1L</span>);<br>        <span class="hljs-comment">// 广度优先</span><br>        <span class="hljs-keyword">while</span>(!arr.<span class="hljs-built_in">empty</span>())&#123;<br>            vector&lt;pair&lt;TreeNode*, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;&gt; tmp;    <span class="hljs-comment">// 暂时存放下一层的节点</span><br>            <span class="hljs-comment">// 遍历当前层的每一个节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;[node, index] : arr)&#123;<br>                <span class="hljs-keyword">if</span>(node-&gt;left)&#123;<br>                    tmp.<span class="hljs-built_in">emplace_back</span>(node-&gt;left, index * <span class="hljs-number">2</span>);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node-&gt;right)&#123;<br>                    tmp.<span class="hljs-built_in">emplace_back</span>(node-&gt;right, index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 遍历完当前层，更新最大宽度</span><br>            ans = <span class="hljs-built_in">max</span>(ans, arr.<span class="hljs-built_in">back</span>().second - arr[<span class="hljs-number">0</span>].second + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 更新当前层节点</span><br>            arr = <span class="hljs-built_in">move</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.。</p><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>遍历时如果是先访问左子节点，再访问右子节点，每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值，需要记录下来进行后续的比较。一次深度优先搜索中，需要当前节点到当前行最左边节点的宽度，以及对子节点进行深度优先搜索，求出最大宽度，并返回最大宽度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; levelMin;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">widthOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">1</span>, <span class="hljs-number">1LL</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node, <span class="hljs-type">int</span> depth, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> index)</span></span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>        &#125;<br>        <span class="hljs-comment">// 第一次访问当前层</span><br>        <span class="hljs-keyword">if</span>(!levelMin.<span class="hljs-built_in">count</span>(depth))&#123;<br>            levelMin[depth] = index;<br>        &#125;<br>        <span class="hljs-comment">// 否则计算最大宽度</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> leftLen = <span class="hljs-built_in">dfs</span>(node-&gt;left, depth + <span class="hljs-number">1</span>, index * <span class="hljs-number">2</span>);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> rightLen = <span class="hljs-built_in">dfs</span>(node-&gt;right, depth + <span class="hljs-number">1</span>, index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(&#123;index - levelMin[depth] + <span class="hljs-number">1LL</span>, leftLen, rightLen&#125;);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">零钱兑换</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>动态规划：</p><ol><li>划分阶段：按照背包容量即金额进行阶段划分。</li><li>定义状态：dp[i]表示凑成i元需要的最少硬币数。</li><li>状态转移方程：dp[i] &#x3D; min(dp[i], dp[i-num]+1)</li><li>初始条件：凑成总金额为0所需的最少硬币数为0，dp[0]&#x3D;0</li><li>返回结果：dp[n]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX<span class="hljs-number">-1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 凑成0元物品需要0个硬币</span><br>        <span class="hljs-comment">// 枚举物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> coin : coins)&#123;<br>            <span class="hljs-comment">// 枚举重量</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = coin; i &lt;= amount; i++)&#123;<br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i-coin] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> dp[amount] == (INT_MAX - <span class="hljs-number">1</span>) ? <span class="hljs-number">-1</span> : dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times amount)$</li><li>空间复杂度：$O(amount)$</li></ul><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a><a href="https://leetcode.cn/problems/subsets/">子集</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>回溯法：递归结束条件是遍历到最后一个元素，然后选择&#x2F;不选择当前元素进行递归。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(nums, path, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, <span class="hljs-type">int</span> index)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(index == nums.<span class="hljs-built_in">size</span>())&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 选择不加入</span><br>        <span class="hljs-built_in">dfs</span>(nums, path, index + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 选择加入</span><br>        path.<span class="hljs-built_in">push_back</span>(nums[index]);<br>        <span class="hljs-built_in">dfs</span>(nums, path, index + <span class="hljs-number">1</span>);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \cdot 2^n)$，其中 n 为 nums 的长度。每次都是选或不选，递归次数为一个满二叉树的节点个数，那么一共会递归 $O(2^n)$ 次（等比数列和），再算上加入答案时复制 path 需要 O(n) 的时间。</li><li>空间复杂度：$O(n)$，不计返回值空间。</li></ul><h2 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a><a href="https://leetcode.cn/problems/maximal-square/description/">最大正方形</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照正方形的右下角坐标进行阶段划分。</li><li>定义状态：dp[i][j]表示以(i,j)为右下角的且值包含1的正方形的最大边长。</li><li>状态转移方程：如果<code>matrix[i][j] == 0</code>，则<code>dp[i][j] = 0</code>；否则<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</code>。</li><li>初始条件：dp[i][j] &#x3D; 0。边界条件：<code>i == 0 || j == 0</code>。即当<code>matrix[i][j] = 0</code>时，无需进行操作，因为初始化为0，如果是1，再根据是否是边界情况来进行不同的操作。</li><li>返回结果：维护一个最大值变量，然后取其平方。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 定义状态</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-comment">// 遍历矩阵</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    <span class="hljs-comment">// 处理边界条件</span><br>                    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>)&#123;<br>                        dp[i][j] = <span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        dp[i][j] = <span class="hljs-built_in">min</span>(&#123;dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]&#125;) + <span class="hljs-number">1</span>;<br>                    &#125;<br>                    ans = <span class="hljs-built_in">max</span>(ans, dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans * ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><h2 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>, head);<br>        ListNode* pre = dummy;<br>        ListNode* left = head;<br>        ListNode* right = left-&gt;next;<br><br>        <span class="hljs-keyword">while</span>(left &amp;&amp; right)&#123;<br>            ListNode* next = right-&gt;next;<br>            pre-&gt;next = right;<br>            right-&gt;next = left;<br>            left-&gt;next = next;<br>            pre = left;<br>            left = next;<br>            <span class="hljs-keyword">if</span>(left)&#123;<br>                right = left-&gt;next;<br>            &#125;  <br>        &#125; <br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>如果当前节点为空，或者当前节点的next为空，则递归结束，无需交换。否则递归得到当前节点的下下个节点转换后的头，当前节点指向它，当前节点的下个节点指向当前节点即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* newHead = head-&gt;next;<br>        head-&gt;next = <span class="hljs-built_in">swapPairs</span>(newHead-&gt;next);<br>        newHead-&gt;next = head;<br><br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n),空间复杂度主要取决于递归调用的栈空间。</li></ul><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/description/">爬楼梯</a></h2><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>, q = <span class="hljs-number">0</span>, r = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            p = q;<br>            q = r;<br>            r = p + q;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/description/">最大子数组和</a></h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>划分阶段：按照子序列的结尾位置进行阶段划分。</li><li>定义状态：dp[i]表示以<code>nums[i]</code>结尾的序列的最大和。</li><li>状态转移方程：<code>dp[i] = max(0, dp[i-1]) + nums[i]</code>。</li><li>初始条件：<code>dp[0] = nums[0]</code>。</li><li>返回结果：维护一个最大和变量。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 枚举数字</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, dp[i<span class="hljs-number">-1</span>]) + nums[i];<br>            ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>这种方法可以进一步优化，由于在计算dp[i]时只需要用到dp[i-1]，而前面的都无需维护，所以用一个变量记录dp[i-1]即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span> pre = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = pre;<br>        <span class="hljs-comment">// 枚举数字</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            pre = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, pre) + nums[i];<br>            ans = <span class="hljs-built_in">max</span>(ans, pre);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>维护四个变量：</p><ul><li>lSum：以l为左端点的最大子段和，lSum要么等于左子区间的lSum，要么等于左子区间的iSum+右子区间的lSum，取较大值。</li><li>rSum：以r为右端点的最大子段和，rSum要么等于右子区间的rSum，要么等于右子区间的iSum+左子区间的rSum，取较大值。</li><li>mSum：[l, r]区间的最大子段和：mSum可能是左子区间的mSum，也可能是右子区间的mSum，也可能跨越左右子区间，即左子区间的rSum+右子区间的lSum。</li><li>iSum：[l, r]整个区间和，等于左子区间的iSum+右子区间的iSum。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 维护四个状态</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Status</span>&#123;<br>        <span class="hljs-type">int</span> lSum, rSum, mSum, iSum;<br>    &#125;;<br><br>    <span class="hljs-comment">// 线段树的pushup操作</span><br>    <span class="hljs-function">Status <span class="hljs-title">pushUp</span><span class="hljs-params">(Status left, Status right)</span></span>&#123;<br>        <span class="hljs-type">int</span> lSum = <span class="hljs-built_in">max</span>(left.lSum, left.iSum + right.lSum);<br>        <span class="hljs-type">int</span> rSum = <span class="hljs-built_in">max</span>(right.rSum, right.iSum + left.rSum);<br>        <span class="hljs-type">int</span> iSum = left.iSum + right.iSum;<br>        <span class="hljs-type">int</span> mSum = <span class="hljs-built_in">max</span>(&#123;left.mSum, right.mSum, left.rSum + right.lSum&#125;);<br><br>        <span class="hljs-keyword">return</span> (Status)&#123;lSum, rSum, mSum, iSum&#125;;<br>    &#125;<br><br>        <span class="hljs-comment">// 获取子区间的和</span><br>    <span class="hljs-function">Status <span class="hljs-title">get</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(left == right)&#123;<br>            <span class="hljs-keyword">return</span> (Status)&#123;nums[left], nums[left], nums[left], nums[left]&#125;;<br>        &#125;<br>        <span class="hljs-comment">// 递归计算左右区间</span><br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        Status lSub = <span class="hljs-built_in">get</span>(nums, left, mid);<br>        Status rSub = <span class="hljs-built_in">get</span>(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-comment">// 合并</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pushUp</span>(lSub, rSub);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>).mSum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，把递归的过程看作是一颗二叉树的先序遍历。</li><li>空间复杂度：O(logn)，递归会使用 O(logn) 的栈空间，故渐进空间复杂度为 O(logn)。</li></ul><p>分治法不仅可以解决区间 [0,n−1]，还可以用于解决任意的子区间 [l,r] 的问题。如果我们把 [0,n−1] 分治下去出现的所有子区间的信息都用堆式存储的方式记忆化下来，即建成一棵真正的树之后，我们就可以在 O(logn) 的时间内求到任意区间内的答案，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在 O(logn) 的时间内求到任意区间内的答案，对于大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是线段树。</p><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a><a href="https://leetcode.cn/problems/permutations/description/">全排列</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><ul><li>递归终止条件：到达叶子节点，即<code>index == n</code>。</li><li>明确选择：固定当前元素<code>nums[index]</code>，与后面的元素进行交换，然后进行下一层递归，最后还原。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> index)</span></span>&#123;<br>        <span class="hljs-comment">// 递归终止</span><br>        <span class="hljs-keyword">if</span>(index == nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(nums);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 对于每一个元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-built_in">swap</span>(nums[index], nums[i]); <span class="hljs-comment">// 交换</span><br>            <span class="hljs-built_in">dfs</span>(nums, index + <span class="hljs-number">1</span>);   <span class="hljs-comment">// 固定index+1位的元素</span><br>            <span class="hljs-built_in">swap</span>(nums[index], nums[i]); <span class="hljs-comment">// 还原</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \cdot n!)$</li><li>空间复杂度：O(n)</li></ul><h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/description/">括号生成</a></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><ul><li>明确所有选择：每个位置上有2个选择，即<code>(</code>或者<code>)</code>，只有当左括号数量大于右括号数量时，当前位置才可以选择<code>)</code>。</li><li>明确终止条件：当前节点为叶子节点，即左括号右括号剩余数都是0.</li><li>传入参数：当前字符串，左括号剩余数，右括号剩余数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        string path;<br>        <span class="hljs-built_in">dfs</span>(path, n, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string path, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-comment">// 递归终止</span><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 选择左括号</span><br>        <span class="hljs-keyword">if</span>(left &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">dfs</span>(path + <span class="hljs-string">&quot;(&quot;</span>, left - <span class="hljs-number">1</span>, right);<br>        &#125;<br>        <span class="hljs-comment">// 选择右括号</span><br>        <span class="hljs-keyword">if</span>(right &gt; left)&#123;<br>            <span class="hljs-built_in">dfs</span>(path + <span class="hljs-string">&quot;)&quot;</span>, left, right - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$\frac{4^n}{\sqrt{n}}$。</li><li>空间复杂度：O(n)，返回值不计入。</li></ul><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">组合总和</a></h2><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><ul><li>明确所有选择：每个数字都可以被无限制的选取。</li><li>明确终止条件：当前和等于目标时终止，或者索引到最后一个元素。等于目标时将路径结果加入结果集。</li><li>传入参数：数组，目标，当前索引，当前路径，当前和。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(candidates, target, <span class="hljs-number">0</span>, path, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, <span class="hljs-type">int</span> sum)</span></span>&#123;<br>        <span class="hljs-comment">// 递归终止</span><br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index == candidates.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 不选择当前元素</span><br>        <span class="hljs-built_in">dfs</span>(candidates, target, index + <span class="hljs-number">1</span>, path, sum);<br><br>        <span class="hljs-comment">// 选择当前元素，但和不能大于目标</span><br>        <span class="hljs-keyword">if</span>(sum + candidates[index] &lt;= target)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(candidates[index]);<br>            <span class="hljs-built_in">dfs</span>(candidates, target, index, path, sum + candidates[index]);  <span class="hljs-comment">// 注意可以无限选择</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：上界是$O(n \cdot 2^n)$</li><li>空间复杂度：O(target)，除答案数组外，空间复杂度取决于递归的栈深度。</li></ul><h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">复原IP地址</a></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><ul><li>明确所有选择：针对字符串中的每个数字，通常面临两个选项。第1个选项是将当前字符拼接到当前分段数字的末尾，拼接之后的数字应该在0到255之间。第2个选项是当前字符作为一个新的分段数字的开始。需要注意的是，一个IP地址最多只有4个分段数字，并且当开始一个新的分段数字时前一个分段数字不能是空的。</li><li>明确终止条件：完成一次ip地址的复原，即index到达最后，且分段点数量达到3，且当前分段合法。</li><li>传入参数：字符串，当前索引，当前分段，分段数，ip地址字符串。</li></ul><p>子段合法标准：数值小于等于255且要么等于0要么第一个字符不为0.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(s, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> index, string seg, <span class="hljs-type">int</span> segI, string ip)</span></span>&#123;<br>        <span class="hljs-comment">// 加入结果集</span><br>        <span class="hljs-keyword">if</span>(index == s.<span class="hljs-built_in">length</span>() &amp;&amp; segI == <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">isValid</span>(seg))&#123;<br>            res.<span class="hljs-built_in">push_back</span>(ip + seg);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index &lt; s.<span class="hljs-built_in">length</span>() &amp;&amp; segI &lt;= <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-type">char</span> ch = s[index];<br>            <span class="hljs-comment">// 后续字符加到当前子段</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(seg + ch))&#123;<br>                <span class="hljs-built_in">dfs</span>(s, index + <span class="hljs-number">1</span>, seg + ch, segI, ip);<br>            &#125;<br>            <span class="hljs-comment">// 重新开启新子段</span><br>            <span class="hljs-keyword">if</span>(seg.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; segI &lt; <span class="hljs-number">3</span>)&#123;<br>                <span class="hljs-built_in">dfs</span>(s, index + <span class="hljs-number">1</span>, <span class="hljs-built_in">string</span>(<span class="hljs-number">1</span>, ch), segI + <span class="hljs-number">1</span>, ip + seg +<span class="hljs-string">&#x27;.&#x27;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string seg)</span></span>&#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-built_in">stoi</span>(seg);<br>        <span class="hljs-keyword">if</span>(num &lt;= <span class="hljs-number">255</span> &amp;&amp; (seg == <span class="hljs-string">&quot;0&quot;</span> || seg[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;0&#x27;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(2^n)$</li><li>空间复杂度：O(n)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一节的题之前基本上都做过，但这次做思路还是会不清晰，以后不能只是盲目地刷题，每周末要抽时间回顾一下本周做过的题。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>面试篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07.02 第 073 ~ 074 题（ 第 05 ~ 08 天）</title>
    <link href="/2024/11/06/posts/0702/"/>
    <url>/2024/11/06/posts/0702/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="07-02-第-073-074-题（-第-05-08-天）"><a href="#07-02-第-073-074-题（-第-05-08-天）" class="headerlink" title="07.02 第 073 ~ 074 题（ 第 05 ~ 08 天）"></a>07.02 第 073 ~ 074 题（ 第 05 ~ 08 天）</h1><h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">路径总和</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>深度优先遍历：</p><ul><li>如果当前节点为空，返回false。</li><li>否则更新<code>targetSum -= root-&gt;val</code>；</li><li>当前节点是叶子节点，如果<code>targetSum == 0</code>，返回true，否则返回false。</li><li>递归左子树或右子树。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        targetSum -= root-&gt;val;<br>        <span class="hljs-comment">// 如果是叶子节点</span><br>        <span class="hljs-keyword">if</span>(root-&gt; left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(targetSum == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 否则递归左右子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, targetSum) || <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, targetSum);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="路径总和II"><a href="#路径总和II" class="headerlink" title="路径总和II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">路径总和II</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>与上一题类似，需要一个数组去存储路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> targetSum) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(root, targetSum, <span class="hljs-number">0</span>, res, path);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum, <span class="hljs-type">int</span> curSum, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="hljs-type">int</span>&gt; path)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        curSum += root-&gt;val;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-comment">// 如果是叶子节点</span><br>        <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(curSum == targetSum)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(path);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, targetSum, curSum, res, path);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, targetSum, curSum, res, path);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(n)</li></ul><blockquote><p>[!NOTE]<br>想一想path带不带<code>&amp;</code>的区别。</p></blockquote><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a></h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>检查左右子树是否相等:</p><ul><li>左右子树有一个为空，不相等；都为空，相等。</li><li>检查左右子树值以及左子树的右子树和右子树的左子树是否相等，以及左子树的左子树和右子树的右子树。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isEqual</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(TreeNode* leftT, TreeNode* rightT)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(leftT == <span class="hljs-literal">nullptr</span> || rightT == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> leftT == rightT;<br>        &#125;<br>        <span class="hljs-keyword">return</span> leftT-&gt;val == rightT-&gt;val &amp;&amp; <span class="hljs-built_in">isEqual</span>(leftT-&gt;left, rightT-&gt;right) &amp;&amp; <span class="hljs-built_in">isEqual</span>(leftT-&gt;right, rightT-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>首先引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(root, root);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode* leftT, TreeNode* rightT)</span></span>&#123;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(leftT);<br>        que.<span class="hljs-built_in">push</span>(rightT);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* leftNode = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            TreeNode* rightNode = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 为空</span><br>            <span class="hljs-keyword">if</span>(leftNode == <span class="hljs-literal">nullptr</span> &amp;&amp; rightNode == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 其中有一个为空或者值不相等，返回false</span><br>            <span class="hljs-keyword">if</span>((leftNode == <span class="hljs-literal">nullptr</span> || rightNode == <span class="hljs-literal">nullptr</span>) || leftNode-&gt;val != rightNode-&gt;val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            que.<span class="hljs-built_in">push</span>(leftNode-&gt;left);<br>            que.<span class="hljs-built_in">push</span>(rightNode-&gt;right);<br>            que.<span class="hljs-built_in">push</span>(leftNode-&gt;right);<br>            que.<span class="hljs-built_in">push</span>(rightNode-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><blockquote><p>[!NOTE]<br>有空看一下<a href="https://leetcode.cn/link/?target=https://www.bilibili.com/video/BV1UD4y1Y769/">递归算法讲解1</a>和<a href="https://leetcode.cn/link/?target=https://www.bilibili.com/video/BV18M411z7bb/">递归算法讲解2</a></p></blockquote><h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">二叉树中的最大路径和</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>用一个dfs函数求到当前节点的链的和，也就是中间不能拐弯，即当前节点值加左右子树的较大值。最后求直径和，即左子树链值加右子树链值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = INT_MIN;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">// 返回链和，途中更新ans</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftLen = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(root-&gt;left), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> rightLen = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(root-&gt;right), <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 更新答案</span><br>        ans = <span class="hljs-built_in">max</span>(ans, leftLen + rightLen + root-&gt;val);<br>        <span class="hljs-comment">// 返回链和</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftLen, rightLen) + root-&gt;val;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">二叉树的右视图</a></h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>如果当前节点为空，结束遍历，否则，先递归右子树，再递归左子树，当某个深度首次到达时，对应的节点就在右视图中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> depth)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(depth == ans.<span class="hljs-built_in">size</span>())&#123;<br>             ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, depth + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>层序遍历，取每一层最右边的节点即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br><br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                <span class="hljs-comment">// 如果是这一层的最后一个节点</span><br>                <span class="hljs-keyword">if</span>(i == size - <span class="hljs-number">1</span>)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                &#125;<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);             <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">翻转二叉树</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>如果节点为空，就不用翻转；否则递归翻转左右子树，然后再反转左右子树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        TreeNode* leftT = <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        TreeNode* rightT = <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        root-&gt;left = rightT;<br>        root-&gt;right = leftT;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>递归思路：当前序遍历数组为空时，返回空。否则在中序遍历数组中找到当前根的位置，并将其分成左右两棵子树，根据左右子树的节点数将前序、中序数组都分成左右子树两部分，然后递归得到左右子树的根，再让当前根连接左右子树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(preorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-comment">// 根节点</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 在中序遍历中找到它</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(; i &lt; inorder.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(inorder[i] == root-&gt;val)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 计算左右子树节点数</span><br>        <span class="hljs-type">int</span> leftSize = i - <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 计算左右子树的前序、中序遍历数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftPre</span><span class="hljs-params">(preorder.begin() + <span class="hljs-number">1</span>, preorder.begin() + <span class="hljs-number">1</span> + leftSize)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightPre</span><span class="hljs-params">(preorder.begin() + <span class="hljs-number">1</span> + leftSize, preorder.end())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftIn</span><span class="hljs-params">(inorder.begin(), inorder.begin() + leftSize)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightIn</span><span class="hljs-params">(inorder.begin() + <span class="hljs-number">1</span> + leftSize, inorder.end())</span></span>;<br>        <span class="hljs-comment">// 递归遍历得到左右子树的根</span><br>        TreeNode* left = <span class="hljs-built_in">buildTree</span>(leftPre, leftIn);<br>        TreeNode* right = <span class="hljs-built_in">buildTree</span>(rightPre, rightIn);<br>        root-&gt;left = left;<br>        root-&gt;right = right;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$，最坏情况下二叉树是一条链，我们需要递归 O(n) 次，每次都需要 O(n) 的时间查找 preorder[0] 和复制数组。</li><li>空间复杂度：$O(n^2)$。</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>用一个哈希表（或者数组）预处理 inorder 每个元素的下标，这样就可以 O(1) 查到 preorder[0] 在 inorder 的位置，从而 O(1) 知道左子树的大小。</li><li>把递归参数改成子数组下标区间（左闭右开区间）的左右端点，从而避免复制数组。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-comment">// 哈希表预存储</span><br>        <span class="hljs-type">int</span> n = preorder.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; index;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            index[inorder[i]] = i;<br>        &#125;<br><br>        function&lt;TreeNode*(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> preLeft, <span class="hljs-type">int</span> preRight, <span class="hljs-type">int</span> inLeft, <span class="hljs-type">int</span> inRight) -&gt; TreeNode*&#123;<br>            <span class="hljs-comment">// 递归结束</span><br>            <span class="hljs-keyword">if</span>(preLeft == preRight)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-comment">// O(1)时间在中序遍历中找到根节点</span><br>            <span class="hljs-type">int</span> leftSize = index[preorder[preLeft]] - inLeft;<br>            <span class="hljs-comment">// 递归遍历左右子树</span><br>            TreeNode* left = <span class="hljs-built_in">dfs</span>(preLeft + <span class="hljs-number">1</span>, preLeft + <span class="hljs-number">1</span> + leftSize, inLeft, inLeft + leftSize);<br>            TreeNode* right = <span class="hljs-built_in">dfs</span>(preLeft + <span class="hljs-number">1</span> + leftSize, preRight, inLeft + leftSize + <span class="hljs-number">1</span>, inRight);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[preLeft], left, right);<br>        &#125;;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, n, <span class="hljs-number">0</span>, n);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">验证二叉搜索树</a></h2><p>虽然题目是 int 类型，但开始递归的时候，left 需要比所有节点值都要小，right 需要比所有节点值都要大，如果节点值刚好是 int 的最小值&#x2F;最大值，就没有这样的 left 和 right 了，所以需要用 long 类型。</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hepler</span>(root, LLONG_MIN, LLONG_MAX);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hepler</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">long</span> <span class="hljs-type">long</span> left, <span class="hljs-type">long</span> <span class="hljs-type">long</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> x = root-&gt;val;<br>        <span class="hljs-keyword">if</span>(x &lt;= left || x &gt;= right)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hepler</span>(root-&gt;left, left, x) &amp;&amp; <span class="hljs-built_in">hepler</span>(root-&gt;right, x, right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> pre = LLONG_MIN;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isValidBST</span>(root-&gt;left) || root-&gt;val &lt;= pre)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        pre = root-&gt;val;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isValidBST</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">平衡二叉树</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>计算左子树深度，计算右子树深度，如果相差大于1则返回-1，否则返回左右子树高度。最后判断root的高度是否为-1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">checkBalance</span>(root) != <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">checkBalance</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">checkBalance</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 左子树不平衡，直接返回</span><br>        &#125;<br><br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">checkBalance</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (right == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 右子树不平衡，直接返回</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(left - right) &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 当前节点不平衡</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 返回当前节点的高度</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">岛屿数量</a></h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>DFS 有两个要素：「访问相邻结点」和「判断 base case」。网格结构的相邻结点就是上下左右四个，边界是超出网格范围的格子。</p><p>网格结构的 DFS 与二叉树的 DFS 最大的不同之处在于，遍历中可能遇到遍历过的结点。这是因为，网格结构本质上是一个「图」，在图中遍历时，自然可能遇到重复遍历结点。避免这样的重复遍历，需要标记已经遍历过的格子。以岛屿问题为例，我们需要在所有值为 1 的陆地格子上做 DFS 遍历。每走过一个陆地格子，就把格子的值改为 2，这样当我们遇到 2 的时候，就知道这是遍历过的格子了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    ans++;<br>                    <span class="hljs-built_in">dfs</span>(grid, i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span></span>&#123;<br>        <span class="hljs-comment">// 边界处理</span><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isArea</span>(grid, row, col))&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 避免重复遍历</span><br>        <span class="hljs-keyword">if</span>(grid[row][col] != <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        grid[row][col] = <span class="hljs-string">&#x27;2&#x27;</span>;   <span class="hljs-comment">// 标记已遍历过</span><br><br>        <span class="hljs-comment">// 访问上下左右四个节点</span><br>        <span class="hljs-built_in">dfs</span>(grid, row - <span class="hljs-number">1</span>, col);<br>        <span class="hljs-built_in">dfs</span>(grid, row + <span class="hljs-number">1</span>, col);<br>        <span class="hljs-built_in">dfs</span>(grid, row, col - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(grid, row, col + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 判断是否越界</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isArea</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span></span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;=<span class="hljs-number">0</span> &amp;&amp; col &lt; n)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)，最坏情况下，整个棋盘是一个岛屿，递归的深度会达到mn。</li></ul><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的 1 都会被标记为 2。直到队列为空，搜索结束。最终岛屿的数量就是我们进行广度优先搜索的次数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-comment">// 广度优先搜索</span><br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    ans++;<br>                    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;  <span class="hljs-comment">// 队列存储坐标</span><br>                    que.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>                    grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>;   <span class="hljs-comment">// 标记已访问</span><br>                    <span class="hljs-comment">// 广度优先</span><br>                    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>                        <span class="hljs-keyword">auto</span> rc = que.<span class="hljs-built_in">front</span>();<br>                        que.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-type">int</span> row = rc.first, col = rc.second;<br>                        <span class="hljs-comment">// 将上下左右四个放入队列</span><br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isArea</span>(grid, row - <span class="hljs-number">1</span>, col))&#123;<br>                            que.<span class="hljs-built_in">push</span>(&#123;row - <span class="hljs-number">1</span>, col&#125;);<br>                            grid[row<span class="hljs-number">-1</span>][col] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isArea</span>(grid, row + <span class="hljs-number">1</span>, col))&#123;<br>                            que.<span class="hljs-built_in">push</span>(&#123;row + <span class="hljs-number">1</span>, col&#125;);<br>                            grid[row+<span class="hljs-number">1</span>][col] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isArea</span>(grid, row, col - <span class="hljs-number">1</span>))&#123;<br>                            que.<span class="hljs-built_in">push</span>(&#123;row, col - <span class="hljs-number">1</span>&#125;);<br>                            grid[row][col<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isArea</span>(grid, row, col + <span class="hljs-number">1</span>))&#123;<br>                            que.<span class="hljs-built_in">push</span>(&#123;row, col + <span class="hljs-number">1</span>&#125;);<br>                            grid[row][col + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                        &#125;                                                <br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否越界</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isArea</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span></span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;=<span class="hljs-number">0</span> &amp;&amp; col &lt; n &amp;&amp; grid[row][col] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>isArea逻辑优化：在其中添加对<code>grid[row][col] == &#39;1&#39;</code>的判断，这样在上下左右四个节点的时候无需再判断，减少不必要的递归。</p><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(min(m,n))，这里可以理解为，广度优先每次向外扩展一圈，直到超出网格边界或不为1，那么最坏情况下，超过较短边界的时候程序就会结束。</li></ul><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则将其与相邻四个方向上的 1 在并查集中进行合并。最终岛屿的数量就是并查集中连通分量的数目。</p><p>在 C++ 中，为成员函数加上 const 表示该函数不会修改类的成员变量，从而保证这个函数是“只读”的，适合用于访问类的状态而不改变它。具体到你的代码，getCount() 是用来获取岛屿数量的，只需读取 count 值，不涉及任何修改操作，所以可以在其声明后加上 const。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<br>    vector&lt;<span class="hljs-type">int</span>&gt; rank;<br>    <span class="hljs-type">int</span> count;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid) &#123;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-comment">// 初始化并查集</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    parent.<span class="hljs-built_in">push_back</span>(i * n + j);<br>                    count++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    parent.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>                &#125;<br>                rank.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(parent[i] != i)&#123;<br>            parent[i] = <span class="hljs-built_in">find</span>(parent[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[i];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-type">int</span> rootx = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-type">int</span> rooty = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-comment">// 按秩合并</span><br>        <span class="hljs-keyword">if</span>(rootx != rooty)&#123;<br>            <span class="hljs-keyword">if</span>(rank[rootx] &lt; rank[rooty])&#123;<br>                <span class="hljs-built_in">swap</span>(rootx, rooty);<br>            &#125;<br>            parent[rooty] = rootx;<br>            <span class="hljs-keyword">if</span>(rank[rootx] == rank[rooty])&#123;<br>                rank[rootx] += <span class="hljs-number">1</span>;<br>            &#125;<br>            count--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(grid)</span></span>; <span class="hljs-comment">// 初始化并查集</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>;   <span class="hljs-comment">// 标记已访问过</span><br>                    <span class="hljs-comment">// 合并上下左右节点</span><br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isArea</span>(grid, i - <span class="hljs-number">1</span>, j))&#123;<br>                        uf.<span class="hljs-built_in">unite</span>(i * n + j, (i<span class="hljs-number">-1</span>) * n + j);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isArea</span>(grid, i + <span class="hljs-number">1</span>, j))&#123;<br>                        uf.<span class="hljs-built_in">unite</span>(i * n + j, (i+<span class="hljs-number">1</span>) * n + j);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isArea</span>(grid, i, j - <span class="hljs-number">1</span>))&#123;<br>                        uf.<span class="hljs-built_in">unite</span>(i * n + j, i * n + (j<span class="hljs-number">-1</span>));<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isArea</span>(grid, i, j + <span class="hljs-number">1</span>))&#123;<br>                        uf.<span class="hljs-built_in">unite</span>(i * n + j, i * n + (j+<span class="hljs-number">1</span>));<br>                    &#125;                                                            <br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> uf.<span class="hljs-built_in">getCount</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否越界</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isArea</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span></span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;=<span class="hljs-number">0</span> &amp;&amp; col &lt; n &amp;&amp; grid[row][col] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(MN×α(MN))，其中 M 和 N 分别为行数和列数。注意当使用路径压缩（见 find 函数）和按秩合并（见数组 rank）实现并查集时，单次操作的时间复杂度为 α(MN)，其中 α(x) 为反阿克曼函数，当自变量 x 的值在人类可观测的范围内（宇宙中粒子的数量）时，函数 α(x) 的值不会超过 5，因此也可以看成是常数时间复杂度。</li><li>空间复杂度：O(MN)，这是并查集需要使用的空间。</li></ul><h2 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a><a href="https://leetcode.cn/problems/max-area-of-island/">岛屿的最大面积</a></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>与上面的思想类似，但需要在每次进入一个岛屿时维护当前岛屿面积的变量，并不断更新。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-type">int</span> area = <span class="hljs-number">0</span>;<br>                    <span class="hljs-built_in">dfs</span>(grid, i, j, area);<br>                    ans = <span class="hljs-built_in">max</span>(ans, area);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span>&amp; area)</span></span>&#123;<br>        <span class="hljs-comment">// 边界处理</span><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isArea</span>(grid, row, col))&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 避免重复遍历</span><br>        <span class="hljs-keyword">if</span>(grid[row][col] != <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 标记已访问</span><br>        grid[row][col] = <span class="hljs-number">2</span>;<br>        area++;<br>        <span class="hljs-comment">// 访问上下左右</span><br>        <span class="hljs-built_in">dfs</span>(grid, row - <span class="hljs-number">1</span>, col, area);<br>        <span class="hljs-built_in">dfs</span>(grid, row + <span class="hljs-number">1</span>, col, area);<br>        <span class="hljs-built_in">dfs</span>(grid, row, col - <span class="hljs-number">1</span>, area);<br>        <span class="hljs-built_in">dfs</span>(grid, row, col + <span class="hljs-number">1</span>, area);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isArea</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span></span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(row &gt;=<span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; n)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><h2 id="求根节点到叶节点的数字之和"><a href="#求根节点到叶节点的数字之和" class="headerlink" title="求根节点到叶节点的数字之和"></a><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/">求根节点到叶节点的数字之和</a></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>递归思路：当前节点为叶子节点，将当前路径和加入答案，结束递归。否则递归计算左右子树的和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node, <span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        x = x * <span class="hljs-number">10</span> + node-&gt;val;<br>        <span class="hljs-comment">// 是叶子结点</span><br>        <span class="hljs-keyword">if</span>(node-&gt;left == node-&gt;right)&#123;<br>            ans += x;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(node-&gt;left, x);<br>        <span class="hljs-built_in">dfs</span>(node-&gt;right, x);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以用有返回值的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        x = x * <span class="hljs-number">10</span> + root-&gt;val;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == root-&gt;right) &#123; <span class="hljs-comment">// root 是叶子节点</span><br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sumNumbers</span>(root-&gt;left, x) + <span class="hljs-built_in">sumNumbers</span>(root-&gt;right, x);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一部分的题目主要是对二叉树的深度优先遍历，练习了一些递归的写法，在岛屿题目中学到了网格的遍历方法，又复习了一下并查集。之后还需要再复习，多练习一些相关的题目。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>面试篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07.01 第 051 ~ 072 题（第 01 ~ 04 天）</title>
    <link href="/2024/11/01/posts/0701/"/>
    <url>/2024/11/01/posts/0701/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="07-01-第-051-072-题（第-01-04-天）"><a href="#07-01-第-051-072-题（第-01-04-天）" class="headerlink" title="07.01 第 051 ~ 072 题（第 01 ~ 04 天）"></a>07.01 第 051 ~ 072 题（第 01 ~ 04 天）</h1><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">无重复字符的最长子串</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>使用哈希表+滑动窗口。如果当前字符没有在哈希表中出现过，就将其加入哈希表，右指针继续向右，right-left+1是当前长度，不断更新最大长度；否则不断向右滑动左窗口，直至遇到哈希表内没有当前元素，再把当前元素加入哈希表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-comment">// 定义哈希表，左右指针</span><br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历字符串</span><br>        <span class="hljs-keyword">while</span>(right &lt; n)&#123;<br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">find</span>(s[right]) == hash.<span class="hljs-built_in">end</span>())&#123;<br>                hash[s[right]] = <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                hash[s[right]]++;<br>            &#125;<br>            <span class="hljs-comment">// 左指针滑动至没有重复字符</span><br>            <span class="hljs-keyword">while</span>(hash[s[right]] &gt; <span class="hljs-number">1</span>)&#123;<br>                hash[s[left]]--;<br>                left++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文子串</a></h2><h3 id="中心扩散"><a href="#中心扩散" class="headerlink" title="中心扩散"></a>中心扩散</h3><p>可以用从中心向两边扩展的方法，对每一个位置都进行这样的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-comment">// 维护当前长度和最大长度</span><br>        <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>, maxLen = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 维护最长子串的起始指针</span><br>        <span class="hljs-type">int</span> maxStart = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历字符串：</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-comment">// 定义左右指针</span><br>            <span class="hljs-type">int</span> left = i - <span class="hljs-number">1</span>, right = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 偶数个，向左扩展</span><br>            <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; s[left] == s[i])&#123;<br>                len++;<br>                left--;<br>            &#125;<br>            <span class="hljs-comment">// 向右扩展</span><br>            <span class="hljs-keyword">while</span>(right &lt; n &amp;&amp; s[right] == s[i])&#123;<br>                len++;<br>                right++;<br>            &#125;<br>            <span class="hljs-comment">// 奇数个，向两边扩展</span><br>            <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp;right &lt; n &amp;&amp; s[left] == s[right])&#123;<br>                len += <span class="hljs-number">2</span>;<br>                left--;<br>                right++;<br>            &#125;<br>            <span class="hljs-comment">// 更新最大长度</span><br>            <span class="hljs-keyword">if</span>(len &gt; maxLen)&#123;<br>                maxLen = len;<br>                maxStart = left + <span class="hljs-number">1</span>;<br>            &#125;<br>            len = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(maxStart, maxLen);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(1)</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li><p>划分阶段：按照区间长度进行阶段划分。</p></li><li><p>定义状态：dp[i][j]表示s[i:j]是否是回文的。</p></li><li><p>状态转移方程：</p><p>$s[i] &#x3D; s[j], dp[i][j] &#x3D; \begin{cases} true &amp; j-i \leq 2 \cr dp[i+1][j - 1] &amp; else \end{cases}$</p></li><li><p>初始条件：dp[i][j]&#x3D;false.</p></li><li><p>返回结果：s[maxStart:maxStart+maxLen]</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> maxLen = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> maxStart = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 定义状态数组</span><br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n));<br>        <span class="hljs-comment">// 枚举结束位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-comment">// 枚举起始位置</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; j; i++)&#123;<br>                <span class="hljs-keyword">if</span>(s[i] == s[j])&#123;<br>                    <span class="hljs-keyword">if</span>(j - i &lt;= <span class="hljs-number">2</span>)&#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>];<br>                    &#125;                    <br>                &#125;<br>                <span class="hljs-comment">// 更新最大长度</span><br>                <span class="hljs-keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLen)&#123;<br>                    maxLen = j - i + <span class="hljs-number">1</span>;<br>                    maxStart = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(maxStart, maxLen);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h3><h2 id="字符串转换整数"><a href="#字符串转换整数" class="headerlink" title="字符串转换整数"></a><a href="https://leetcode.cn/problems/string-to-integer-atoi/">字符串转换整数</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ol><li>空格：读入字符串并丢弃无用的前导空格（” “）</li><li>符号：检查下一个字符（假设还未到字符末尾）为 ‘-‘ 还是 ‘+’。如果两者都不存在，则假定结果为正。</li><li>转换：通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾。如果没有读取数字，则结果为0。</li><li>舍入：如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被舍入为 −231 ，大于 231 − 1 的整数应该被舍入为 231 − 1 。</li><li>读取在第一个非数字字符处停止。</li></ol><p>自己写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 跳过空格</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; s[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++;<br>        <span class="hljs-comment">// 获取符号</span><br>        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;-&#x27;</span> || s[i] == <span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br>            flag = s[i] == <span class="hljs-string">&#x27;-&#x27;</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br>            i++;<br>        &#125;<br>        <span class="hljs-comment">// 跳过前导0</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; <span class="hljs-built_in">isdigit</span>(s[i]))&#123;<br>            num = num * <span class="hljs-number">10</span> + (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            i++;<br>            <span class="hljs-comment">// 舍入</span><br>            <span class="hljs-keyword">if</span>(flag * num &gt; INT_MAX) <span class="hljs-keyword">return</span> INT_MAX;<br>            <span class="hljs-keyword">if</span>(flag * num &lt; INT_MIN) <span class="hljs-keyword">return</span> INT_MIN;<br>        &#125;<br>        num *= flag;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="自动机"><a href="#自动机" class="headerlink" title="自动机"></a>自动机</h3><h2 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">反转字符串中的单词</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>用一个额外的字符串处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 遍历</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(i == n)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 寻找第一个不是空格的</span><br>            <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; s[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++;<br>            <span class="hljs-comment">// 截断单词</span><br>            string tmp;<br>            <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; s[i] != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                tmp += s[i];<br>                i++;<br>            &#125;<br>            <span class="hljs-built_in">reverse</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">if</span>(tmp != <span class="hljs-string">&quot;&quot;</span>)&#123;<br>                ans += tmp + <span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        ans = ans.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, ans.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a><a href="https://leetcode.cn/problems/multiply-strings/">字符串相乘</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>模拟。可以先将字符串反转，从前向后就是从低位到高位的运算。可以在高位的计算结果后补零，这样方便结果相加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">multiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num1 == <span class="hljs-string">&quot;0&quot;</span> || num2 == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;  <span class="hljs-comment">// 处理边界情况</span><br><br>        <span class="hljs-type">int</span> n1 = num1.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> n2 = num2.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(n1 + n2, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 初始化结果数组</span><br><br>        <span class="hljs-comment">// 反向遍历字符串进行乘法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n1 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n2 - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-type">int</span> mul = (num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * (num2[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                <span class="hljs-type">int</span> sum = mul + result[i + j + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 当前位的乘法结果加上之前的值</span><br>                result[i + j + <span class="hljs-number">1</span>] = sum % <span class="hljs-number">10</span>;  <span class="hljs-comment">// 存储当前位</span><br>                result[i + j] += sum / <span class="hljs-number">10</span>;  <span class="hljs-comment">// 处理进位</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 构建结果字符串</span><br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : result) &#123;<br>            <span class="hljs-keyword">if</span> (!(res.<span class="hljs-built_in">empty</span>() &amp;&amp; num == <span class="hljs-number">0</span>)) &#123;  <span class="hljs-comment">// 跳过前导零</span><br>                res += <span class="hljs-built_in">to_string</span>(num);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;0&quot;</span> : res;  <span class="hljs-comment">// 如果结果为空则返回&quot;0&quot;</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(m+n)</li></ul><h2 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a><a href="https://leetcode.cn/problems/longest-common-prefix/">最长公共前缀</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>纵向遍历，从第一个字符开始，比较每一个字符串的第一个字符是否相等。若相等，则比较第二个字符，若不相等，则结束循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>        string s0 = strs[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; s0.<span class="hljs-built_in">size</span>(); j++)&#123;<br>            <span class="hljs-keyword">for</span>(string&amp; s : strs)&#123;<br>                <span class="hljs-keyword">if</span>(j == s.<span class="hljs-built_in">size</span>() || s[j] != s0[j])&#123;<br>                    <span class="hljs-keyword">return</span> s0.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s0;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(1)</li></ul><h2 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">二叉树的前序遍历</a></h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><ol><li>判断二叉树是否为空，为空则直接返回。</li><li>初始化维护一个栈，将根节点入栈。</li><li>当栈不为空时：<ul><li>弹出栈顶元素 node，并访问该元素。</li><li>如果 node 的右子树不为空，则将 node 的右子树入栈。</li><li>如果 node 的左子树不为空，则将 node 的左子树入栈。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        stack&lt;TreeNode*&gt; stk;<br>        stk.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* node = stk.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 弹出栈顶</span><br>            stk.<span class="hljs-built_in">pop</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(node-&gt;val);   <span class="hljs-comment">// 访问栈顶</span><br>            <span class="hljs-keyword">if</span>(node-&gt;right)&#123;<br>                stk.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node-&gt;left)&#123;<br>                stk.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><p>在二叉树遍历的深度优先遍历中，分析了如何用递归和非递归方式实现遍历二叉树，但是那些方法都无法做到空间复杂度为 O(1)，对于递归方法，遍历时用到了函数栈，而对于非递归方法，则是直接申请了栈，这两种方法的空间复杂度均与树的高度相关，设树的高度为 h，则空间复杂度为 O(h)。</p><p>二叉树上的很多节点都有大量的空闲指针（如叶节点就有两个空闲指针），比如某些节点没有右孩子节点，那么这个节点的 right 指针就指向 null，我们将之称为空闲状态，而Morris遍历就是使用了这些空闲指针。</p><ol><li>若 cur &#x3D;&#x3D; null，则过程停止，否则继续下面的过程；</li><li>若 cur 无左子树，则令 cur &#x3D; cur.right；</li><li>若 cur 有左子树，则找到 cur 左子树上最右的节点，记作 mostRight：<ul><li>若 mostRight.right &#x3D;&#x3D; null，则令 mostRight.right &#x3D; cur，即让 mostRight 的 right 指针指向当前节点 cur，然后令 cur &#x3D; cur.left；</li><li>若 mostRight.right &#x3D;&#x3D; cur， 则令 mostRight.right &#x3D; null，即让 mostRight 的 right 指针指向空，然后令 cur &#x3D; cur.right。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            <span class="hljs-comment">// 无左子树，则指向右子树</span><br>            <span class="hljs-keyword">if</span>(!cur-&gt;left)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                cur = cur-&gt;right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 有左子树，找到左子树最右边的节点</span><br>                TreeNode* leftNode = cur-&gt;left;<br>                <span class="hljs-keyword">while</span>(leftNode-&gt;right &amp;&amp; leftNode-&gt;right != cur)&#123;<br>                    leftNode = leftNode-&gt;right;<br>                &#125;<br>                <span class="hljs-comment">// 如果指向空</span><br>                <span class="hljs-keyword">if</span>(leftNode-&gt;right == <span class="hljs-literal">NULL</span>)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                    leftNode-&gt;right = cur;<br>                    cur = cur-&gt;left;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(leftNode-&gt;right == cur)&#123;<br>                    leftNode-&gt;right = <span class="hljs-literal">NULL</span>;<br>                    cur = cur-&gt;right;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">二叉树的中序遍历</a></h2><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><ol><li>判断二叉树是否为空，为空则直接返回。</li><li>初始化维护一个栈.</li><li>当栈不为空或当前结点不为空：<ul><li>当当前节点不为空，将当前节点指向它的左子树，并入栈。</li><li>弹出栈顶元素 node，并访问该元素。</li><li>尝试访问右子树。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-comment">// 维护栈</span><br>        stack&lt;TreeNode*&gt; stk;<br>        <span class="hljs-keyword">while</span>(root || !stk.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(root)&#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            <span class="hljs-comment">// 当栈不为空</span><br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();    <br>            ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);   <span class="hljs-comment">// 访问当前元素            </span><br>            <span class="hljs-comment">// 尝试访问右子树</span><br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="Morris遍历-1"><a href="#Morris遍历-1" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><ol><li>若 cur &#x3D;&#x3D; null，则过程停止，否则继续下面的过程；</li><li>若 cur 无左子树，则访问当前元素，并令 cur &#x3D; cur.right；</li><li>若 cur 有左子树，则找到 cur 左子树上最右的节点，记作 mostRight：<ul><li>若 mostRight.right &#x3D;&#x3D; null，则令 mostRight.right &#x3D; cur，即让 mostRight 的 right 指针指向当前节点 cur，然后令 cur &#x3D; cur.left；</li><li>若 mostRight.right &#x3D;&#x3D; cur， 说明我们已经遍历完的左子树，则访问当前元素，并令 mostRight.right &#x3D; null，即让 mostRight 的 right 指针指向空，然后令 cur &#x3D; cur.right。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span>(root)&#123;<br>            <span class="hljs-comment">// 如果左子树为空</span><br>            <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                root = root-&gt;right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 找到 cur 左子树上最右的节点</span><br>                TreeNode* leftNode = root-&gt;left;<br>                <span class="hljs-keyword">while</span>(leftNode-&gt;right &amp;&amp; leftNode-&gt;right != root)&#123;<br>                    leftNode = leftNode-&gt;right;<br>                &#125;<br>                <span class="hljs-comment">// 指向空，遍历左子树</span><br>                <span class="hljs-keyword">if</span>(leftNode-&gt;right == <span class="hljs-literal">NULL</span>)&#123;<br>                    leftNode-&gt;right = root;<br>                    root = root-&gt;left;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">// 左子树已经遍历完</span><br>                    ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                    leftNode-&gt;right = <span class="hljs-literal">NULL</span>;<br>                    root = root-&gt;right;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>使用一个队列辅助。当队列不为空，弹出节点，将其左右子树加入队列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        queue&lt;TreeNode*&gt; que;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> curSize = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; cur;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; curSize; i++)&#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                cur.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                que.<span class="hljs-built_in">pop</span>();<br><br>                <span class="hljs-keyword">if</span>(node-&gt;left)&#123;<br>                    que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node-&gt;right)&#123;<br>                    que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                &#125;                <br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title="二叉树的锯齿形层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/">二叉树的锯齿形层序遍历</a></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>反转偶数层的数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);   <br>        <br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> n = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; cur;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                cur.<span class="hljs-built_in">push_back</span>(node-&gt;val);   <span class="hljs-comment">// 访问当前元素</span><br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            <span class="hljs-comment">// 反转偶数层的</span><br>            <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-built_in">reverse</span>(cur.<span class="hljs-built_in">begin</span>(), cur.<span class="hljs-built_in">end</span>());<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p><img src="/2024/11/01/posts/0701/image.png" alt="Alt text"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回当前节点</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span> || root == p || root == q)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">// 递归</span><br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-comment">// 如果两边都能找到，公共最先就是当前节点</span><br>        <span class="hljs-keyword">if</span>(left &amp;&amp; right)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125; <br>        <span class="hljs-comment">// 如果左边能找到</span><br>        <span class="hljs-keyword">if</span>(left)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)，最坏情况下，二叉树是一条链，因此递归需要 O(n) 的栈空间。</li></ul><h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">二叉搜索树的最近公共祖先</a></h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><ul><li>如果p和q都小于当前节点值，则递归左子树。</li><li>如果p和q都大于当前节点值，则递归右子树。</li><li>如果分别位于不同子树上，则返回当前节点值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt;root-&gt;val)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)，最坏情况下，二叉搜索树退化成一条链（注意题目没有保证它是平衡树），因此递归需要 O(n) 的栈空间。</li></ul><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">二叉树的最大深度</a></h2><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>如果当前节点为空，返回0.否则递归左右子树，取较大值，再+1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">maxDepth</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">maxDepth</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)，最差情况下二叉树的高度为n，递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</li></ul><p>这道题也可以用层序遍历的思路去做，在每遍历完一层的时候，ans+1.</p><p>把上面的动态规划、马拉车、自动机方法学习一下。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>面试篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06.04 第 038 ~ 050 题（第 13 ~ 16 天）</title>
    <link href="/2024/10/28/posts/0604/"/>
    <url>/2024/10/28/posts/0604/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="06-04-第-038-050-题（第-13-16-天）"><a href="#06-04-第-038-050-题（第-13-16-天）" class="headerlink" title="06.04 第 038 ~ 050 题（第 13 ~ 16 天）"></a>06.04 第 038 ~ 050 题（第 13 ~ 16 天）</h1><h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/description/">两数相加</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* cur = dummy;<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 &amp;&amp; l2)&#123;<br>            <span class="hljs-type">int</span> sum = l1-&gt;val + l2-&gt;val + carry;<br>            carry = sum / <span class="hljs-number">10</span>;<br>            ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            cur-&gt;next = node;<br>            cur = cur-&gt;next;<br>            l1 = l1-&gt;next;<br>            l2 = l2-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 剩余部分</span><br>        <span class="hljs-keyword">while</span>(l1)&#123;<br>            <span class="hljs-type">int</span> sum = l1-&gt;val + carry;<br>            carry = sum / <span class="hljs-number">10</span>;<br>            ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            cur-&gt;next = node;<br>            cur = cur-&gt;next;<br>            l1 = l1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(l2)&#123;<br>            <span class="hljs-type">int</span> sum = l2-&gt;val + carry;<br>            carry = sum / <span class="hljs-number">10</span>;<br>            ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            cur-&gt;next = node;<br>            cur = cur-&gt;next;<br>            l2 = l2-&gt;next;<br>        &#125;        <br>        <span class="hljs-comment">// 如果有进位</span><br>        <span class="hljs-keyword">if</span>(carry)&#123;<br>            ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(carry);<br>            cur-&gt;next = node;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(max(m, n))</li><li>空间复杂度：O(1)，注意返回值不计入空间复杂度。</li></ul><h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a><a href="https://leetcode.cn/problems/min-stack/">最小栈</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>用一个辅助栈来实现最小值的存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>    stack&lt;<span class="hljs-type">int</span>&gt; minStk;    <br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        minStk.<span class="hljs-built_in">push</span>(INT_MAX);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        stk.<span class="hljs-built_in">push</span>(val);<br>        minStk.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">min</span>(minStk.<span class="hljs-built_in">top</span>(), val));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        stk.<span class="hljs-built_in">pop</span>();<br>        minStk.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> minStk.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(val);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>如果我们想去掉辅助栈 minStk，可以使用一个变量来记录当前的最小值，然后在插入或删除时进行动态更新。我们可以在栈中保存上一个最小值。，从而在每次插入、删除、获取最小值时都只需要操作一个栈。以下是实现思路：</p><ul><li>在 push 操作时，如果新插入的元素小于或等于当前最小值，则将当前最小值入栈，并更新最小值为新元素。</li><li>在 pop 操作时，如果弹出的元素等于当前最小值，则需要将最小值恢复为栈中前一个最小值（即上次的最小值）。</li><li>在 getMin 操作时直接返回当前最小值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>    <span class="hljs-type">int</span> minVal;<br>    <br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        minVal = INT_MAX;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (val &lt;= minVal) &#123;<br>            stk.<span class="hljs-built_in">push</span>(minVal);  <span class="hljs-comment">// 保存当前最小值</span><br>            minVal = val;       <span class="hljs-comment">// 更新最小值</span><br>        &#125;<br>        stk.<span class="hljs-built_in">push</span>(val);           <span class="hljs-comment">// 入栈</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">top</span>() == minVal) &#123;  <span class="hljs-comment">// 如果弹出的是当前最小值</span><br>            stk.<span class="hljs-built_in">pop</span>();              <span class="hljs-comment">// 弹出当前最小值</span><br>            minVal = stk.<span class="hljs-built_in">top</span>();     <span class="hljs-comment">// 恢复上一个最小值</span><br>        &#125;<br>        stk.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> minVal;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(val);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;getMin();</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/description/">有效的括号</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>用栈来实现，如果是左括号就入栈，如果是右括号，检查栈顶元素是否匹配，如果不匹配，返回false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : s)&#123;<br>            <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;(&#x27;</span> || ch == <span class="hljs-string">&#x27;[&#x27;</span> || ch == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                stk.<span class="hljs-built_in">push</span>(ch);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">check</span>(stk.<span class="hljs-built_in">top</span>(), ch))&#123;<br>                    stk.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 检查栈是否为空</span><br>        <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">char</span> ch1, <span class="hljs-type">char</span> ch2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(ch1 == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; ch2 == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ch1 == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; ch2 == <span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ch1 == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; ch2 == <span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><blockquote><p>[!NOTE]<br>今天刷的题目都比较简单，需要注意的是最小栈那道题，在评论区看到有面试的时候问空间复杂度如何优化。</p></blockquote><h2 id="基本计算器II"><a href="#基本计算器II" class="headerlink" title="基本计算器II"></a><a href="https://leetcode.cn/problems/basic-calculator-ii/">基本计算器II</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果。</p><p>具体来说，遍历字符串 s，并用变量 preSign 记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据 preSign 来决定计算方式：</p><ul><li>加号：将数字压入栈；</li><li>减号：将数字的相反数压入栈；</li><li>乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果。</li></ul><p>代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新 preSign 为当前遍历的字符。</p><p>遍历完字符串 s 后，将栈中元素累加，即为该字符串表达式的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义数字栈</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-type">char</span> preSign = <span class="hljs-string">&#x27;+&#x27;</span>;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-comment">// 遍历字符串</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-comment">// 如果是数字</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(s[i]))&#123;<br>                num = num * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isdigit</span>(s[i]) &amp;&amp; s[i] != <span class="hljs-string">&#x27; &#x27;</span> || i == n<span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-keyword">switch</span>(preSign)&#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                        stk.<span class="hljs-built_in">push_back</span>(num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                        stk.<span class="hljs-built_in">push_back</span>(-num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                        stk.<span class="hljs-built_in">back</span>() *= num;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        stk.<span class="hljs-built_in">back</span>() /= num;<br>                &#125;<br>                preSign = s[i];<br>                num = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(stk.<span class="hljs-built_in">begin</span>(), stk.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">用栈实现队列</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>使用两个栈，inStack 用于输入，outStack 用于输出。</p><ul><li>push：放入inStack.</li><li>pop：如果 outStack 输出栈为空，将 inStack 输入栈元素依次取出，按顺序压入 outStack 栈。这样 outStack 栈的元素顺序和之前 inStack 元素顺序相反，outStack 顶层元素就是要取出的队头元素，将其移出，并返回该元素。如果 outStack 输出栈不为空，则直接取出顶层元素。</li><li>peek：如果 outStack 输出栈为空，将 inStack 输入栈元素依次取出，按顺序压入 outStack 栈。这样 outStack 栈的元素顺序和之前 inStack 元素顺序相反，outStack 顶层元素就是要取出的队头元素，无需移出，只返回该元素。如果 outStack 输出栈不为空，则直接返回顶层元素。</li><li>empty：如果 inStack 和 outStack 都为空，则队列为空，否则队列不为空。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; inStack;<br>    stack&lt;<span class="hljs-type">int</span>&gt; outStack;<br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        inStack.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(outStack.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-comment">// 将inStack元素逐个压入out</span><br>            <span class="hljs-keyword">while</span>(!inStack.<span class="hljs-built_in">empty</span>())&#123;<br>                outStack.<span class="hljs-built_in">push</span>(inStack.<span class="hljs-built_in">top</span>());<br>                inStack.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> num = outStack.<span class="hljs-built_in">top</span>();<br>        outStack.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> num;<br>        <span class="hljs-keyword">if</span>(outStack.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-comment">// 逐个弹出并压入</span><br>            <span class="hljs-keyword">while</span>(!inStack.<span class="hljs-built_in">empty</span>())&#123;<br>                outStack.<span class="hljs-built_in">push</span>(inStack.<span class="hljs-built_in">top</span>());<br>                inStack.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> outStack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(inStack.<span class="hljs-built_in">empty</span>() &amp;&amp; outStack.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue* obj = new MyQueue();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;peek();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(1)</li><li>空间复杂度：O(n)</li></ul><h2 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a><a href="https://leetcode.cn/problems/decode-string/">字符串解码</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;string&gt; cStack;<br>        stack&lt;<span class="hljs-type">int</span>&gt; nStack;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-comment">// 遍历字符串</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : s)&#123;<br>            <span class="hljs-comment">// 如果是数字，就累加</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(ch))&#123;<br>                num = num * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(ch - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 如果是左括号，将数字，当前字符串入栈，并清除这两个变量</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                cStack.<span class="hljs-built_in">push_back</span>(res);<br>                nStack.<span class="hljs-built_in">push</span>(num);<br>                res = <span class="hljs-string">&quot;&quot;</span>;<br>                num = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果是右括号，弹出字符串和数字</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>                string curStr = cStack.<span class="hljs-built_in">back</span>();<br>                cStack.<span class="hljs-built_in">pop_back</span>();<br>                <span class="hljs-type">int</span> curNum = nStack.<span class="hljs-built_in">top</span>();<br>                nStack.<span class="hljs-built_in">pop</span>();<br>                res = curStr + <span class="hljs-built_in">copyStr</span>(res, curNum);<br>            &#125;<br>            <span class="hljs-comment">// 如果是普通字符，直接添加到res</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                res += ch;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">copyStr</span><span class="hljs-params">(string &amp;str, <span class="hljs-type">int</span> n)</span></span>&#123;<br>        string result = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            result += str;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a><a href="https://leetcode.cn/problems/longest-valid-parentheses/description/">最长有效括号</a></h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>划分阶段：按照最长有效括号子串的结束位置进行阶段划分。</li><li>定义状态：dp[i]表示以s[i]为结尾的最长有效括号子串长度。</li><li>状态转移方程：<ul><li>如果<code>s[i] == &#39;(&#39;</code>，则以s[i]为结尾的字符串不可能是有效括号子串，<code>dp[i] = 0</code>。</li><li>如果<code>s[i] == &#39;)&#39;</code>，需要考虑 s[i - 1] 来判断是否能够构成有效括号对：<ul><li>如果<code>s[i-1] == &#39;(</code>，dp[i] 取决于「以字符 s[i - 2] 为结尾的最长有效括号长度」 + 「s[i - 1] 与 s[i] 构成的有效括号对长度（2）」，即 <code>dp[i] = dp[i - 2] + 2</code>。如果<code>i-2 &lt; 0</code>，则<code>dp[i] = 2</code>。</li><li>如果<code>s[i-1] == &#39;)&#39;</code>，以 s[i - 1] 为结尾的最长有效长度为 dp[i - 1]，则我们需要看 i - 1 - dp[i - 1] 位置上的字符 s[i - 1 - dp[i - 1]]是否与 s[i] 匹配。<ul><li>如果 <code>s[i - 1 - dp[i - 1]] == &#39;(&#39;</code>，则说明 <code>s[i - 1 - dp[i - 1]]</code>与 s[i] 相匹配，此时我们需要看以 s[i - 1 - dp[i - 1]] 的前一个字符<code> s[i - 2 - dp[i - 1]]</code> 为结尾的最长括号长度是多少，将其加上 <code>s[i - 1 - dp[i - 1]]与 s[i]</code>，从而构成更长的有效括号对：即<code>dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2</code>，如果 <code>s[i - dp[i - 1] - 2]</code> 不存在，即<code>i - dp[i - 1] - 2 &lt; 0</code>，则<code>dp[i] = dp[i-1] + 2</code>。</li></ul></li></ul></li></ul></li><li>初始条件：<code>dp[0] = 0</code>。</li><li>返回结果：max(dp[i])。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历字符串</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-comment">// 如果是左括号</span><br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                dp[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-comment">// 否则看s[i-1]，如果是左括号</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                <span class="hljs-comment">// i-2的位置下标是否合法</span><br>                <span class="hljs-keyword">if</span>(i - <span class="hljs-number">2</span> &lt; <span class="hljs-number">0</span>)&#123;<br>                    dp[i] = <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i] = dp[i<span class="hljs-number">-2</span>] + <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果s[i-1]是右括号，看s[i - 1 - dp[i - 1]]和s[i]是否匹配</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i-dp[i<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; s[i-dp[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                <span class="hljs-comment">// 看i-dp[i-1]-2是否合法</span><br>                <span class="hljs-type">int</span> index = i - dp[i<span class="hljs-number">-1</span>] - <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span>)&#123;<br>                    dp[i] = dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i] = dp[index] + dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ol><li>定义一个变量 ans 用于维护最长有效括号的长度，初始时，ans &#x3D; 0。</li><li>定义一个栈用于判定括号对是否匹配（栈中存储的是括号的下标），栈底元素始终保持「最长有效括号子串的开始元素的前一个元素下标」。</li><li>初始时，我们在栈中存储 -1 作为哨兵节点，表示「最长有效括号子串的开始元素的前一个元素下标为 -1」。</li><li>然后从左至右遍历字符串。<ul><li>如果遇到左括号，则入栈；</li><li>如果遇到右括号，将栈顶弹出，弹出后：<ul><li>如果栈为空，说明刚刚弹出的不是左括号，而是最长有效括号子串的开始元素的前一个元素下标，此时无法完成合法匹配。将当前右括号的坐标 i 压入栈中，充当「下一个有效括号子串的开始元素前一个下标」。</li><li>栈不为空，说明匹配，当前合法匹配的长度为<code>i-stack.top()</code>。然后更新最大长度。</li></ul></li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义栈，初始化</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; stack;<br>        stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历字符串</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++)&#123;<br>            <span class="hljs-comment">// 如果是左括号，入栈</span><br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                stack.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>            <span class="hljs-comment">// 如果是右括号，弹出栈顶</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                stack.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 判断弹出的是左括号还是前一个元素的下标</span><br>                <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">empty</span>())&#123;<br>                    stack.<span class="hljs-built_in">push</span>(i);<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-type">int</span> len = i - stack.<span class="hljs-built_in">top</span>();<br>                    res = <span class="hljs-built_in">max</span>(res, len);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">接雨水</a></h2><h3 id="相向双指针"><a href="#相向双指针" class="headerlink" title="相向双指针"></a>相向双指针</h3><p>对前后缀分解方法的空间优化，某个位置能接多少水，取决于它前面的所有木板的最高值，及后面所有木板的最高值，两者之间的最小值-它自身的高度，就是这个位置能接的水。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 记录前后最大高度</span><br>        <span class="hljs-type">int</span> preMax = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sufMax = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 定义双指针</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 相向而行</span><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            preMax = <span class="hljs-built_in">max</span>(preMax, height[left]);<br>            sufMax = <span class="hljs-built_in">max</span>(sufMax, height[right]);<br>            <span class="hljs-comment">// 更新</span><br>            res += preMax &lt; sufMax ? preMax - height[left++] : sufMax - height[right--];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>如果当前元素小于栈顶元素，无法接水，所以入栈；如果当前元素大于等于栈顶元素，不断出栈，出栈后如果栈为空，表明只是两根相邻的柱子，无法接水，否则可以计算面积，高度取当前栈顶（索引为left）和当前元素的较小值，宽是i - left - 1.然后将当前元素入栈。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 定义栈</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; stack;<br>        <span class="hljs-comment">// 遍历所有元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-comment">// 如果栈不为空，且当前元素大于等于栈顶元素</span><br>            <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt;= height[stack.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-type">int</span> bottomHeight = height[stack.<span class="hljs-built_in">top</span>()];<br>                stack.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 如果栈为空，无法接水</span><br>                <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">empty</span>())&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 记录左边界</span><br>                <span class="hljs-type">int</span> left = stack.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[left], height[i]) - bottomHeight;<br>                ans += h * (i - left - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">// 入栈</span><br>            stack.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">用队列实现栈</a></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>和用两个栈实现队列类似。</p><ul><li>push：一个队列为主队列，一个为辅助队列，当入栈操作时，先将主队列内容导入辅助队列，然后将入栈元素放入主队列队头位置，再将辅助队列内容，依次添加进主队列即可。</li><li>pop：直接返回。</li><li>top：直接返回。</li><li>empty：主队列为空。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; queue1;<br>    queue&lt;<span class="hljs-type">int</span>&gt; queue2;<br>    <span class="hljs-built_in">MyStack</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        queue2.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-comment">// 把1中的元素放入2</span><br>        <span class="hljs-keyword">while</span>(!queue1.<span class="hljs-built_in">empty</span>())&#123;<br>            queue2.<span class="hljs-built_in">push</span>(queue1.<span class="hljs-built_in">front</span>());<br>            queue1.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(queue1, queue2);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = queue1.<span class="hljs-built_in">front</span>();<br>        queue1.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> ans;   <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> queue1.<span class="hljs-built_in">front</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> queue1.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack* obj = new MyStack();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：入栈操作的时间复杂度为O(n)。出栈、取栈顶元素、判断栈是否为空的时间复杂度为O(1)。</li><li>空间复杂度：O(n)</li></ul><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a href="https://leetcode.cn/problems/3sum/description/">三数之和</a></h2><h3 id="对撞指针"><a href="#对撞指针" class="headerlink" title="对撞指针"></a>对撞指针</h3><p>先进行排序。固定一个元素x，然后将left指针指向它的下一个元素y，right指向末尾，三数相加大于target则向左移动right，否则向右移动left，直至两指针相撞，然后移动x，再进行对撞。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">// 排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 循环遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-2</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 此时两数之和的目标</span><br>            <span class="hljs-type">int</span> target = <span class="hljs-number">0</span> - nums[i];<br>            <span class="hljs-comment">// 定义对撞指针</span><br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>, right = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-type">int</span> sum = nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;);<br>                    <span class="hljs-comment">// 跳过重复的left和right值</span><br>                    <span class="hljs-keyword">for</span>(left += <span class="hljs-number">1</span>; left &lt; right &amp;&amp; nums[left] == nums[left<span class="hljs-number">-1</span>]; left++);<br>                    <span class="hljs-keyword">for</span>(right -=<span class="hljs-number">1</span>; right &gt; left &amp;&amp; nums[right] == nums[right+<span class="hljs-number">1</span>]; right--);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>                    right--;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    left++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(1)</li></ul><h2 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a><a href="https://leetcode.cn/problems/first-missing-positive/">缺失的第一个正数</a></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>将当前数组视为哈希表。一个长度为 n 的数组，对应存储的元素值应该为 [1, n + 1] 之间，其中还包含一个缺失的元素。</p><ol><li>遍历一遍数组，将当前元素放到其对应位置上（比如元素值为 1 的元素放到数组第 0 个位置上、元素值为 2 的元素放到数组第 1 个位置上，等等）。实际上这样操作后，比n大的元素不会被操作，或者说，当数组中存在一个比n大的元素时，必然有至少一个值小于等于n，它一定会被找到。</li><li>然后再次遍历一遍数组。遇到第一个元素值不等于下标 + 1 的元素，就是答案要求的缺失的第一个正数。</li><li>如果遍历完没有在数组中找到缺失的第一个正数，则缺失的第一个正数是 n + 1。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 第一次遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-comment">// 只考虑1~n之间的数</span><br>            <span class="hljs-keyword">while</span>(nums[i] &gt;= <span class="hljs-number">1</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i]<span class="hljs-number">-1</span>])&#123;<br>                <span class="hljs-type">int</span> index1 = i;<br>                <span class="hljs-type">int</span> index2 = nums[index1] - <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">swap</span>(nums[index1], nums[index2]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 第二次遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != i + <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">最长连续序列</a></h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ol><li>先将数组存储到集合中进行去重，用变量curLen和ans记录当前序列和最长序列的长度。</li><li>遍历集合，判断当前元素num的num-1是否在集合中，如果不在集合中，说明num是序列的起始，如果在集合中，直接跳过。</li><li>对于起始元素num，判断num+1,num+2,…是否在集合中，并更新序列长度，最后更新ans。</li><li>返回ans。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>        <span class="hljs-comment">// 存入集合，去重</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            set.<span class="hljs-built_in">insert</span>(nums[i]);<br>        &#125;<br>        <span class="hljs-comment">// 维护长度变量</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历集合</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num : set)&#123;<br>            <span class="hljs-comment">// 确定序列起始</span><br>            <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">count</span>(num<span class="hljs-number">-1</span>) == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> curNum = num + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> curLen = <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 枚举</span><br>                <span class="hljs-keyword">while</span>(set.<span class="hljs-built_in">count</span>(curNum) != <span class="hljs-number">0</span>)&#123;<br>                    curLen++;<br>                    curNum++;<br>                &#125;<br>                ans = <span class="hljs-built_in">max</span>(ans, curLen);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要涉及栈、队列、哈希表等内容，注意单调栈的部分，之后需要更多的练习。</p><p><a href="https://algo.itcharge.cn/03.Stack/02.Monotone-Stack/01.Monotone-Stack/#_3-%E5%8D%95%E8%B0%83%E6%A0%88%E6%A8%A1%E6%9D%BF">单调栈</a></p><p><a href="https://www.bilibili.com/video/BV1VN411J7S7/?spm_id_from=333.337.search-card.all.click&vd_source=57ec244afa109ba4ee6346389a5f32f7">单调栈视频讲解</a></p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>面试篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0603练习题目</title>
    <link href="/2024/10/23/posts/0603/"/>
    <url>/2024/10/23/posts/0603/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="06-03-第-026-037-题（第-09-12-天）"><a href="#06-03-第-026-037-题（第-09-12-天）" class="headerlink" title="06.03 第 026 ~ 037 题（第 09 ~ 12 天）"></a>06.03 第 026 ~ 037 题（第 09 ~ 12 天）</h1><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>使用两个指针 cur 和 pre 进行迭代。pre 指向 cur 前一个节点位置。初始时，pre 指向 None，cur 指向 head。不断让cur-&gt;next指向pre，pre右移，cur右移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode* next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>从 head.next 的位置开始调用递归函数，即将 head.next 为头节点的链表进行反转，并返回该链表的头节点。递归到链表的最后一个节点，将其作为最终的头节点，即为 new_head。在每次递归函数返回的过程中，改变 head 和 head.next 的指向关系。也就是将 head.next 的next 指针先指向当前节点 head，即 head.next.next &#x3D; head 。然后让当前节点 head 的 next 指针指向 None，从而实现从链表尾部开始的局部反转。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* newHead = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)，最多需要n层栈空间。</li></ul><h2 id="反转链表II"><a href="#反转链表II" class="headerlink" title="反转链表II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">反转链表II</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>先让pre指向left的前一个节点，cur指向left，然后逐个反转，直到循环变量等于right。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义哑节点</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next = head;<br>        <span class="hljs-comment">// 定义pre cur指针</span><br>        ListNode* pre = dummy;<br>        ListNode* cur = head;<br>        <span class="hljs-comment">// 先让cur指向left</span><br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; left; i++)&#123;<br>            pre = cur;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 进行反转</span><br>        ListNode* next;<br>        <span class="hljs-keyword">for</span>(; i &lt; right; i++)&#123;<br>            next = cur-&gt;next;<br>            cur-&gt;next = next-&gt;next;<br>            next-&gt;next = pre-&gt;next;<br>            pre-&gt;next = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="K个一组反转链表"><a href="#K个一组反转链表" class="headerlink" title="K个一组反转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">K个一组反转链表</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>共需要反转<code>n / k</code>组，每组k个元素最后剩余的<code>n % k</code>个不需要反转。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 先得到链表的长度</span><br>        <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            n++;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 计算要反转多少组</span><br>        <span class="hljs-type">int</span> group = n / k;<br>        <span class="hljs-comment">// 进行反转</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next = head;<br>        ListNode* pre = dummy;<br>        cur = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; group; i++)&#123;<br>            <span class="hljs-comment">// 保存反转前的尾部节点</span><br>            ListNode* gHead = cur;<br>            ListNode* gPrev = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++)&#123;<br>                ListNode* next = cur-&gt;next;<br>                cur-&gt;next = gPrev;<br>                gPrev = cur;<br>                cur = next;<br>            &#125;<br>            <span class="hljs-comment">// 连接起来</span><br>            pre-&gt;next = gPrev;<br>            gHead-&gt;next = cur;<br>            <span class="hljs-comment">// 更新指针</span><br>            pre = gHead;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><blockquote><p>[!NOTE]<br>这几道题回来再好好想想。</p></blockquote><h2 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/description/">回文链表</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ol><li>使用快慢指针找到中间位置。初始slow,fast &#x3D; head,每次slow移动一步，fast移动两步，当fast-&gt;next指向空时，即到达链表表尾，此时slow所指的就是中间的位置。如果链表有偶数个元素，最后一次fast移动时只能移动一步。</li><li>反转后半部分链表。</li><li>比较两个部分的值，当后半部分到达末尾则比较完成，因为如果是偶数个，前半部分也会到达最后，如果是奇数个，前半部分最后一个节点无需判断。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(!head)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 分割链表</span><br>        ListNode* firstHalfEnd = <span class="hljs-built_in">cutList</span>(head);<br>        <span class="hljs-comment">// 反转后半部分</span><br>        ListNode* right = <span class="hljs-built_in">reverseList</span>(firstHalfEnd-&gt;next);<br>        <span class="hljs-comment">// 判断是否回文</span><br>        ListNode* left = head;<br>        <span class="hljs-keyword">while</span>(right)&#123;<br>            <span class="hljs-keyword">if</span>(left-&gt;val != right-&gt;val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            left = left-&gt;next;<br>            right = right-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 分割链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">cutList</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        <span class="hljs-comment">// 定义快慢指针</span><br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-comment">// 移动双指针</span><br>        <span class="hljs-keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>    <span class="hljs-comment">// 反转链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode* next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">合并两个有序链表</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* cur = dummy;<br>        <span class="hljs-comment">// 不断比较list1和list2的值</span><br>        <span class="hljs-keyword">while</span>(list1 &amp;&amp; list2)&#123;<br>            <span class="hljs-keyword">if</span>(list1-&gt;val &lt;= list2-&gt;val)&#123;<br>                cur-&gt;next = list1;<br>                list1 = list1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cur-&gt;next = list2;<br>                list2 = list2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 链接剩余节点</span><br>        <span class="hljs-keyword">while</span>(list1)&#123;<br>            cur-&gt;next = list1;<br>            list1 = list1-&gt;next;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(list2)&#123;<br>            cur-&gt;next = list2;<br>            list2 = list2-&gt;next;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m + n)</li><li>空间复杂度：O(1)</li></ul><h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">排序链表</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>快排在最坏情况下时间复杂度会到$O(n^2)$，在链表排序中一般选择归并排序。</p><ol><li>分割环节：找到链表中心链节点，从中心节点将链表断开，并递归进行分割。</li><li>归并环节：将递归后的链表进行两两归并，完成一遍后每个子链表长度加倍。重复进行归并操作，直到得到完整的链表。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeSort</span>(head);<br>    &#125;<br>    <span class="hljs-comment">// 归并排序</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeSort</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 分割</span><br>        <span class="hljs-comment">// 找到分割点</span><br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 断开左右链接</span><br>        ListNode* leftHead = head;<br>        ListNode* rightHead = slow-&gt;next;<br>        slow-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 递归排序左右两部分，合并两部分</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">mergeSort</span>(leftHead), <span class="hljs-built_in">mergeSort</span>(rightHead));<br>    &#125;<br>    <span class="hljs-comment">// 合并链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* leftHead, ListNode* rightHead)</span></span>&#123;<br>        <span class="hljs-comment">// 定义哑节点</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* cur = dummy;<br>        <span class="hljs-comment">// 不断比较</span><br>        <span class="hljs-keyword">while</span>(leftHead &amp;&amp; rightHead)&#123;<br>            <span class="hljs-keyword">if</span>(leftHead-&gt;val &lt;= rightHead-&gt;val)&#123;<br>                cur-&gt;next = leftHead;<br>                leftHead = leftHead-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cur-&gt;next = rightHead;<br>                rightHead = rightHead-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 链接剩余部分</span><br>        <span class="hljs-keyword">while</span>(leftHead)&#123;<br>            cur-&gt;next = leftHead;<br>            leftHead = leftHead-&gt;next;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(rightHead)&#123;<br>            cur-&gt;next = rightHead;<br>            rightHead = rightHead-&gt;next;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><blockquote><p>[!NOTE]<br>这一部分主要是链表的拆分，归并排序，使用到了快慢指针。即初始时快慢指针都指向head，慢指针每次走一步，快指针每次走两步，当快指针走到最后一个节点时，慢指针刚好走到中间位置。</p></blockquote><h2 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并K个升序链表</a></h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>如果只剩一个链表，就结束递归。然后合并两个链表，按照归并排序的方式合并。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-type">int</span> k = lists.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeSort</span>(lists, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 归并排序</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(left == right)&#123;<br>            <span class="hljs-keyword">return</span> lists[left];<br>        &#125;<br>        <span class="hljs-comment">// 递归左右两部分</span><br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        ListNode* leftHead = <span class="hljs-built_in">mergeSort</span>(lists, left, mid);<br>        ListNode* rightHead = <span class="hljs-built_in">mergeSort</span>(lists, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-comment">// 合并两部分</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(leftHead, rightHead);<br>    &#125;<br>    <span class="hljs-comment">// 合并两个有序链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* leftHead, ListNode* rightHead)</span></span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* cur = dummy;<br>        <span class="hljs-keyword">while</span>(leftHead &amp;&amp; rightHead)&#123;<br>            <span class="hljs-keyword">if</span>(leftHead-&gt;val &lt;= rightHead-&gt;val)&#123;<br>                cur-&gt;next = leftHead;<br>                leftHead = leftHead-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cur-&gt;next = rightHead;<br>                rightHead = rightHead-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 剩余部分</span><br>        <span class="hljs-keyword">while</span>(leftHead)&#123;<br>            cur-&gt;next = leftHead;<br>            leftHead = leftHead-&gt;next;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(rightHead)&#123;<br>            cur-&gt;next = rightHead;<br>            rightHead = rightHead-&gt;next;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：力扣官方题解写的是，分治需要O(logk)，每次合并需要$O(2^in)$，但每次需要合并$\frac{k}{2^i}$组，因此算法时间复杂度接近$O(knlogk)$。但其他地方写的复杂度都是$O(nlogk)$。因为其他地方的n指的是所有链表节点的数目，而力扣的n是链表的最大节点数。</li><li>空间复杂度：递归栈深度，O(logk)。</li></ul><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>维护当前每个链表没有被合并的元素的最前面一个，k 个链表就最多有 k 个满足这样条件的元素，每次在这些元素里面选取 val 属性最小的元素合并到答案中。在选取最小元素的时候，可以用优先队列来优化这个过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-comment">// 最小堆</span><br>        <span class="hljs-keyword">auto</span> cmp = [&amp;](<span class="hljs-type">const</span> ListNode* lhs, <span class="hljs-type">const</span> ListNode* rhs)&#123;<br>            <span class="hljs-keyword">return</span> lhs-&gt;val &gt; rhs-&gt;val;<br>        &#125;;<br>        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">heap</span>(cmp);<br>        <span class="hljs-comment">// 初始化一个哑节点</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* cur = dummy;<br>        <span class="hljs-comment">// 将每个链表的第一个节点放入最小堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; node : lists)&#123;<br>            <span class="hljs-keyword">if</span>(node)&#123;<br>                heap.<span class="hljs-built_in">push</span>(node);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 不断取堆顶元素加到结果链表中</span><br>        <span class="hljs-keyword">while</span>(!heap.<span class="hljs-built_in">empty</span>())&#123;<br>            ListNode* node = heap.<span class="hljs-built_in">top</span>();<br>            heap.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(node-&gt;next)&#123;<br>                heap.<span class="hljs-built_in">push</span>(node-&gt;next);<br>            &#125;<br>            cur-&gt;next = node;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlogk)$，n是所有链表节点总数。</li><li>空间复杂度：堆中的元素不超过k个，O(k)。</li></ul><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/submissions/">环形链表</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>最简单的是申请一个哈希表或数组，标记每个节点是否访问过，但是题目进阶要求O(1)的空间复杂度。可以使用快慢指针，慢指针每次走一步，快指针每次走两步，如果快慢指针能够相遇，则说明存在环，否则快指针指向空，不存在环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        ListNode* slow = head;<br>        ListNode* fast = head-&gt;next;<br>        <span class="hljs-comment">// 移动快慢指针</span><br>        <span class="hljs-keyword">while</span>(slow != fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(slow == fast)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表II</a></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>如果链表中有环，快慢两个指针一定会在环中的某个节点相遇。慢的指针一次走一步，假设在相遇时慢的指针一共走了k步。由于快的指针一次走两步，因此在相遇时快的指针一共走了2k步。因此，到相遇时快的指针比慢的指针多走了k步。另外，两个指针相遇时快的指针比慢的指针在环中多转了若干圈。也就是说，两个指针相遇时快的指针多走的步数k一定是环中节点的数目的整数倍，此时慢的指针走过的步数k也是环中节点数的整数倍。</p><p>此时可以让一个指针指向相遇的节点，该指针的位置是之前慢的指针走了k步到达的位置。接着让另一个指针指向链表的头节点，然后两个指针以相同的速度一起朝着指向下一个节点的指针移动，当后面的指针到达环的入口节点时，前面的指针比它多走了k步，而k是环中节点的数目的整数倍，相当于前面的指针在环中转了k圈后也到达环的入口节点，两个指针正好相遇。也就是说，两个指针相遇的节点正好是环的入口节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理边界情况</span><br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <br>        <span class="hljs-comment">// 移动快慢指针</span><br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <br>            <span class="hljs-comment">// 相遇</span><br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>                ListNode* ptr = head;<br>                <span class="hljs-keyword">while</span> (ptr != slow) &#123;<br>                    ptr = ptr-&gt;next;<br>                    slow = slow-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> ptr;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">相交链表</a></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>直观的想法是用哈希表记录链表的节点，但这样空间复杂度较高。创建两个指针 pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB，然后将两个指针依次遍历两个链表的每个节点。</p><ul><li>pA指向空，将pA移向headB。</li><li>pB指向空，将pB移向headA。</li><li>两者指向同一个节点或者都指向空，返回。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(!headA || !headB)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">// 双指针</span><br>        ListNode* pA = headA;<br>        ListNode* pB = headB;<br>        <span class="hljs-keyword">while</span>(pA != pB)&#123;<br>            pA = pA == <span class="hljs-literal">NULL</span> ? headB : pA-&gt;next;<br>            pB = pB == <span class="hljs-literal">NULL</span> ? headA : pB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m + n)</li><li>空间复杂度：O(1)</li></ul><h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第N个节点</a></h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>很容易用遍历两遍的方法实现，考虑只扫描一次链表的方法。初始时两指针指向链表头部，快指针先走n步，然后快慢指针同时移动。当两指针走了len-n步，即快指针指向空时，慢指针指向倒数第n个节点。但是我们需要删除这个节点，所以让快指针指向最后一个节点，慢指针指向要删除的前一个节点，重置慢指针的next即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        ListNode* slow = dummy;<br>        ListNode* fast = head;<br>        <span class="hljs-comment">// 快指针先走n步</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 两指针同时移动，直到fast指向空</span><br>        <span class="hljs-keyword">while</span>(fast)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        ListNode* del = slow-&gt;next;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-built_in">delete</span>(del);<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a><a href="https://leetcode.cn/problems/reorder-list/">重排链表</a></h2><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>直观的解法是是将链表遍历一遍，存入线性表中，但是这样需要消耗一定的空间。考虑寻找链表中点 + 链表逆序 + 合并链表。</p><ol><li>寻找链表中点：可以用快慢指针，慢指针每次走一步，快指针每次走两步。当fast-&gt;next或者fast-&gt;next-&gt;next为空时，slow恰好指向中间。</li><li>逆序：将后半部分链表反转。</li><li>合并链表：按照第一个链表一个，第二个链表一个的顺序合并链表。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next || !head-&gt;next-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 找到中点</span><br>        ListNode* mid = <span class="hljs-built_in">findMid</span>(head);<br>        ListNode* left = head;<br>        ListNode* right = mid-&gt;next;<br>        mid-&gt;next = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 断开前后链表</span><br>        <br>        <span class="hljs-comment">// 反转后半部分链表</span><br>        right = <span class="hljs-built_in">reverseList</span>(right);<br>        <br>        <span class="hljs-comment">// 合并</span><br>        <span class="hljs-built_in">mergeList</span>(left, right);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">findMid</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode* next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeList</span><span class="hljs-params">(ListNode* left, ListNode* right)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(left &amp;&amp; right)&#123;<br>            ListNode* leftNext = left-&gt;next;<br>            ListNode* rightNext = right-&gt;next;<br>            <br>            left-&gt;next = right;<br>            <span class="hljs-keyword">if</span>(leftNext == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 如果链表节点数是偶数，提前退出循环</span><br>            right-&gt;next = leftNext;<br>            <br>            left = leftNext;<br>            right = rightNext;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：查找中点需要O(n)，反转也需要O(n)，合并也需要O(n)，因此最终为O(n)。</li><li>空间复杂度：O(1)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第 09 ~ 12 天的题目主要涉及分割链表，即找到链表的中点；反转链表，合并链表，以及使用双指针处理环形链表等。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>面试篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0602练习题目</title>
    <link href="/2024/10/18/posts/0602/"/>
    <url>/2024/10/18/posts/0602/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="06-02第-013-025-题（第-05-08-天）"><a href="#06-02第-013-025-题（第-05-08-天）" class="headerlink" title="06.02第 013 ~ 025 题（第 05 ~ 08 天）"></a>06.02第 013 ~ 025 题（第 05 ~ 08 天）</h1><h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>把数组看成左右两部分，左边部分一定比右半部分值大。</p><ul><li>如果<code>nums[mid] == target</code>，直接返回下标。</li><li>如果<code>nums[mid] &gt;= nums[left]</code>，说明mid在左半部分，此时：<ul><li><code>nums[mid] &gt; target &amp;&amp; target &gt;= nums[left]</code>，target在mid左侧，移动<code>right = mid - 1</code>。</li><li><code>nums[mid] &lt; target</code>，则target在mid右侧，<code>left = mid + 1</code>。</li><li><code>target &lt; nums[left]</code>，target在右半部分，<code>left = mid + 1</code>。</li></ul></li><li>如果<code>nums[mid] &lt; nums[left]</code>，说明mid在右半部分，此时：<ul><li><code>nums[mid] &lt; target &amp;&amp; taret &lt; nums[right]</code>，则target在mid右侧，<code>left = mid + 1</code>。</li><li><code>nums[mid] &gt; target</code>，则target在右半部分，且在mid左侧，<code>right = mid - 1</code>。</li><li><code>target &gt; nums[right]</code>，target在左半部分，<code>right = mid-1</code>。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(target == nums[mid])&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-comment">// mid在左半部分</span><br>            <span class="hljs-keyword">if</span>(nums[mid] &gt;= nums[left])&#123;<br>                <span class="hljs-keyword">if</span>(nums[mid] &gt; target &amp;&amp; target &gt;= nums[left])&#123;<br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// mid在右半部分</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a><a href="https://leetcode.cn/problems/find-peak-element/">寻找峰值</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>使用两个指针left和right分别指向数组的第一个元素和最后一个元素。取中间值mid，如果<code>nums[mid] &lt; nums[mid + 1]</code>，则峰值在右侧，<code>left = mid + 1</code>；否则峰值在左侧，<code>right = mid</code>。当<code>left == right</code>时跳出循环，返回结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt; nums[mid+<span class="hljs-number">1</span>])&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="寻找两个正序数组中的中位数"><a href="#寻找两个正序数组中的中位数" class="headerlink" title="寻找两个正序数组中的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/">寻找两个正序数组中的中位数</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>中位数把数组分割成了左右两部分，并且左右两部分元素个数相等。如果两个数组元素个数为偶数，单侧元素个数为$(n1+n2) &#x2F; 2$个；否则是$(n1+n2)&#x2F;2 + 1$个，可以总结为单侧元素个数： $\lfloor \frac{(n1 + n2 + 1)}{2} \rfloor$ 。现在的问题就变为了：如何在两个有序数组中找到前 k 小的元素位置？</p><ol><li>让left指向nums1的首个元素，right指向最后一个元素，m1为中间元素。</li><li>则<code>m2 = k - m1</code>，然后判断m1和m2位置上元素的关系：<ul><li><code>nums1[m1] &lt; nums2[m2]</code>，说明最多有<code>m1 + m2 - 1 = k - 1</code>个元素比nums[m1]小，所以左侧的m1个元素都不可能是第k个元素，因此可以将left右移，即<code>left = m1 + 1</code>。</li><li>否则，说明m1取值过大，<code>right = m1</code>。</li></ul></li><li>当<code>left == right</code>，循环结束，找到正确的m1和m2.</li><li>分奇偶情况讨论。</li></ol><ul><li>如果<code>m1 &lt;= 0</code>，说明整个nums1都比nums2大，那第k个元素一定在m2中；反之亦然。</li><li>如果<code>m1 &gt;= n1</code>，则说明整个nums1都小于第k个元素，即第k个元素在m2中；反之亦然。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-comment">// 设nums1为较短的数组</span><br>        <span class="hljs-type">int</span> n1 = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n2 = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n1 &gt; n2) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">findMedianSortedArrays</span>(nums2, nums1);<br>        &#125;<br><br>        <span class="hljs-type">int</span> k = (n1 + n2 + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = n1;<br>        <br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;  <span class="hljs-comment">// 修改终止条件</span><br>            <span class="hljs-type">int</span> m1 = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> m2 = k - m1;<br><br>            <span class="hljs-comment">// 检查 m1 和 m2 的边界，确保不会越界</span><br>            <span class="hljs-keyword">if</span> (m1 &lt; n1 &amp;&amp; m2 &gt; <span class="hljs-number">0</span> &amp;&amp; nums1[m1] &lt; nums2[m2 - <span class="hljs-number">1</span>]) &#123;<br>                left = m1 + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m1 &gt; <span class="hljs-number">0</span> &amp;&amp; m2 &lt; n2 &amp;&amp; nums1[m1 - <span class="hljs-number">1</span>] &gt; nums2[m2]) &#123;<br>                right = m1 - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 满足条件，划分完成</span><br>                <span class="hljs-type">int</span> c1;<br>                <span class="hljs-keyword">if</span> (m1 == <span class="hljs-number">0</span>) &#123;<br>                    c1 = nums2[m2 - <span class="hljs-number">1</span>];  <span class="hljs-comment">// nums1 全部被划分到右侧</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m2 == <span class="hljs-number">0</span>) &#123;<br>                    c1 = nums1[m1 - <span class="hljs-number">1</span>];  <span class="hljs-comment">// nums2 全部被划分到右侧</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    c1 = <span class="hljs-built_in">max</span>(nums1[m1 - <span class="hljs-number">1</span>], nums2[m2 - <span class="hljs-number">1</span>]);  <span class="hljs-comment">// 左侧最大值</span><br>                &#125;<br><br>                <span class="hljs-comment">// 如果总数为奇数，直接返回</span><br>                <span class="hljs-keyword">if</span> ((n1 + n2) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> c1;<br>                &#125;<br><br>                <span class="hljs-comment">// 否则，计算右半部分的最小值</span><br>                <span class="hljs-type">int</span> c2;<br>                <span class="hljs-keyword">if</span> (m1 == n1) &#123;<br>                    c2 = nums2[m2];  <span class="hljs-comment">// nums1 全部被划分到左侧</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m2 == n2) &#123;<br>                    c2 = nums1[m1];  <span class="hljs-comment">// nums2 全部被划分到左侧</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    c2 = <span class="hljs-built_in">min</span>(nums1[m1], nums2[m2]);  <span class="hljs-comment">// 右侧最小值</span><br>                &#125;<br><br>                <span class="hljs-comment">// 返回中位数</span><br>                <span class="hljs-keyword">return</span> (c1 + c2) / <span class="hljs-number">2.0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;  <span class="hljs-comment">// 理论上不会到达此处</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>重写的代码怎么也通不过，只能再看之前写的代码。</p><ul><li>时间复杂度：时间复杂度：O(log min(m,n))</li><li>空间复杂度：O(1)</li></ul><h2 id="搜索二维矩阵II"><a href="#搜索二维矩阵II" class="headerlink" title="搜索二维矩阵II"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/">搜索二维矩阵II</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>z字形查找方法，从矩阵右上角进行搜索:</p><ul><li><code>matrix[i][j] == target</code>，搜索完成。</li><li><code>matrix[i][j] &gt; target</code>，<code>j--</code>。</li><li><code>matrix[i][j] &lt; target</code>，<code>i++</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j] == target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &gt; target)&#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m + n)，操作过程中，要么i+1，要么j-1，i最多加m次，j最多减n次。</li><li>空间复杂度：O(1)</li></ul><h2 id="x的平方根"><a href="#x的平方根" class="headerlink" title="x的平方根"></a><a href="https://leetcode.cn/problems/sqrtx/description/">x的平方根</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>可以从0~x的范围，用二分法进行查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = x;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)mid * (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)mid &lt;= x)&#123;<br>                res = mid;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logx)</li><li>空间复杂度：O(1)</li></ul><h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/description/">移动零</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>使用两个指针，slow指向指向处理好的非0数字的尾部，fast指向当前待处理元素。不断向右移动fast，每次移动到非零数，则将左右指针对应的数交换，交换同时将slow右移。最后，slow指针左侧均为处理好的非零数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(fast &lt; nums.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">swap</span>(nums[slow], nums[fast]);<br>                slow++;<br>            &#125;<br>            fast++;<br>        &#125;   <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a><a href="https://leetcode.cn/problems/add-strings/">字符串相加</a></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n1 = num1.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> n2 = num2.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span>(n1 &lt; n2)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">addStrings</span>(num2, num1);<br>        &#125;<br>        string res;<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = n1<span class="hljs-number">-1</span>, j = n2<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> t1 = num1[i--] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-type">int</span> t2 = num2[j--] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            res = <span class="hljs-built_in">to_string</span>((t1 + t2 + carry) % <span class="hljs-number">10</span> ) + res;<br>            carry = (t1 + t2 + carry) / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> t = num1[i--] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            res = <span class="hljs-built_in">to_string</span>((t + carry) % <span class="hljs-number">10</span>) + res;<br>            carry = (t + carry) / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>)&#123;<br>            res = <span class="hljs-string">&#x27;1&#x27;</span> + res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(max(len1, len2))</li><li>空间复杂度：O(1)</li></ul><h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">滑动窗口最大值</a></h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>初始时将前k个元素加入优先队列的二叉堆中。存入优先队列的是数组值与索引构成的元组。优先队列将数组值作为优先级。每当我们向右移动窗口时，我们就可以把一个新的元素放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值。然而这个最大值可能并不在滑动窗口中，在这种情况下，这个值在数组 nums 中的位置出现在滑动窗口左边界的左侧。可以将其永久地从优先队列中移除。不断地移除堆顶的元素，直到其确实出现在滑动窗口中。此时，堆顶元素就是滑动窗口中的最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 定义优先队列并初始化</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            q.<span class="hljs-built_in">push</span>(&#123;nums[i], i&#125;);<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        res.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">top</span>().first);<br>        <span class="hljs-comment">// 逐渐向右移动窗口</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k; i &lt; n; i++)&#123;<br>            q.<span class="hljs-built_in">push</span>(&#123;nums[i], i&#125;);<br>            <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">top</span>().second &lt;= i-k)&#123;<br>                q.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">top</span>().first);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 定义双端队列并初始化</span><br>        deque&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[q.<span class="hljs-built_in">back</span>()])&#123;<br>                q.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            q.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-comment">// 向右移动窗口</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res = &#123;nums[q.<span class="hljs-built_in">front</span>()]&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[q.<span class="hljs-built_in">back</span>()])&#123;<br>                q.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            q.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">front</span>() &lt;= i - k)&#123;<br>                q.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(nums[q.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，每一个下标恰好被放入队列一次，并且最多被弹出队列一次。</li><li>空间复杂度：O(k)，因此「不断从队首弹出元素」保证了队列中最多不会有超过k+1个元素。</li></ul><h3 id="分块-预处理"><a href="#分块-预处理" class="headerlink" title="分块 + 预处理"></a>分块 + 预处理</h3><p>将数组所有元素每k个分为一组，最后一组中元素的数量可能会不足 k 个。如果我们希望求出 nums[i] 到 nums[i+k−1] 的最大值，就会有两种情况：</p><ul><li>如果i是k的倍数，那么此区间恰好是一个分组，只需要预处理出每个分组的最大值即可；</li><li>如果i不是k的倍数，那么存在一个j，<code>i&lt;j≤i+k−1</code>，那么 nums[i] 到 nums[j−1] 就是第一个分组的后缀，nums[j] 到 nums[i+k−1] 就是第二个分组的前缀。如果我们能够预处理出每个分组中的前缀最大值以及后缀最大值，同样可以在 O(1) 的时间得到答案。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义前后缀数组</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefixMax</span><span class="hljs-params">(n)</span>, <span class="hljs-title">suffixMax</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-comment">// 处理前缀</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i % k == <span class="hljs-number">0</span>)&#123;<br>                prefixMax[i] = nums[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                prefixMax[i] = <span class="hljs-built_in">max</span>(prefixMax[i<span class="hljs-number">-1</span>], nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 处理后缀</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(i == n<span class="hljs-number">-1</span> || (i + <span class="hljs-number">1</span>) % k == <span class="hljs-number">0</span>)&#123;<br>                suffixMax[i] = nums[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                suffixMax[i] = <span class="hljs-built_in">max</span>(suffixMax[i+<span class="hljs-number">1</span>], nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n-k; i++)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">max</span>(suffixMax[i], prefixMax[i+k<span class="hljs-number">-1</span>]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>双指针，维护一个left和一个right，用哈希表记录两个指针的窗口内字符的个数，用一个变量维护不含重复字符的最长子串长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义双指针</span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 枚举右指针</span><br>        <span class="hljs-keyword">while</span>(right &lt; n)&#123;<br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">find</span>(s[right]) == hash.<span class="hljs-built_in">end</span>())&#123;<br>                hash[s[right]] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                hash[s[right]]++;<br>            &#125;<br>            <span class="hljs-comment">// 消除重复字符</span><br>            <span class="hljs-keyword">while</span>(hash[s[right]] &gt; <span class="hljs-number">1</span>)&#123;<br>                hash[s[left]]--;<br>                left++;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, right - left + <span class="hljs-number">1</span>);<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/description/">最小覆盖子串</a></h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>用一个变量 less 维护目前子串中有 less 种字母的出现次数小于 t 中字母的出现次数。</p><ol><li>初始化左右指针，<code>ansLeft = -1, ansRight = m</code>，m为s子串的长度。</li><li>用哈希表或数组记录t中的字符情况，由于也要记录s中的情况，因此可以用一个数组<code>cnt[] = cntT[] - cntS</code>来代替，节省空间。</li><li>初始化less为t中不同字母的个数。</li><li>枚举右指针，即将右指针所指字符移入窗口内，<code>cnt[s[right]]--</code>，如果此时<code>cnt[s[right]] == 0</code>，说明在当前字符移入窗口后该字符的数量等于t中的数量，因此less可以减1.</li><li>当less&#x3D;0时，即s涵盖t，可以不断移动左指针，直到s又无法涵盖t。如果left所指字符在移出窗口前的cnt&#x3D;0，那么在移出后，s无法涵盖t，所以less要+1.移出字符即<code>cnt[s[left++]]++</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-comment">// 初始化左右指针、less、哈希表</span><br>        <span class="hljs-type">int</span> ansLeft = <span class="hljs-number">-1</span>, ansRight = m;<br>        <span class="hljs-type">int</span> less = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">123</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : t)&#123;<br>            <span class="hljs-comment">// 统计less</span><br>            <span class="hljs-keyword">if</span>(cnt[c] == <span class="hljs-number">0</span>)&#123;<br>                less++;<br>            &#125;<br>            cnt[c]++;<br>        &#125;<br>        <span class="hljs-comment">// 滑动窗口</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; m; right++)&#123;<br>            <span class="hljs-comment">// 将右端点移入窗口内</span><br>            <span class="hljs-type">char</span> c = s[right];<br>            cnt[c]--;<br>            <span class="hljs-comment">// 更新less</span><br>            <span class="hljs-keyword">if</span>(cnt[c] == <span class="hljs-number">0</span>)&#123;<br>                less--;<br>            &#125;<br>            <span class="hljs-comment">// 涵盖t，移动左指针</span><br>            <span class="hljs-keyword">while</span>(less == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">// 找到更短子串</span><br>                <span class="hljs-keyword">if</span>(right - left &lt; ansRight - ansLeft)&#123;<br>                    ansLeft = left;<br>                    ansRight = right;<br>                &#125;<br>                <span class="hljs-comment">// 移动左指针，更新less</span><br>                <span class="hljs-type">char</span> x = s[left];<br>                <span class="hljs-keyword">if</span>(cnt[x] == <span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">// 移动之后无法涵盖</span><br>                    less++;<br>                &#125;<br>                cnt[x]++;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> ansLeft &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;&quot;</span> : s.<span class="hljs-built_in">substr</span>(ansLeft, ansRight - ansLeft + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m+n+∣Σ∣)</li><li>空间复杂度：O(∣Σ∣)</li></ul><h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">最长重复子数组</a></h2><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照子数组结尾位置进行阶段划分。</li><li>定义状态：dp[i][j]表示nums1前i个数字和nums2的前j个数字的最长公共子数组长度。</li><li>状态转移方程：<ul><li>如果nums1[i-1] &#x3D;&#x3D; nums2[j-1]，那么dp[i][j] &#x3D; dp[i-1][j-1]+1；</li><li>否则，dp[i][j] &#x3D; 0。</li></ul></li><li>初始条件：dp[0][j] &#x3D; dp[i][0] &#x3D; 0</li><li>dp[i][j]中的最大值，可以在循环中用一个变量保存。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 定义状态</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                    res = <span class="hljs-built_in">max</span>(res, dp[i][j]);<br>                &#125;                <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><h2 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">删除排序链表中的重复元素</a></h2><h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><p>用两个指针，pre和cur，当<code>cur-&gt;val == pre-&gt;val</code>时，删除当前节点，即<code>pre-&gt;next = cur-&gt;next</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 定义两个指针</span><br>        ListNode* pre = head;<br>        ListNode* cur = pre-&gt;next;<br>        <span class="hljs-comment">// 遍历链表</span><br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            <span class="hljs-comment">// 删除当前节点</span><br>            <span class="hljs-keyword">if</span>(pre-&gt;val == cur-&gt;val)&#123;<br>                pre-&gt;next = cur-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                pre = cur;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>或者只用一个指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(!head)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 定义指针</span><br>        ListNode* cur = head;<br>        <span class="hljs-comment">// 遍历链表</span><br>        <span class="hljs-keyword">while</span>(cur-&gt;next)&#123;<br>            <span class="hljs-comment">// 删除当前节点</span><br>            <span class="hljs-keyword">if</span>(cur-&gt;val == cur-&gt;next-&gt;val)&#123;<br>                cur-&gt;next = cur-&gt;next-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="删除排序链表中的重复元素II"><a href="#删除排序链表中的重复元素II" class="headerlink" title="删除排序链表中的重复元素II"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">删除排序链表中的重复元素II</a></h2><h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><p>与上一题的不同之处是，上一题会保留重复元素中的一个，而这道题要把重复的元素全部删除。在循环中用一个循环，把所有重复的节点删除，然后删除第一个节点，但是可能会把头节点删除，所以加一个dummy。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(!head)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 定义哑节点</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br>        ListNode* cur = dummy;<br>        <span class="hljs-comment">// 遍历</span><br>        <span class="hljs-keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)&#123;<br>            <span class="hljs-comment">// 如果相等</span><br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val)&#123;<br>                <span class="hljs-comment">// 暂时保存这个值</span><br>                <span class="hljs-type">int</span> x = cur-&gt;next-&gt;val;<br>                <span class="hljs-keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == x)&#123;<br>                    cur-&gt;next = cur-&gt;next-&gt;next;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 否则</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第二部分的题目主要涉及二分查找、滑动窗口、双指针等，注意二分查找的变形题目，主要是分析每次计算mid后，如何更新左右指针。滑动窗口的关键在于更新右指针后的操作以及如何更新左指针。在遍历链表时，要注意快慢指针所指向的节点，在有可能更改头节点的时候，要申请一个哑节点。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>面试篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0601练习题目</title>
    <link href="/2024/10/14/posts/0601/"/>
    <url>/2024/10/14/posts/0601/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="06-01第-001-012-题（第-01-04-天）"><a href="#06-01第-001-012-题（第-01-04-天）" class="headerlink" title="06.01第 001 ~ 012 题（第 01 ~ 04 天）"></a>06.01第 001 ~ 012 题（第 01 ~ 04 天）</h1><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">螺旋矩阵</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对矩阵进行模拟，每次更新边界位置，初始时向右走，当<code>i == right</code>，开始调整方向向下走，此时对i进行枚举，当<code>i == down</code>，调整方向向左走，枚举j，当<code>i == left</code>，调整方向向上走，对i进行枚举，当<code>i == up</code>，再次向右走。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-comment">// 定义边界</span><br>        <span class="hljs-type">int</span> up = <span class="hljs-number">0</span>, down = m<span class="hljs-number">-1</span>, left = <span class="hljs-number">0</span>, right = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 循环遍历</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">// 向右走</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left; i &lt;= right; i++)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[up][i]);<br>            &#125;<br>            <span class="hljs-comment">// 向下走</span><br>            up += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(up &gt; down)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = up; i &lt;= down; i++)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[i][right]);<br>            &#125;<br>            <span class="hljs-comment">// 向左走</span><br>            right -= <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = right; i &gt;= left; i--)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[down][i]);<br>            &#125;<br>            <span class="hljs-comment">// 向上走</span><br>            down -= <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(up &gt; down)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = down; i &gt;= up; i--)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[i][left]);<br>            &#125;<br>            <span class="hljs-comment">// 循环往复</span><br>            left += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(m \times n)$</li><li>空间复杂度：$O(m \times n)$，如果算上答案数组的空间占用。</li></ul><h2 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/description/">旋转图像</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>对于位置(i,j)上的元素，其旋转后会放置在(j,n-i-1)的位置上，而原本(j,n-i-1)的位置上，会旋转到(n-i-1,n-j-1)；(n-i-1,n-j-1)会旋转到(n-j-1, i)，(n-j-1, i)会旋转到(i, j)。因此只需要一个临时变量存储循环中的元素即可。总结为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">temp = matrix[i][j]<br>matrix[i][j] = matrix[n-j<span class="hljs-number">-1</span>][i]<br>matrix[n-j<span class="hljs-number">-1</span>][i] = matrix[n-i<span class="hljs-number">-1</span>][n-j<span class="hljs-number">-1</span>]<br>matrix[n-i<span class="hljs-number">-1</span>][n-j<span class="hljs-number">-1</span>] = matrix[j][n-i<span class="hljs-number">-1</span>]<br>matrx[j][n-i<span class="hljs-number">-1</span>] = temp<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; (n+<span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; j++)&#123;<br>                <span class="hljs-type">int</span> temp = matrix[i][j];<br>                matrix[i][j] = matrix[n-j<span class="hljs-number">-1</span>][i];<br>                matrix[n-j<span class="hljs-number">-1</span>][i] = matrix[n-i<span class="hljs-number">-1</span>][n-j<span class="hljs-number">-1</span>];<br>                matrix[n-i<span class="hljs-number">-1</span>][n-j<span class="hljs-number">-1</span>] = matrix[j][n-i<span class="hljs-number">-1</span>];<br>                matrix[j][n-i<span class="hljs-number">-1</span>] = temp;<br>            &#125;<br>        &#125;        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(1)</li></ul><p>还可以通过一次水平翻转<code>swap(matrix[i][j], matrix[n-i-1][j])</code> + 一次主对角线翻转<code>swap(matrix[i][j], matrix[j][i])</code>得到，此处不再赘述。</p><h2 id="数组中的第k个最大元素"><a href="#数组中的第k个最大元素" class="headerlink" title="数组中的第k个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">数组中的第k个最大元素</a></h2><p>这道题之前做过很多次，大体思路是对数组进行降序（升序）排序，返回第k-1（n-k）个元素，排序方法主要是快排和堆排。这次要把快排和堆排的代码记住。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>使用快速排序在每次调整时，都会确定一个元素的最终位置，且以该元素为界限，将数组分成了左右两个子数组，左子数组中的元素都比该元素小，右子树组中的元素都比该元素大。</p><p>这样，只要某次划分的元素恰好是第k个下标就找到了答案。并且我们只需关注第k个最大元素所在区间的排序情况，与第k个最大元素无关的区间排序都可以忽略。这样进一步减少了执行步骤。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">quickSelect</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, k);<br>        <span class="hljs-keyword">return</span> nums[index];<br>    &#125;<br>    <span class="hljs-comment">// 分区函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partion</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-comment">// 选择左边界元素作为基准元素</span><br>        <span class="hljs-type">int</span> pivot = nums[left];<br>        <span class="hljs-comment">// 初始化左右指针</span><br>        <span class="hljs-type">int</span> i = left;<br>        <span class="hljs-type">int</span> j = right + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 开始分区</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 从左往右找到第一个大于等于基准元素的元素</span><br>            <span class="hljs-keyword">while</span>(++i &lt; right &amp;&amp; nums[i] &lt; pivot);<br>            <span class="hljs-comment">// 从右往左找到第一个小于等于基准元素的元素</span><br>            <span class="hljs-keyword">while</span>(--j &gt; left &amp;&amp; nums[j] &gt; pivot);<br>            <span class="hljs-comment">// 如果左右指针相遇，则分区完成</span><br>            <span class="hljs-keyword">if</span>(i &gt;= j)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 交换不符合条件的元素</span><br>            <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>        <span class="hljs-comment">// 将基准元素放置在正确的位置上</span><br>        <span class="hljs-built_in">swap</span>(nums[left], nums[j]);<br>        <span class="hljs-comment">// 返回基准元素的位置</span><br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br>    <span class="hljs-comment">// 快速选择</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-comment">// 分区并获取基准元素的位置</span><br>        <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">partion</span>(nums, left, right);<br>        <span class="hljs-comment">// 将 k 转换为数组下标</span><br>        <span class="hljs-type">int</span> target = nums.<span class="hljs-built_in">size</span>() - k;<br>        <span class="hljs-comment">// 如果基准元素的位置就是目标位置，则返回该元素</span><br>        <span class="hljs-keyword">if</span>(pivot == target)&#123;<br>            <span class="hljs-keyword">return</span> pivot;<br>        &#125;<br>        <span class="hljs-comment">// 如果基准元素的位置小于目标位置，则在右侧继续查找</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pivot &lt; target)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, pivot+<span class="hljs-number">1</span>, right, k);<br>        &#125;<br>        <span class="hljs-comment">// 如果基准元素的位置大于目标位置，则在左侧继续查找</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickSelect</span>(nums, left, pivot<span class="hljs-number">-1</span>, k);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(logn)</li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>如果能够找出 k 个最大的数字，那么第 k 大的数字就是这 k 个最大数字中最小的一个。由于每次都需要找出 k 个数字中的最小值，因此可以把这 k 个数字保存到最小堆中。首先构建最小堆，将数组的前 k 个元素插入到最小堆中。最小堆是一个完全二叉树，树中每个节点的值都小于或等于其子节点的值。然后遍历数组中剩下的元素，如果当前元素大于堆顶元素（最小堆中的最小值），则将堆顶元素替换为当前元素，并进行堆调整（向下调整）以保持最小堆的性质。遍历完成后，最小堆中的堆顶元素就是数组中的第 K 大元素。</p><ul><li>minHeapify函数：用于调整以节点 i 为根的子树，使其满足小根堆的性质。它首先获取节点 i的左右子节点索引，然后找出其中最小的节点索引，如果该最小节点索引不等于当前节点索引 i，则交换当前节点和最小节点的值，并继续递归调整以最小节点为根的子树。</li><li>buildMinHeap函数：用于建立小根堆。它从最后一个非叶子节点开始，依次向前调整节点，保证以每个节点为根的子树都是小根堆。</li><li>heapSelect函数：首先构建一个大小为 k 的最小堆（只包含前 k 个元素）。然后遍历数组的剩余部分（从第 k 个元素到最后一个元素），如果当前元素比堆顶元素大，则将其与堆顶元素交换，并调整堆。最后，堆顶元素即为第 k 大的元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">heapSelect</span>(nums, k);<br>    &#125;<br>    <span class="hljs-comment">// 小根堆操作：将以节点 i 为根的子树进行小根堆调整</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">minHeapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> heapSize)</span></span>&#123;<br>        <span class="hljs-comment">// 获取左右子节点索引和当前节点索引</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> smallest = i;<br>        <span class="hljs-comment">// 如果左子节点存在且小于当前节点，则更新最小节点索引</span><br>        <span class="hljs-keyword">if</span>(left &lt; heapSize &amp;&amp; nums[left] &lt; nums[smallest])&#123;<br>            smallest = left;<br>        &#125;<br>        <span class="hljs-comment">// 如果右子节点存在且小于当前节点或左子节点，则更新最小节点索引</span><br>        <span class="hljs-keyword">if</span>(right &lt; heapSize &amp;&amp; nums[right] &lt; nums[smallest])&#123;<br>            smallest = right;<br>        &#125;<br>        <span class="hljs-comment">// 如果最小节点索引不等于当前节点索引，则交换当前节点和最小节点，并继续调整最小堆</span><br>        <span class="hljs-keyword">if</span>(smallest != i)&#123;<br>            <span class="hljs-built_in">swap</span>(nums[smallest], nums[i]);<br>            <span class="hljs-built_in">minHeapify</span>(nums, smallest, heapSize);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 小根堆操作：建立小根堆</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildMinHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> heapSize)</span></span>&#123;<br>        <span class="hljs-comment">// 从最后一个非叶子节点开始，依次向前调整节点，保证以每个节点为根的子树都是小根堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = heapSize / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-built_in">minHeapify</span>(nums, i, heapSize);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 基于堆排序的选择方法</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">heapSelect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-type">int</span> heapSize = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 构建一个大小为K的最小堆</span><br>        <span class="hljs-built_in">buildMinHeap</span>(nums, k);<br>        <span class="hljs-comment">// 处理剩余元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k; i &lt; heapSize; i++)&#123;<br>            <span class="hljs-comment">// 如果当前元素比堆顶元素大，则替换堆顶元素</span><br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>], nums[i]);<br>                <span class="hljs-built_in">minHeapify</span>(nums, <span class="hljs-number">0</span>, k);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times \log n)$</li><li>空间复杂度：堆选择算法需要一个大小为 k 的额外数组来存储堆，因此其空间复杂度为 O(k)。</li></ul><h2 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a><a href="https://leetcode.cn/problems/sort-an-array/description/">排序数组</a></h2><h3 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-comment">// 分区函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partion</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-comment">// 选择基准元素</span><br>        <span class="hljs-type">int</span> pivot = nums[left];<br>        <span class="hljs-comment">// 初始化左右指针</span><br>        <span class="hljs-type">int</span> i = left, j = right + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 开始分区</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>             <span class="hljs-comment">// 从左往右找到第一个大于等于基准元素的元素</span><br>             <span class="hljs-keyword">while</span>(++i &lt; right &amp;&amp; nums[i] &lt; pivot);<br>              <span class="hljs-comment">// 从右往左找到第一个小于等于基准元素的元素</span><br>              <span class="hljs-keyword">while</span>(--j &gt; left &amp;&amp; nums[j] &gt; pivot);<br>              <span class="hljs-comment">// 如果左右指针相遇，则分区完成</span><br>              <span class="hljs-keyword">if</span>(i &gt;= j)&#123;<br>                <span class="hljs-keyword">break</span>;<br>              &#125;<br>              <span class="hljs-comment">// 交换不在位置的元素</span><br>              <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>        <span class="hljs-comment">// 将pivot放到正确位置</span><br>        <span class="hljs-built_in">swap</span>(nums[left], nums[j]);<br>        <span class="hljs-comment">// 返回基准元素的位置</span><br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br>    <span class="hljs-comment">// 快速排序</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left &lt; right)&#123;<br>            <span class="hljs-comment">// 划分数组</span><br>            <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">partion</span>(nums, left, right);<br>            <span class="hljs-comment">// 对两边数组进行快排</span><br>            <span class="hljs-built_in">quickSort</span>(nums, left, pivot<span class="hljs-number">-1</span>);<br>            <span class="hljs-built_in">quickSort</span>(nums, pivot+<span class="hljs-number">1</span>, right);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times \log n)$</li><li>空间复杂度：O(logn)</li></ul><h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> heapSize = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 建立大根堆</span><br>        <span class="hljs-built_in">buildHeap</span>(nums, heapSize);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = heapSize - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-comment">// 每次将堆顶（最大值）与当前堆的最后一个元素交换</span><br>            <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>], nums[i]);<br>            <span class="hljs-comment">// 重新调整堆，排除已排序的最后一个元素</span><br>            heapSize--;<br>            <span class="hljs-built_in">maxHeapify</span>(nums, <span class="hljs-number">0</span>, heapSize);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-comment">// 调整堆</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maxHeapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> heapSize)</span></span>&#123;<br>        <span class="hljs-comment">// 计算左右子节点</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> largest = i;<br>        <span class="hljs-comment">// 更新最大节点索引</span><br>        <span class="hljs-keyword">if</span>(left &lt; heapSize &amp;&amp; nums[left] &gt; nums[largest])&#123;<br>            largest = left;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right &lt; heapSize &amp;&amp; nums[right] &gt; nums[largest])&#123;<br>            largest = right;<br>        &#125;<br>        <span class="hljs-comment">// 如果最大节点索引不等于当前节点索引，则交换当前节点和最大节点，并继续调整最大堆</span><br>        <span class="hljs-keyword">if</span>(largest != i)&#123;<br>            <span class="hljs-built_in">swap</span>(nums[largest], nums[i]);<br>            <span class="hljs-built_in">maxHeapify</span>(nums, largest, heapSize);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 建立大根堆</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> heapSize)</span></span>&#123;<br>        <span class="hljs-comment">// 从最后一个非叶子节点开始，依次向前调整节点，保证以每个节点为根的子树都是大根堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = heapSize / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-built_in">maxHeapify</span>(nums, i, heapSize);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)（忽略递归栈的空间）或 O(log n)（如果考虑递归栈空间）</li></ul><p><img src="/2024/10/14/posts/0601/image.png" alt="排序算法总结"></p><h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/description/">合并两个有序数组</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>从前向后遍历的话，nums1的值可能会被覆盖，所以考虑从后向前遍历，不断比较nums1和nums2的值并放入nums1的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = m<span class="hljs-number">-1</span>, j = n<span class="hljs-number">-1</span>, k = m+n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(nums1[i] &lt; nums2[j])&#123;<br>                nums1[k--] = nums2[j--];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                nums1[k--] = nums1[i--];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>)&#123;<br>            nums1[k--] = nums1[i--];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>)&#123;<br>            nums1[k--] = nums2[j--];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(m + n)$</li><li>空间复杂度：O(1)</li></ul><h2 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><a href="https://leetcode.cn/problems/majority-element/description/">多数元素</a></h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>最直观的解法是用哈希表，这里用分治法来解决，题解中还有一种投票算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getMod</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMod</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-comment">// 只有一个元素</span><br>        <span class="hljs-keyword">if</span>(left == right)&#123;<br>            <span class="hljs-keyword">return</span> nums[left];<br>        &#125;<br>        <span class="hljs-comment">// 获取左右两部分的多数元素</span><br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> leftMod = <span class="hljs-built_in">getMod</span>(nums, left, mid);<br>        <span class="hljs-type">int</span> rightMod = <span class="hljs-built_in">getMod</span>(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-comment">// 相等直接返回</span><br>        <span class="hljs-keyword">if</span>(leftMod == rightMod)&#123;<br>            <span class="hljs-keyword">return</span> leftMod;<br>        &#125;<br>        <span class="hljs-comment">// 否则进行计数</span><br>        <span class="hljs-type">int</span> leftModCnt = <span class="hljs-number">0</span>, rightModCnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left; i &lt;= right; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == leftMod)&#123;<br>                leftModCnt++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] == rightMod)&#123;<br>                rightModCnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> leftModCnt &gt; rightModCnt ? leftMod : rightMod;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times \log n)$</li><li>空间复杂度：$O(\log n)$</li></ul><h3 id="投票算法"><a href="#投票算法" class="headerlink" title="投票算法"></a>投票算法</h3><p>如果我们把众数记为 +1，把其他数记为 −1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cadidate = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            <span class="hljs-keyword">if</span>(num == cadidate)&#123;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(--count &lt; <span class="hljs-number">0</span>)&#123;<br>                cadidate = num;<br>                count = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cadidate;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a><a href="https://leetcode.cn/problems/single-number/description/">只出现一次的数字</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>数字逐个异或得到的结果就是这个数字，因为俩俩异或的结果是0.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            res ^= num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/submissions/">合并区间</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>先按开始时间进行排序，然后逐个比较，如果前一个区间的结束时间大于后一个区间的开始时间，则将两个区间合并。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        <span class="hljs-comment">// 对所有区间按开始时间进行排序</span><br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res = &#123;intervals[<span class="hljs-number">0</span>]&#125;;<br>        <span class="hljs-comment">// 逐个遍历区间</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>] &gt;= intervals[i][<span class="hljs-number">0</span>])&#123;<br>                res.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(intervals[i][<span class="hljs-number">1</span>], res.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                res.<span class="hljs-built_in">push_back</span>(intervals[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)，排序消耗的时间。</li><li>空间复杂度：O(n)，结果数组。</li></ul><h2 id="最大数"><a href="#最大数" class="headerlink" title="最大数"></a><a href="https://leetcode.cn/problems/largest-number/description/">最大数</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>将所有数字按照最高位-最低位的大小进行排序，排序后组成的字符串就是结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num1, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num2)</span> </span>&#123;<br>        string str1 = <span class="hljs-built_in">to_string</span>(num1) + <span class="hljs-built_in">to_string</span>(num2);<br>        string str2 = <span class="hljs-built_in">to_string</span>(num2) + <span class="hljs-built_in">to_string</span>(num1);<br>        <span class="hljs-keyword">return</span> str1 &gt; str2;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">largestNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), compare);<br>        <span class="hljs-comment">// 如果最大值是 0，直接返回 &quot;0&quot;</span><br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        <br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            res += <span class="hljs-built_in">to_string</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li></ul><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><a href="https://leetcode.cn/problems/binary-search/description/">二分查找</a></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>            <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>题目要求时间复杂度为O(logn)，所以使用二分法。在找到目标，即<code>nums[mid] == target</code>后，再以mid为中心向两边查找起始位置和结束位置。但在找到目标元素后，通过 while 循环向两边扩展，这样的复杂度接近 O(n)。可以通过两次独立的二分查找分别找到目标值的左边界和右边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">findLeftBoundary</span>(nums, target);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">findRightBoundary</span>(nums, target);<br>        <br>        <span class="hljs-comment">// 如果左边界大于右边界，说明没有找到目标值</span><br>        <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> &#123;left, right&#125;;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 查找左边界</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLeftBoundary</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>, high = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>            <span class="hljs-type">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>                high = mid - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 向左收缩范围</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回左边界</span><br>        <span class="hljs-keyword">return</span> (low &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[low] == target) ? low : <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找右边界</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRightBoundary</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>, high = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>            <span class="hljs-type">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) &#123;<br>                low = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 向右收缩范围</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回右边界</span><br>        <span class="hljs-keyword">return</span> (high &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[high] == target) ? high : <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/">寻找旋转排序数组中的最小值</a></h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>数组经过「旋转」之后，会有两种情况，第一种就是原先的升序序列，另一种是两段升序的序列。第一种的最小值在最左边。第二种最小值在第二段升序序列的第一个元素。</p><p>二分法：left和right分别指向数组首尾。计算mid:</p><ul><li>如果nums[mid] &gt; nums[right]，则最小值一定在mid右侧；</li><li>否则一定在mid或者mid的左侧。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &gt; nums[right])&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="寻找旋转排序数组中的最小值II"><a href="#寻找旋转排序数组中的最小值II" class="headerlink" title="寻找旋转排序数组中的最小值II"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/description/">寻找旋转排序数组中的最小值II</a></h2><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>与上一题类似，但 nums 可能包含重复元素。考虑数组中的最后一个元素 x：在最小值右侧的元素，它们的值一定都小于等于 x；而在最小值左侧的元素，它们的值一定都大于等于 x。</p><ul><li>如果<code>nums[mid] &lt; nums[right]</code>，则mid是最小值或者在最小值右侧，因此可以忽略右边部分，更新<code>right = mid</code>。</li><li>如果<code>nums[mid] &gt; nums[right]</code>，则mid在最小值左侧，可以忽略左边部分，更新<code>left = mid + 1</code>。</li><li>如果两者相等，则需要更新右端点值，如图所示：<br><img src="/2024/10/14/posts/0601/image-1.png" alt="Alt text"></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt; nums[right])&#123;<br>                right = mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; nums[right])&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：平均时间复杂度为O(logn)，最坏情况下所有元素都相等，时间复杂度为O(n)。</li><li>空间复杂度：O(1)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一部分的面试题比较简单，主要是模拟、排序、二分查找的题目，对于排序的题目，最好的方法是快排和堆排，其他的排序方法之后也要再敲一遍。二分查找要注意分析每次更新左右端点的方式，注意临界点。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>面试篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0504区间DP和树形DP</title>
    <link href="/2024/10/05/posts/0504%E5%8C%BA%E9%97%B4DP%E5%92%8C%E6%A0%91%E5%BD%A2DP/"/>
    <url>/2024/10/05/posts/0504%E5%8C%BA%E9%97%B4DP%E5%92%8C%E6%A0%91%E5%BD%A2DP/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="05-04-区间DP和树形DP"><a href="#05-04-区间DP和树形DP" class="headerlink" title="05.04 区间DP和树形DP"></a>05.04 区间DP和树形DP</h1><blockquote><p>区间动态规划：线性 DP 的一种，简称为「区间 DP」。以「区间长度」划分阶段，以两个坐标（区间的左、右端点）作为状态的维度。一个状态通常由被它包含且比它更小的区间状态转移而来。</p><p>区间 DP 的主要思想就是：先在小区间内得到最优解，再利用小区间的最优解合并，从而得到大区间的最优解，最终得到整个区间的最优解。</p><p>根据小区间向大区间转移情况的不同，常见的区间 DP 问题可以分为两种：</p><ul><li>单个区间从中间向两侧更大区间转移的区间 DP 问题：$dp[i][j] &#x3D; max \lbrace dp[i + 1][j - 1], \quad dp[i + 1][j], \quad dp[i][j - 1] \rbrace + cost[i][j], \quad i \le j$<ol><li>枚举区间的起点；</li><li>枚举区间的终点；</li><li>根据状态转移方程计算从小区间转移到更大区间后的最优值。</li></ol></li><li>多个（大于等于2个）小区间转移到大区间的区间 DP 问题：$dp[i][j] &#x3D; max &#x2F; min \lbrace dp[i][k] + dp[k + 1][j] + cost[i][j] \rbrace, \quad i &lt; k \le j$<ol><li>枚举区间长度；</li><li>枚举区间的起点，根据区间起点和区间长度得出区间终点；</li><li>枚举区间的分割点，根据状态转移方程计算合并区间后的最优值。</li></ol></li></ul></blockquote><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/submissions/">最长回文子序列</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照区间长度进行阶段划分。</li><li>定义状态：dp[i][j]表示s在[i,j]范围内的最长回文子序列长度。</li><li>状态转移方程：$dp[i][j] &#x3D; \begin{cases} max \lbrace dp[i + 1][j - 1] + 2 \rbrace &amp; s[i] &#x3D; s[j] \cr max \lbrace dp[i][j - 1], dp[i - 1][j] \rbrace &amp; s[i] \ne s[j] \end{cases}$</li><li>初始条件：单个字符的最长回文序列是1，<code>dp[i][i] = 1</code></li><li>返回结果：<code>dp[i][j]</code>依赖于<code>dp[i+1][j-1]</code>、<code>dp[i+1][j]</code>和<code>dp[i][j-1]</code>，所以i应该从n-1到0枚举，而j应该从i+1到n-1枚举。所以最终应该返回<code>dp[0][n-1]</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-comment">// 定义状态</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-comment">// 初始化单个字符串的最长回文子序列长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            dp[i][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 枚举起点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-comment">// 枚举终点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(s[i] == s[j])&#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n^2)$</li></ul><h2 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a><a href="https://leetcode.cn/problems/burst-balloons/">戳气球</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>在首尾加上两个气球，金币数为1，方便计算。</p><ol><li>划分阶段：按照区间长度进行阶段划分。</li><li>定义状态：dp[i][j]表示戳破所有(i,j)之间的气球所获得的最大金币数。</li><li>状态转移方程：假设气球i与气球j之间最后一个被戳破的气球编号为<code>dp[i][j] = dp[i][k] + dp[k][j] + cost(k)</code>，<code>cost(k) = max(nums[i] × nums[k] × nums[j]), i &lt; k &lt; j</code>。</li><li>初始条件：dp[i][j]表示的是开区间，则<code>i &lt; j-1</code>，当<code>i &gt;= j-1, dp[i][j] = 0</code>。</li><li>返回结果：dp[0][n+1]。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<br>        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        arr[n+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            arr[i] = nums[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 定义状态</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">2</span>));<br>        <span class="hljs-comment">// 枚举区间长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">3</span>; len &lt;= n+<span class="hljs-number">2</span>; len++)&#123;<br>            <span class="hljs-comment">// 枚举起点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n+<span class="hljs-number">2</span>; i++)&#123;<br>                <span class="hljs-comment">// 计算终点</span><br>                <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 终点超过边界</span><br>                <span class="hljs-keyword">if</span>(j &gt;= n + <span class="hljs-number">2</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 枚举中间值k</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>; k &lt;= j<span class="hljs-number">-1</span>; k++)&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i][k] + dp[k][j] + arr[i] * arr[k] * arr[j]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n+<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^3)$</li><li>空间复杂度：$O(n^2)$</li></ul><h2 id="切棍子的最小成本"><a href="#切棍子的最小成本" class="headerlink" title="切棍子的最小成本"></a><a href="https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/">切棍子的最小成本</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>在数组中添加0和n并进行排序，形成区间。</p><ol><li>划分阶段：按照区间长度进行阶段划分。</li><li>定义状态：dp[i][j]表示切割[i,j]上的小木棍的最小成本。</li><li>状态转移方程：$dp[i][j] &#x3D; min \lbrace dp[i][k] + dp[k][j] + cuts[j] - cuts[i] \rbrace, \quad i &lt; k &lt; j$</li><li>初始条件：相邻位置之间没有切割点，不需要切割，最小成本为0，即dp[i-1][i]&#x3D;0。其余位置默认为最小成本为一个极大值。</li><li>返回结果：dp[0][n-1]。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCost</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cuts)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理成区间</span><br>        cuts.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        cuts.<span class="hljs-built_in">push_back</span>(n);<br>        <span class="hljs-built_in">sort</span>(cuts.<span class="hljs-built_in">begin</span>(), cuts.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> size = cuts.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 定义状态</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(size, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(size));<br>        <span class="hljs-comment">// 初始化相邻位置之间的成本为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++)&#123;<br>            dp[i<span class="hljs-number">-1</span>][i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 枚举区间长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">3</span>; len &lt;= size; len++)&#123;<br>            <span class="hljs-comment">// 枚举起点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>                <span class="hljs-comment">// 计算终点</span><br>                <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(j &gt;= size)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 枚举中间值K</span><br>                dp[i][j] = INT_MAX;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i+<span class="hljs-number">1</span>; k &lt; j; k++)&#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][size<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^3)$</li><li>空间复杂度：$O(n^2)$</li></ul><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文子串</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>之前都是用双指针的方法做的，根据上面学习的内容，再来用动态规划做一遍。</p><ol><li>划分阶段：按照区间长度进行阶段划分。</li><li>定义状态：dp[i][j]表示s[i:j]是否是回文的。</li><li>状态转移方程：$s[i] &#x3D; s[j], dp[i][j] &#x3D; \begin{cases} true &amp; j-i \leq 2 \cr dp[i+1][j - 1] &amp; else \end{cases}$</li><li>初始条件：dp[i][j]&#x3D;false.</li><li>返回结果：s[maxStart:maxStart+maxLen]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n));<br>        <span class="hljs-comment">// 记录</span><br>        <span class="hljs-type">int</span> maxStart = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxLen = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 枚举结束位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-comment">// 枚举起始位置</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; j; i++)&#123;<br>                <span class="hljs-keyword">if</span>(s[i] == s[j])&#123;<br>                    <span class="hljs-keyword">if</span>(j - i &lt;= <span class="hljs-number">2</span>)&#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>];<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 更新最大长度</span><br>                <span class="hljs-keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLen)&#123;<br>                    maxLen = j - i + <span class="hljs-number">1</span>;<br>                    maxStart = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(maxStart, maxLen);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n^2)$</li></ul><h2 id="预测赢家"><a href="#预测赢家" class="headerlink" title="预测赢家"></a><a href="https://leetcode.cn/problems/predict-the-winner/">预测赢家</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照区间长度进行阶段划分。</li><li>定义状态：dp[i][j]表示玩家1和玩家2在nums[i]…nums[j]之间选取，玩家1比玩家2多的最大分数。</li><li>状态转移方程：$dp[i][j] &#x3D; \begin{cases}<br> nums[i] &amp; i &#x3D;&#x3D; j \cr \max \lbrace nums[i]-dp[i+1][j], nums[j]-dp[i][j-1] \rbrace &amp; i \neq j<br>\end{cases}$</li><li>初始条件：如果<code>i == j</code>，<code>dp[i][j] = nums[i]</code></li><li>返回结果：dp[0][n-1]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">predictTheWinner</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-comment">// 枚举区间长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; len++)&#123;<br>            <span class="hljs-comment">// 枚举起点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>                <span class="hljs-comment">// 计算终点</span><br>                <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 超出边界</span><br>                <span class="hljs-keyword">if</span>(j &gt;= n)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 如果i==j</span><br>                <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>)&#123;<br>                    dp[i][j] = nums[i];<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(nums[i]-dp[i+<span class="hljs-number">1</span>][j], nums[j]-dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>] &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n^2)$</li></ul><h2 id="奇怪的打印机"><a href="#奇怪的打印机" class="headerlink" title="奇怪的打印机"></a><a href="https://leetcode.cn/problems/strange-printer/">奇怪的打印机</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照区间长度进行阶段划分。</li><li>定义状态：dp[i][j]表示打印i…j之间字符所需要的最少操作次数。</li><li>状态转移方程：$dp[i][j] &#x3D; \begin{cases}<br> 1 &amp; i &#x3D;&#x3D; k \cr dp[i][j-1] &amp; s[i] &#x3D;&#x3D; s[j] \cr \min \lbrace dp[i][k] + dp[k+1][j] \rbrace &amp; s[i] \neq s[j], i &lt; k &lt; j<br>\end{cases}$</li><li>初始条件：如果<code>i == j</code>，则<code>dp[i][j] = 1</code>，否则初始化为<code>INT_MAX</code>.</li><li>返回结果：dp[0][n-1]。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strangePrinter</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            dp[i][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 枚举区间长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len++)&#123;<br>            <span class="hljs-comment">// 枚举起点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>                <span class="hljs-comment">// 计算终点</span><br>                <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 超出边界</span><br>                <span class="hljs-keyword">if</span>(j &gt;= n)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 初始化</span><br>                dp[i][j] = <span class="hljs-number">100</span>;<br>                <span class="hljs-comment">// 如果相等</span><br>                <span class="hljs-keyword">if</span>(s[i] == s[j])&#123;<br>                    dp[i][j] = dp[i][j<span class="hljs-number">-1</span>];<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 否则枚举</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i; k &lt; j; k++)&#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i][k] + dp[k+<span class="hljs-number">1</span>][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^3)$</li><li>空间复杂度：$O(n^2)$</li></ul><h2 id="合并石头的最低成本"><a href="#合并石头的最低成本" class="headerlink" title="合并石头的最低成本"></a><a href="https://leetcode.cn/problems/minimum-cost-to-merge-stones/description/">合并石头的最低成本</a></h2><h3 id="动态规划-前缀和"><a href="#动态规划-前缀和" class="headerlink" title="动态规划+前缀和"></a>动态规划+前缀和</h3><p>先将无法将所有的石头合并成一堆的情况排除出去：每次将k堆合并成1堆，堆数会减少k-1堆。当$(n-1) \bmod (k-1) &#x3D;&#x3D; 0$，说明可以将所有的石头合并成一堆，否则不能。</p><p>使用前缀和的方法计算出前i堆石头成本。</p><ol><li>划分阶段：按照区间长度划分。</li><li>定义状态：dp[i][j][m]表示将区间[i,j]的石堆合并成m堆需要的最少成本，m取值为[1,k]。</li><li>状态转移方程：<ul><li>先合并成m堆石头，$dp[i][j][m] &#x3D; min_{i \le n &lt; j} \lbrace dp[i][n][1] + dp[n + 1][j][m - 1] \rbrace$。</li><li>再合并成一堆：$dp[i][j][1] &#x3D; dp[i][j][k] + \sum_{t &#x3D; i}^{t &#x3D; j} stones[t]$</li></ul></li><li>初始条件：<code>dp[i][i][1] = 0</code></li><li>返回结果：<code>dp[0][size-1][1]</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mergeStones</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; stones, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 排除情况</span><br>        <span class="hljs-type">int</span> size = stones.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>((size<span class="hljs-number">-1</span>) % (k<span class="hljs-number">-1</span>) != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 计算前缀和</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(size + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size; i++)&#123;<br>            prefix[i] = prefix[i<span class="hljs-number">-1</span>] + stones[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 定义状态</span><br>        vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(size, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(size, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(k+<span class="hljs-number">1</span>, <span class="hljs-number">10000000</span>)));<br>        <span class="hljs-comment">// 初始化区间为1的情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>            dp[i][i][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 枚举区间</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= size; len++)&#123;<br>            <span class="hljs-comment">// 枚举起点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>                <span class="hljs-comment">// 计算终点</span><br>                <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 超出边界</span><br>                <span class="hljs-keyword">if</span>(j &gt;= size)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 将石头合并成m堆</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m = <span class="hljs-number">2</span>; m &lt;= k; m++)&#123;<br>                    <span class="hljs-comment">// 以k步枚举分割点n</span><br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n = i; n &lt; j; n += k<span class="hljs-number">-1</span>)&#123;<br>                        dp[i][j][m] = <span class="hljs-built_in">min</span>(dp[i][j][m], dp[i][n][<span class="hljs-number">1</span>] + dp[n+<span class="hljs-number">1</span>][j][m<span class="hljs-number">-1</span>]);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 合成一堆</span><br>                dp[i][j][<span class="hljs-number">1</span>] = dp[i][j][k] + prefix[j+<span class="hljs-number">1</span>] - prefix[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][size<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^3 \times k)$</li><li>空间复杂度：$O(n^2 \times k)$</li></ul><h3 id="动态规划-状态优化"><a href="#动态规划-状态优化" class="headerlink" title="动态规划 + 状态优化"></a>动态规划 + 状态优化</h3><p>上一种思路中，dp[i][j][m]表示将[i,j]区间的石头合并成m堆，m的取值为[1,k]。初始时，[i,j]内的堆数为j-i+1堆，每次合并都会减少k-1堆，合并到无法合并时的堆数固定为$(j-i) \bmod (k-1) + 1$，因此定义dp[i][j]为合并到无法合并时的最低成本。</p><ol><li>划分阶段：按照区间长度进行阶段划分。</li><li>定义状态：dp[i][j]为合并到无法合并时的最低成本。</li><li>状态转移方程：枚举n，将区间[i,j]拆分成[i,n]和[n+1,j]两个区间，$dp[i][j] &#x3D; min_{i \le n &lt; j} \lBrace dp[i][n] + dp[n+1][j] \rBrace$，如果$(j-i) \bmod (k-1) &#x3D;&#x3D; 0$，说明区间可以合并成一堆，<code>dp[i][j] += prefix[j+1] - prefix[i]</code></li><li>初始条件：长度为1的区间合并到无法合并时的最低成本为0，<code>dp[i][i] = 0</code></li><li>返回结果：dp[0][size-1]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mergeStones</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; stones, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 排除情况</span><br>        <span class="hljs-type">int</span> size = stones.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>((size<span class="hljs-number">-1</span>) % (k<span class="hljs-number">-1</span>) != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 计算前缀和</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(size + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size; i++)&#123;<br>            prefix[i] = prefix[i<span class="hljs-number">-1</span>] + stones[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 定义状态</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(size, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(size, <span class="hljs-number">10000000</span>));<br>        <span class="hljs-comment">// 初始化区间为1的情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>            dp[i][i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 枚举区间长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= size; len++)&#123;<br>            <span class="hljs-comment">// 枚举起点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>                <span class="hljs-comment">// 计算终点</span><br>                <span class="hljs-type">int</span> j = i + len <span class="hljs-number">-1</span>;<br>                <span class="hljs-comment">// 超出边界</span><br>                <span class="hljs-keyword">if</span>(j &gt;= size)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <br>                <span class="hljs-comment">// 枚举分割点</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n = i; n &lt; j; n+=k<span class="hljs-number">-1</span>)&#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i][n] + dp[n+<span class="hljs-number">1</span>][j]);<br>                &#125;<br>                <span class="hljs-comment">// 区间可以合并成一堆</span><br>                <span class="hljs-keyword">if</span>((j-i) % (k<span class="hljs-number">-1</span>) == <span class="hljs-number">0</span>)&#123;<br>                    dp[i][j] += prefix[j+<span class="hljs-number">1</span>] - prefix[i];<br>                &#125; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][size<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^3)$</li><li>空间复杂度：$O(n^2)$</li></ul><p><a href="https://github.com/datawhalechina/leetcode-notes/blob/main/docs/ch05/05.04/05.04.04-Interval-DP-List.md">区间DP剩余题目</a></p><p><img src="/2024/10/05/posts/0504%E5%8C%BA%E9%97%B4DP%E5%92%8C%E6%A0%91%E5%BD%A2DP/image.png" alt="树形DP"></p><p>固定根的树形 DP 问题，如果是二叉树，树通常是以根节点的形式给出。我们可以直接从指定根节点出发进行深度优先搜索。如果是多叉树，树是以一张n个节点、n - 1条边的无向图形式给出的，并且事先给出指定根节点的编号。这种情况下，我们要先用邻接表存储下这n个点和n-1条边，然后从指定根节点出发进行深度优先搜索，并注意标记节点是否已经被访问过，以避免在遍历中沿着反向边回到父节点。</p><h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">二叉树中的最大路径和</a></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>该二叉树的最大路径和 &#x3D; max(左子树中最大贡献值 + 右子树中最大贡献值 + 当前节点值，所有子树中最大路径和)。这道题在学递归算法的时候做过，再做一遍加深印象。</p><h2 id="相邻字符不同的最长路径"><a href="#相邻字符不同的最长路径" class="headerlink" title="相邻字符不同的最长路径"></a><a href="https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/">相邻字符不同的最长路径</a></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>最长路径长度 &#x3D; max(某子树中的最长路径长度 + 另一子树中的最长路径长度 + 1，某个子树中的最长路径长度)。</p><ol><li>先计算出从相邻节点v出发的最长路径长度vLen。</li><li>更新维护全局最长路径长度为<code>res = max(res, uLen + vLen + 1)</code></li><li>更新维护当前节点最长路径长度<code>uLen = max(uLen, vLen + 1)</code></li></ol><p>因为题目限定了「相邻节点字符不同」，所以在更新全局最长路径长度和当前节点u的最长路径长度时，我们需要判断一下节点<br>u与相邻节点v的字符是否相同，只有在字符不同的条件下，才能够更新维护。</p><p>题目要求的是树的直径（树的最长路径长度）中的节点个数,节点个数&#x3D;路径长度+1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestPath</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; parent, string s)</span> </span>&#123;<br>        <span class="hljs-comment">// 根据 parent 数组，建立有向图</span><br>        <span class="hljs-type">int</span> n = parent.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            graph[parent[i]].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-comment">// 递归</span><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, graph, s);<br>        <span class="hljs-keyword">return</span> res + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, string&amp; s)</span></span>&#123;<br>        <span class="hljs-type">int</span> uLen = <span class="hljs-number">0</span>;   <span class="hljs-comment">//u 节点的最大路径长度</span><br>        <span class="hljs-comment">// 遍历 u 节点的相邻节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : graph[u])&#123;<br>            <span class="hljs-type">int</span> vLen = <span class="hljs-built_in">dfs</span>(v, graph, s);   <span class="hljs-comment">// 相邻节点的最大路径长度</span><br>            <span class="hljs-comment">// 如果相邻字符不同，更新结果和当前节点最大路径长度</span><br>            <span class="hljs-keyword">if</span>(s[u] != s[v])&#123;<br>                res = <span class="hljs-built_in">max</span>(res, uLen + vLen + <span class="hljs-number">1</span>);<br>                uLen = <span class="hljs-built_in">max</span>(uLen, vLen + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uLen;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><blockquote><p>[!NOTE]<br>在函数参数中传值和传引用有很大的区别，在这道题中，如果dfs函数按值传递，即<code>dfs(string s)</code>会超出内存限制，这是因为每次递归调用时都要复制字符串。而传引用，即<code>dfs(string&amp; s)</code>可以节省大量内存，特别是当字符串比较长时。</p></blockquote><p>「两次扫描与换根法」:</p><ol><li>第一次扫描时，任选一个节点为根，在「有固定根的树」上执行一次树形 DP，预处理树的一些相关信息。</li><li>第二次扫描时，从刚才的根节点出发，对整棵树再执行一次深度优先搜索，同时携带根节点的一些信息提供给子节点进行推导，计算出「换根」之后的解。</li></ol><h2 id="最小高度树"><a href="#最小高度树" class="headerlink" title="最小高度树"></a><a href="https://leetcode.cn/problems/minimum-height-trees/">最小高度树</a></h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><ol><li>图的构建：用邻接表graph存储每个节点的邻居节点。</li><li>自底向上DFS，计算每个节点向下的最长路径：<ul><li>dfs函数实现了一次深度优先搜索（DFS），用于从叶子节点开始向上收集信息，即从子节点往父节点传递最长路径信息。</li><li>定义两个数组down1和down2，分别记录从每个节点出发向下走的最长路径和次长路径。</li><li>通过比较每个子节点的高度（即down1[v] + 1），更新当前节点的down1和down2，即节点向下走的最长路径和次长路径。同时，用p[u]记录下这个最长路径是由哪个子节点传上来的。</li></ul></li><li>自顶向下DFS，计算每个节点向上的最长路径：<ul><li>完成自底向上的DFS后，接着要计算每个节点向上的最长路径，即如果该节点作为根节点，其向父节点方向可以走多远。定义一个数组up来记录这一信息。</li><li>reroot函数实现自顶向下的动态规划。对于每个节点u的每个子节点v：<ul><li>如果v是当前节点u的最长路径的子节点（即p[u] &#x3D;&#x3D; v），则up[v]从u向上走的最长路径要结合down2[u]（次长路径）来计算。</li><li>如果v不是最长路径的子节点，up[v]从u向上走的路径可以结合down1[u]（最长路径）来计算。</li></ul></li></ul></li><li>计算每个节点的最大高度：</li></ol><ul><li>对于每个节点，树的高度就是它的最大高度，也就是它向下的最长路径down1[i]和向上的最长路径up[i]的最大值。</li><li>找到所有节点中具有最小高度的那些节点。</li></ul><ol start="5"><li>最后，将所有具有最小高度的节点放入结果数组中并返回。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMinHeightTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-comment">// 邻接表构建图</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; edge : edges)&#123;<br>            <span class="hljs-type">int</span> u = edge[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> v = edge[<span class="hljs-number">1</span>];<br>            graph[u].<span class="hljs-built_in">push_back</span>(v);<br>            graph[v].<span class="hljs-built_in">push_back</span>(u);<br>        &#125;<br>        <span class="hljs-comment">// down1 用于记录向下走的最长路径 </span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">down1</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-comment">// down2 用于记录向下走的次长路径 </span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">down2</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-comment">// p[u]记录下这个最长路径是由哪个子节点传上来的</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n)</span></span>;<br><br>        <span class="hljs-comment">// 自底向上记录最长路径、次长路径</span><br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)&#123;<br>            <span class="hljs-comment">// 遍历所有邻接节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : graph[u])&#123;<br>                <span class="hljs-keyword">if</span>(v == fa)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 自底向上统计信息</span><br>                <span class="hljs-built_in">dfs</span>(v, u);<br>                <span class="hljs-type">int</span> height = down1[v] + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 当前节点经过v的最长路径</span><br>                <span class="hljs-comment">// 更新</span><br>                <span class="hljs-keyword">if</span>(height &gt; down1[u])&#123;<br>                    down2[u] = down1[u];<br>                    down1[u] = height;<br>                    p[u] = v;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(height &gt; down2[u])&#123;<br>                    down2[u] = height;<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <br>        <span class="hljs-comment">// 进行换根动态规划，自顶向下统计向上走的最长路径</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up</span><span class="hljs-params">(n)</span></span>;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; reroot = [&amp;](<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)&#123;<br>            <span class="hljs-comment">// 遍历u的所有邻接节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : graph[u])&#123;<br>                <span class="hljs-keyword">if</span>(v == fa)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 如果u的向下最长路径经过v</span><br>                <span class="hljs-keyword">if</span>(p[u] == v)&#123;<br>                    up[v] = <span class="hljs-built_in">max</span>(up[u], down2[u]) + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    up[v] = <span class="hljs-built_in">max</span>(up[u], down1[u]) + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-comment">// 自顶向下统计信息</span><br>                <span class="hljs-built_in">reroot</span>(v, u);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">// 自底向上统计信息</span><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">// 自顶向下统计信息</span><br>        <span class="hljs-built_in">reroot</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">// 找到所有树中的最小高度</span><br>        <span class="hljs-type">int</span> minHeight = INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            minHeight = <span class="hljs-built_in">min</span>(minHeight, <span class="hljs-built_in">max</span>(down1[i], up[i]));<br>        &#125;<br>        <span class="hljs-comment">// 将所有最小高度根加入数组</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> h = <span class="hljs-built_in">max</span>(down1[i], up[i]);<br>            <span class="hljs-keyword">if</span>(h == minHeight)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><blockquote><p>[!WARNING]<br>这道题按照给的步骤思路写出来了，但是不是特别懂，以后再看看。</p></blockquote><p><a href="https://github.com/datawhalechina/leetcode-notes/blob/main/docs/ch05/05.04/05.04.06-Exercises.md">练习题目</a></p><h2 id="最长同值路径"><a href="#最长同值路径" class="headerlink" title="最长同值路径"></a><a href="https://leetcode.cn/problems/longest-univalue-path/description/">最长同值路径</a></h2><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>二叉树的直径 &#x3D; max(左子树高度+右子树高度,所有子树最大直径长度)。</p><p>在递归遍历左子树时，如果当前节点与左子树的值相同，则：$\text{包含当前节点向左的最长同值路径长度} &#x3D; \text{左子树最长同值路径长度} + 1$，否则为 0。</p><p>在递归遍历左子树时，如果当前节点与左子树的值相同，则：$\text{包含当前节点向右的最长同值路径长度} &#x3D; \text{右子树最长同值路径长度} + 1$，否则为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestUnivaluePath</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-comment">// 如果root为空</span><br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 递归计算左右子树</span><br>        <span class="hljs-type">int</span> leftLen = <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rightLen = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-comment">// 判断和当前节点值是否相等</span><br>        <span class="hljs-keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;val == root-&gt;val)&#123;<br>            leftLen++;<br>        &#125; <br>        <span class="hljs-keyword">else</span>&#123;<br>            leftLen = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;right-&gt;val == root-&gt;val)&#123;<br>            rightLen++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            rightLen = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 更新结果</span><br>        res = <span class="hljs-built_in">max</span>(res, leftLen + rightLen);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftLen, rightLen);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><h2 id="统计子树中城市之间最大距离"><a href="#统计子树中城市之间最大距离" class="headerlink" title="统计子树中城市之间最大距离"></a><a href="https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/description/">统计子树中城市之间最大距离</a></h2><h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><ol><li>通过二进制枚举的方式，得到所有子树。</li><li>对于当前子树，通过树形 DP + 深度优先搜索的方式，计算出当前子树的直径。</li><li>统计所有子树直径中经过的不同边数个数，将其放入答案数组中。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countSubgraphsForEachDiameter</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-comment">// 构建图</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; edge : edges)&#123;<br>            <span class="hljs-type">int</span> u = edge[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> v = edge[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;<br>            graph[u].<span class="hljs-built_in">push_back</span>(v);<br>            graph[v].<span class="hljs-built_in">push_back</span>(u);<br>        &#125;<br><br>        <span class="hljs-type">int</span> visited = <span class="hljs-number">0</span>, diameter = <span class="hljs-number">0</span>;                 <span class="hljs-comment">// visited 位掩码和当前子图的直径</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;                     <span class="hljs-comment">// 用于存储结果</span><br><br>        <span class="hljs-comment">// 深度优先搜索函数</span><br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> mask, <span class="hljs-type">int</span> u) -&gt; <span class="hljs-type">int</span>&#123;<br>            visited |= (<span class="hljs-number">1</span> &lt;&lt; u);  <span class="hljs-comment">// 标记 u 访问过</span><br>            <span class="hljs-type">int</span> uLen = <span class="hljs-number">0</span>;       <span class="hljs-comment">// u 节点的最大路径长度</span><br>            <span class="hljs-comment">// 遍历 u 的相邻节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : graph[u])&#123;<br>                <span class="hljs-comment">// 如果 v 未被访问且在子集中</span><br>                <span class="hljs-keyword">if</span>(((visited &gt;&gt; v) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp; ((mask &gt;&gt; v) &amp; <span class="hljs-number">1</span>))&#123;<br>                    <span class="hljs-comment">// 递归计算 v 节点的最大路径长度</span><br>                    <span class="hljs-type">int</span> vLen = <span class="hljs-built_in">dfs</span>(mask, v);<br>                    <span class="hljs-comment">// 更新</span><br>                    diameter = <span class="hljs-built_in">max</span>(diameter, uLen + vLen + <span class="hljs-number">1</span>);<br>                    uLen = <span class="hljs-built_in">max</span>(uLen, vLen + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> uLen;<br>        &#125;;<br>        <span class="hljs-comment">// 二进制枚举子集</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> mask = <span class="hljs-number">3</span>; mask &lt; (<span class="hljs-number">1</span> &lt;&lt; n); mask++)&#123;<br>            <span class="hljs-comment">// 排除只有一个节点被选择的情况</span><br>            <span class="hljs-keyword">if</span>(__builtin_popcount(mask) &lt;= <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            visited = <span class="hljs-number">0</span>;<br>            diameter = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 找到子集中最高位的节点</span><br>            <span class="hljs-type">int</span> u = <span class="hljs-number">31</span> - __builtin_clz(mask);<br>            <span class="hljs-comment">// 计算子集的直径</span><br>            <span class="hljs-built_in">dfs</span>(mask, u);<br>            <span class="hljs-comment">// 如果子集内所有节点都被访问，更新对应直径的计数</span><br>            <span class="hljs-keyword">if</span> (visited == mask)&#123;<br>                ans[diameter<span class="hljs-number">-1</span>]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times 2^n)$</li><li>空间复杂度：$O(n)$</li></ul><h2 id="树中距离之和"><a href="#树中距离之和" class="headerlink" title="树中距离之和"></a><a href="https://leetcode.cn/problems/sum-of-distances-in-tree/description/">树中距离之和</a></h2><h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><p>第一次遍历：从编号为0的根节点开始，自底向上地计算出节点0到其他的距离之和，记录在 res[0]中。并且统计出以子节点为根节点的子树节点个数size[v]。</p><p>第二次遍历：从编号为0的根节点开始，自顶向下地枚举每个点，计算出将每个点作为新的根节点时，其他节点到根节点的距离之和。如果当前节点为v，其父节点为u，则自顶向下计算出res[u]后，将根节点从u换为节点v，子树上的点到新根节点的距离比原来都小了1，非子树上剩下所有点到新根节点的距离比原来都大了1。则可以据此计算出节点v与其他节点的距离和为：$res[v] &#x3D; res[u] + n - 2 \times sizes[u]$。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0503背包问题</title>
    <link href="/2024/09/29/posts/0503%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2024/09/29/posts/0503%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="05-03-背包问题"><a href="#05-03-背包问题" class="headerlink" title="05.03 背包问题"></a>05.03 背包问题</h1><p>滚动数组优化：</p><p>$dp[w] &#x3D; \begin{cases} dp[w] &amp; w &lt; weight[i - 1] \cr max \lbrace dp[w], dp[w - weight[i - 1]] + value[i - 1] \rbrace &amp; w \ge weight[i - 1] \end{cases}$</p><h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">分割等和子集</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>先把数组的和求出来，然后转化成01背包问题，即找到能够装入sum&#x2F;2的。</p><ol><li>划分阶段：按照当前背包的载重上限进行阶段划分。</li><li>定义状态：定义状态dp[w]表示为：从数组nums中选择一些元素，放入最多能装元素和为w的背包中，得到的元素和最大为多少。</li><li>状态转移方程：$dp[w] &#x3D; \begin{cases} dp[w] &amp; w &lt; nums[i - 1] \cr max \lbrace dp[w], \quad dp[w - nums[i - 1]] + nums[i - 1] \rbrace &amp; w \ge nums[i - 1] \end{cases}$</li><li>初始条件：无论背包载重上限为多少，只要不选择物品，可以获得的最大价值一定是0，即dp[w] &#x3D; 0.</li><li>返回结果：最后判断dp[target]是否等于target。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 求和</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 枚举前 i 种物品</span><br>        <span class="hljs-type">int</span> weight = target;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-comment">// 逆序枚举背包装载重量</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w = weight; w &gt;= nums[i<span class="hljs-number">-1</span>]; w--)&#123;<br>                dp[w] = <span class="hljs-built_in">max</span>(dp[w], dp[w-nums[i<span class="hljs-number">-1</span>]] + nums[i<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target] == target;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times target)$</li><li>空间复杂度：$O(target)$</li></ul><h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a href="https://leetcode.cn/problems/target-sum/">目标和</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>之前在记忆化搜索部分做过这道题，这里用动态规划再做一遍。</p><p>数组中所有前面为＋的数字和记为<code>sum_x</code>，为-的数字和记为<code>sum_y</code>，则<code>target = sum_x - sum_y</code>，而<code>sum = sum_x + sum_y</code>，可以推出<code>sum_x = (sum + target) / 2</code>，转化问题为如何在数组中找到一个集合，使集合中元素和为<code>sum_x = (sum + target) / 2</code>，背包容量为<code>sum_x = (sum + target) / 2</code>的01背包问题。</p><ol><li>定义状态：dp[i]表示填满容量为i的方法数。</li><li>状态转移方程：<ul><li>不使用当前数字：dp[i]</li><li>使用当前数字：dp[i-num]</li></ul></li></ol><p>  dp[i] &#x3D; dp[i] + dp[i-num]<br>3. 初始化：默认填满容量为0的背包方法有1种，即dp[i] &#x3D; 1.<br>4. 返回结果：dp[n]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// 转化问题</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 边界条件</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target) &gt; <span class="hljs-built_in">abs</span>(sum) || (sum+target) % <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> weight = (sum + target) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(weight + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-comment">// 枚举容量</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w = weight; w &gt;= nums[i<span class="hljs-number">-1</span>]; w--)&#123;<br>                dp[w] = dp[w] + dp[w-nums[i<span class="hljs-number">-1</span>]]; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[weight];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times weight)$</li><li>空间复杂度：O(weight)</li></ul><h2 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a><a href="https://leetcode.cn/problems/last-stone-weight-ii/">最后一块石头的重量II</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>问题转化为：把一堆石头尽量平均的分成两对，求两堆石头重量差的最小值。两堆石头的重量要尽可能的接近数组总数量和的一半。先对所有重量求和，然后target&#x3D;sum&#x2F;2，转化为容量为target&#x2F;2的01背包。</p><ol><li>划分阶段：按照石头的序号进行阶段划分。</li><li>定义状态：dp[w]表示在容量为w时的价值。</li><li>状态转移方程：<code>dp[w] = max(dp[w], dp[w-stones[i-1]] + nums[i-1])</code></li><li>初始条件：dp[w] &#x3D; 0</li><li>返回结果：sum - dp[target] - dp[target]。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> </span>&#123;<br>        <span class="hljs-comment">// 转化问题</span><br>        <span class="hljs-type">int</span> n = stones.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            sum += stones[i];<br>        &#125;<br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 定义数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 枚举每一块石头</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-comment">// 枚举背包容量</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w = target; w &gt;= stones[i<span class="hljs-number">-1</span>]; w--)&#123;<br>                dp[w] = <span class="hljs-built_in">max</span>(dp[w], dp[w-stones[i<span class="hljs-number">-1</span>]]+stones[i<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - dp[target] * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times target)$</li><li>空间复杂度：O(target)</li></ul><p><a href="https://github.com/datawhalechina/leetcode-notes/blob/main/docs/ch05/05.03/05.03.07-Exercises.md">第八天</a></p><h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></h2><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><ol><li>定义集合visited避免重复计算，定义队列存放节点，定义count为完全平方数的最小数量。</li><li>初始化：将n标记为Visited，并加入队列。</li><li>依次将队列中的节点值取出，count+1。</li><li>对于取出的节点值，遍历可能出现的平方数，即从$[1, \sqrt {value} + 1]$</li><li>每次从当前节点值减去一个平方数，并将减完的数加入队列。<ul><li>如果此时的数等于0，则满足题意，返回当前树的最小深度。</li><li>如果此时的数不等于0，则将其加入队列，继续查找。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; visited;<br>        queue&lt;<span class="hljs-type">int</span>&gt; que;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 初始化</span><br>        visited.<span class="hljs-built_in">insert</span>(n);<br>        que.<span class="hljs-built_in">push</span>(n);<br>        <span class="hljs-comment">// 依次从队列中取出</span><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            count++;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>                <span class="hljs-type">int</span> value = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= <span class="hljs-built_in">sqrt</span>(value)+<span class="hljs-number">1</span>; v++)&#123;<br>                    <span class="hljs-type">int</span> x = value - v * v;<br>                    <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-keyword">return</span> count;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">find</span>(x) == visited.<span class="hljs-built_in">end</span>())&#123;<br>                        que.<span class="hljs-built_in">push</span>(x);<br>                        visited.<span class="hljs-built_in">insert</span>(x);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times \sqrt{n})$</li><li>空间复杂度：O(n)</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>将题目转化成01背包问题。将$k&#x3D;1,2,4,9…$当成k种物品，每种物品都可以无限次使用。将n看成背包的容量。即，用K种物品装入容量为n的背包，所需要的最少物品数。</p><ol><li>划分阶段：按照当前背包的载重上限进行阶段划分。</li><li>定义状态：dp[w]表示从完全平方数中挑选一些数，使其和恰好凑w所需的最少个完全平方数。</li><li>状态转移方程：<code>dp[w] = min(dp[w], dp[w-num]+1)</code></li><li>初始条件：<code>dp[0]=0</code>，对于其他状态，则为无限大，可以设置为n+1.</li><li>返回结果：dp[n]。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 循环遍历</span><br>        <span class="hljs-comment">// 枚举完全平方数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(n)+<span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> num = i * i;<br>            <span class="hljs-comment">// 枚举背包重量</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w = num; w &lt;= n; w++)&#123;<br>                dp[w] = <span class="hljs-built_in">min</span>(dp[w], dp[w-num]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times \sqrt{n})$</li><li>空间复杂度：O(n)</li></ul><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">零钱兑换</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照背包容量即金额进行阶段划分。</li><li>定义状态：dp[i]表示凑成i元需要的最少硬币数。</li><li>状态转移方程：<code>dp[i] = min(dp[i], dp[i-num]+1)</code></li><li>初始条件：凑成总金额为0所需的最少硬币数为0，dp[0]&#x3D;0</li><li>返回结果：dp[n]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX<span class="hljs-number">-1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 枚举物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> coin : coins)&#123;<br>            <span class="hljs-comment">// 枚举重量</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = coin; i &lt;= amount; i++)&#123;<br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i - coin] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == (INT_MAX<span class="hljs-number">-1</span>) ? <span class="hljs-number">-1</span> : dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(amount \times size)$。</li><li>空间复杂度：O(amount)</li></ul><h2 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a><a href="https://leetcode.cn/problems/coin-change-ii/">零钱兑换II</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照背包容量即金额进行阶段划分。</li><li>定义状态：dp[i]表示凑成i元有多少种组合方式。</li><li>状态转移方程：不使用当前coin+使用当前coin。即<code>dp[i] = dp[i] + dp[i-coin]</code></li><li>初始条件：凑成总金额为0的组合方式只有1种。</li><li>返回结果：dp[n]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 枚举coin</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> coin : coins)&#123;<br>            <span class="hljs-comment">// 枚举金额</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = coin; i &lt;= amount; i++)&#123;<br>                dp[i] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)dp[i] + (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)dp[i-coin];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times amount)$</li><li>空间复杂度：O(amount)</li></ul><h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a href="https://leetcode.cn/problems/word-break/description/">单词拆分</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照单词结尾位置进行阶段划分。</li><li>定义状态： 能否拆分为单词表的单词，可以分解为：前i个字符构成的字符串，能否分解为单词；剩余字符串，能否分解为单词。dp[i]表示前i个字符组成的字符串是否可以拆分成单词表的单词。</li><li>状态转移数组：如果s[0:j]可以拆分，即<code>dp[j]=true</code>，并且s[j:i]出现在字典中，则<code>dp[i] = true</code>。如果s[0:j]不可以拆分，或者s[j:i]没有出现在字典中，则<code>dp[i] = false</code>。</li><li>初始条件：长度为0的字符串可以拆分为单词，<code>dp[0] = true</code>。</li><li>返回结果：dp[n]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 放进集合便于查找</span><br>        unordered_set&lt;string&gt; set;<br>        <span class="hljs-keyword">for</span>(string str : wordDict)&#123;<br>            set.<span class="hljs-built_in">insert</span>(str);<br>        &#125;<br>        <span class="hljs-comment">// 枚举</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                string sub = s.<span class="hljs-built_in">substr</span>(j, i-j);<br>                <span class="hljs-keyword">if</span>(dp[j] &amp;&amp; set.<span class="hljs-built_in">find</span>(sub) != set.<span class="hljs-built_in">end</span>())&#123;<br>                    dp[i] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(n)</li></ul><h2 id="组合总和IV"><a href="#组合总和IV" class="headerlink" title="组合总和IV"></a><a href="https://leetcode.cn/problems/combination-sum-iv/description/">组合总和IV</a></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>本题与「完全背包问题求方案数」不同点在于：方案中不同的物品顺序代表不同方案。我们需要在考虑某一总和 时，需要将所有元素都考虑到。对应到循环关系时，即将总和的遍历放到外侧循环，将数组元素的遍历放到内侧循环。</p><ol><li>划分阶段：按照target进行阶段划分。</li><li>定义状态：dp[i]表示凑成i所有的组合方式数。</li><li>状态转移方程：<code>dp[i] = dp[i] + dp[i-num]</code></li><li>初始条件：凑成0元有一种组合方式，<code>dp[0] = 1</code>。</li><li>返回结果：dp[target]。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 枚举重量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= target; i++)&#123;<br>            <span class="hljs-comment">// 枚举物品</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>                <span class="hljs-keyword">if</span>(i &gt;= num)&#123;<br>                    dp[i] += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)dp[i-num];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times target)$</li><li>空间复杂度：O(target)</li></ul><h2 id="掷骰子等于目标和的方法数"><a href="#掷骰子等于目标和的方法数" class="headerlink" title="掷骰子等于目标和的方法数"></a><a href="https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/description/">掷骰子等于目标和的方法数</a></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照总价值target划分。</li><li>定义状态：dp[w]表示用n个骰子进行投掷，投掷出总和（总价值）为w的方案数。</li><li>状态转移方程：<code>dp[w] = dp[w] + dp[w-d]</code>，d为当前骰子投出的价值。</li><li>初始条件：dp[0] &#x3D; 1.</li><li>返回结果：dp[target]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numRollsToTarget</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod = <span class="hljs-number">1000000007</span>;;<br>        <span class="hljs-comment">// 定义状态</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 枚举骰子</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-comment">// 枚举重量</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w = target; w &gt;= <span class="hljs-number">0</span>; w--)&#123;<br>                dp[w] = <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">// 枚举数字</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d = <span class="hljs-number">1</span>; d &lt;= k; d++)&#123;<br>                    <span class="hljs-keyword">if</span>(w &gt;= d)&#123;<br>                        dp[w] = (dp[w] + dp[w-d]) % mod;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target] % mod;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times m \times target)$。</li><li>空间复杂度：O(target)</li></ul><h2 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/description/">一和零</a></h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>把0的个数和1的个数视作一个二维背包的容量。每一个字符串都当做是一件物品，其成本为字符串中1的数量和0的数量，每个字符串的价值为1。</p><ol><li>划分阶段：按照物品的序号、当前背包的载重上限进行阶段划分。</li><li>定义状态：dp[i][j]表示最多有i个0、j个1的字符串strs的最大子集的大小。</li><li>状态转移方程：<ul><li>使用之前字符串填满容量为<code>i-numZero</code>、<code>j-numOne</code>的背包物品数+当前字符串价值。</li><li>选择之前字符串填满容量为i、j的物品数。</li><li>$dp[i][j] &#x3D; max(dp[i][j], dp[i - zero\underline{\hspace{0.5em}}num][j - one\underline{\hspace{0.5em}}num] + 1)$</li></ul></li><li>初始条件：dp[i][0] &#x3D; dp[0][j] &#x3D; 0</li><li>返回结果：dp[m][n]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 枚举字符串</span><br>        <span class="hljs-keyword">for</span>(string str : strs)&#123;<br>            <span class="hljs-comment">// 统计0和1的个数</span><br>            <span class="hljs-type">int</span> numZero = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> numOne = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : str)&#123;<br>                <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                    numZero++;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    numOne++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 枚举重量</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m; i &gt;= numZero; i--)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = n; j &gt;= numOne; j--)&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i-numZero][j-numOne] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(len \times m \times n)$</li><li>空间复杂度：O(mn)</li></ul><p><a href="https://github.com/datawhalechina/leetcode-notes/blob/main/docs/ch05/05.03/05.03.09-Knapsack-Problem-List.md">剩余题目</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>01背包中不同物体只有一个，也就是说对于任一物体，只有选或不选两种选择，而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0502线性动态规划</title>
    <link href="/2024/09/26/posts/0502%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2024/09/26/posts/0502%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="单串线性-DP-问题"><a href="#单串线性-DP-问题" class="headerlink" title="单串线性 DP 问题"></a>单串线性 DP 问题</h1><blockquote><p>如果状态包含多个维度，但是每个维度上都是线性划分的阶段，也属于线性 DP。比如背包问题、区间 DP、数位 DP 等都属于线性 DP。</p><p>线性 DP 问题的划分方法有多种方式。</p><p>如果按照「状态的维度数」进行分类，我们可以将线性 DP 问题分为：一维线性 DP 问题、二维线性 DP 问题，以及多维线性 DP 问题。<br>如果按照「问题的输入格式」进行分类，我们可以将线性 DP 问题分为：单串线性 DP 问题、双串线性 DP 问题、矩阵线性 DP 问题，以及无串线性 DP 问题。</p></blockquote><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照子序列的结尾位置进行阶段划分。</li><li>定义状态：定义状态<code>dp[i]</code>表示为：以<code>nums[i]</code>结尾的最长递增子序列长度。</li><li>状态转移方程：一个较小的数后边如果出现一个较大的数，则会形成一个更长的递增子序列。$dp[i] &#x3D; \max(dp[i], dp[j]+1), 0 \leq j \leq i \And nums[j] &lt; nums[i]$</li><li>初始条件：默认状态下，把数组中的每个元素都作为长度为1的递增子序列。</li><li>最终结果：返回dp中的最大值。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j] &lt; nums[i])&#123;<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(n)</li></ul><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照子序列的结尾位置进行阶段划分。</li><li>定义状态：dp[i]表示以nums[i]结尾的最大子数组和。</li><li>状态转移：$dp[i] &#x3D; max(0, dp[i-1]) + nums[i]$</li><li>初始条件：$dp[0] &#x3D; nums[0]$</li><li>返回结果：dp最大值。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>], <span class="hljs-number">0</span>) + nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-type">int</span> res = INT_MIN;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="动态规划-滚动优化"><a href="#动态规划-滚动优化" class="headerlink" title="动态规划 + 滚动优化"></a>动态规划 + 滚动优化</h3><p>因为dp[i]只和dp[i-1]和当前元素nums[i]相关，我们也可以使用一个变量<code>subMax</code>来表示以第i-1个数结尾的连续子数组的最大和。然后使用<code>res</code>来保存全局中最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> subMax = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            subMax = <span class="hljs-built_in">max</span>(subMax, <span class="hljs-number">0</span>) + nums[i];<br>            res = <span class="hljs-built_in">max</span>(subMax, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="最长的斐波那契子序列的长度"><a href="#最长的斐波那契子序列的长度" class="headerlink" title="最长的斐波那契子序列的长度"></a><a href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/">最长的斐波那契子序列的长度</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照斐波那契式子序列相邻两项的结尾位置进行阶段划分。</li><li>定义状态：表示为：以arr[i]、arr[j]为结尾的斐波那契式子序列的最大长度。</li><li>状态转移方程：$dp[j][k] &#x3D; max_{(A[i] + A[j] &#x3D; A[k], \quad i &lt; j &lt; k)}(dp[i][j] + 1)$。</li><li>初始条件：dp[i][j] &#x3D; 2</li><li>返回结果：$res \geq 3$，返回res，否则返回0.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lenLongestFibSubseq</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 定义状态数组</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">2</span>));<br>        <span class="hljs-comment">// 映射成哈希表</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            hash[arr[i]] = i;<br>        &#125;<br>        <span class="hljs-comment">// 计算</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-comment">// 获取索引</span><br>                <span class="hljs-type">int</span> sum = arr[i] + arr[j];<br>                <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">find</span>(sum) != hash.<span class="hljs-built_in">end</span>())&#123;<br>                    <span class="hljs-type">int</span> k = hash[sum];<br>                    dp[j][k] = <span class="hljs-built_in">max</span>(dp[j][k], dp[i][j]+<span class="hljs-number">1</span>);<br>                    res = <span class="hljs-built_in">max</span>(res, dp[j][k]);<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n^2)$</li></ul><h1 id="双串线性DP问题"><a href="#双串线性DP问题" class="headerlink" title="双串线性DP问题"></a>双串线性DP问题</h1><p><img src="/2024/09/26/posts/0502%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image.png" alt="双串线性DP问题"></p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">最长公共子序列</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照两个字符串的结尾位置进行阶段划分。</li><li>定义状态：dp[i][j]等于以text1前i个字符和text2以前j个字符的子序列长度。</li><li>状态转移方程：<img src="/2024/09/26/posts/0502%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-1.png" alt="Alt text"></li><li>初始条件：dp[0][j] &#x3D; dp[i][0] &#x3D; 0</li><li>返回结果：dp[size1][size2]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态数组</span><br>        <span class="hljs-type">int</span> size1 = text1.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> size2 = text2.<span class="hljs-built_in">length</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(size1+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(size2+<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 循环遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size1; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= size2; j++)&#123;<br>                <span class="hljs-comment">// 如果子字符串的最后一个字符相等</span><br>                <span class="hljs-keyword">if</span>(text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[size1][size2];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times m)$</li><li>空间复杂度：$O(n \times m)$</li></ul><h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">最长重复子数组</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照子数组结尾位置进行阶段划分。</li><li>定义状态：dp[i][j]表示nums1前i个数字和nums2的前j个数字的最长公共子数组长度。</li><li>状态转移方程：<ul><li>如果<code>nums1[i-1] == nums2[j-1]</code>，那么<code>dp[i][j] = dp[i-1][j-1]+1</code>；</li><li>否则，<code>dp[i][j] = 0</code>。</li></ul></li><li>初始条件：dp[0][j] &#x3D; dp[i][0] &#x3D; 0</li><li>dp[i][j]中的最大值，可以在循环中用一个变量保存。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态数组</span><br>        <span class="hljs-type">int</span> size1 = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> size2 = nums2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(size1+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(size2+<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 循环遍历</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size1; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= size2; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[i<span class="hljs-number">-1</span>] == nums2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                    res = <span class="hljs-built_in">max</span>(res, dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times m)$。</li><li>空间复杂度：$O(n \times m)$。</li></ul><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/description/">编辑距离</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照两个字符串的结尾位置进行阶段划分。</li><li>定义状态：dp[i][j]表示所使用的最小操作数。</li><li>状态转移数组：<ul><li>如果<code>word1[i-1] == word[j-1]</code>，无需操作，<code>dp[i][j] = dp[i-1][j-1]</code></li><li>否则，<code>dp[i][j] = min(dp[i-1][j](插入), dp[i][j-1](删除), dp[i-1][j-1](替换)) + 1</code></li></ul></li><li>初始条件：<ul><li><code>dp[0][j]=j</code>，当word1长度为0，word2长度为j，需要执行j次插入操作。</li><li>同理<code>dp[i][0] = i</code></li></ul></li><li>返回结果：dp[size1][size2]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态数组</span><br>        <span class="hljs-type">int</span> size1 = word1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> size2 = word2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(size1+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(size2+<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= size2; j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= size1; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-comment">// 循环遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size1; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= size2; j++)&#123;<br>                <span class="hljs-keyword">if</span>(word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>], <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[size1][size2];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times m)$</li><li>空间复杂度：$O(n \times m)$</li></ul><p><a href="https://github.com/datawhalechina/leetcode-notes/blob/main/docs/ch05/05.02/05.02.06-Exercises.md">https://github.com/datawhalechina/leetcode-notes/blob/main/docs/ch05/05.02/05.02.06-Exercises.md</a></p><h2 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a><a href="https://leetcode.cn/problems/maximal-square/">最大正方形</a></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照正方形的右下角坐标进行阶段划分。</li><li>定义状态：dp[i][j]表示以矩阵位置(i,j)为右下角，且值包含1的正方形的最大边长。</li><li>状态转移方程：<ul><li><code>matrix[i][j] == 0</code>， 则<code>dp[i][j] = 0</code></li><li>否则，<code>dp[i][j]</code>由上侧、左侧、左上方共同约束，即<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</code></li></ul></li><li>初始条件：<code>dp[i][j] = 0</code>；边界条件：<code>i == 0 || j == 0</code>，如果<code>matrix[i][j] == 1</code>，则<code>dp[i][j] = 1</code>。</li><li>返回结果：dp中的最大值的平方。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态数组</span><br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-comment">// 循环遍历</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>)&#123;<br>                        dp[i][j] = <span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>], <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])) + <span class="hljs-number">1</span>;<br>                    &#125;<br>                    res = <span class="hljs-built_in">max</span>(res, dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res * res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(m \times n)$</li><li>空间复杂度：$O(m \times n)$</li></ul><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><a href="https://leetcode.cn/problems/integer-break/description/">整数拆分</a></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><ol><li><p>划分阶段：按照正整数进行划分。</p></li><li><p>定义状态：dp[i]表示将正整数i拆分成至少2个正整数的和之后，这些正整数的最大乘积。</p></li><li><p>状态转移方程：<br>当$i \geq 2$时，假设正整数i拆分出的第一个整数为$j, 1 \leq j &lt; i$：</p><ul><li>将i拆分成j和i-j的和，且i-j不再拆分为多个正整数，此时乘积为：$j \times (i - j)$。</li><li>将i拆分成j和i-j的和，且i-j继续拆分为多个正整数，此时乘积为：$j \times dp[i-j]$</li></ul><p> dp[i]取其中较大值。</p></li><li><p>初始条件：<code>dp[0] = dp[1] = 0</code>。</p></li><li><p>返回结果：dp[n]。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 循环遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)&#123;<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>(j * (i-j), j * dp[i-j]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(n)</li></ul><h2 id="只有两个键的键盘"><a href="#只有两个键的键盘" class="headerlink" title="只有两个键的键盘"></a><a href="https://leetcode.cn/problems/2-keys-keyboard/">只有两个键的键盘</a></h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照字符 ‘A’ 的个数进行阶段划分。</li><li>定义状态：dp[i]表示出现i个字符’A’所需要的最小操作次数。</li><li>状态转移方程：$dp[i] &#x3D; min_{j | i}(dp[i], dp[j] + \frac{i}{j}, dp[\frac{i}{j}] + j)$。</li><li>初始条件：dp[1] &#x3D; 0.</li><li>返回结果：dp[n]。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSteps</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            dp[i] = INT_MAX;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j * j &lt;= i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>) &#123;<br>                    dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[j] + i / j);<br>                    dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i / j] + j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \sqrt{n})$</li><li>空间复杂度：O(n)</li></ul><p><a href="https://github.com/datawhalechina/leetcode-notes/blob/main/docs/ch05/05.02/05.02.07-Linear-DP-List.md">剩余题目</a></p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0501动态规划基础</title>
    <link href="/2024/09/22/posts/0501%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/09/22/posts/0501%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="05-01-动态规划基础"><a href="#05-01-动态规划基础" class="headerlink" title="05.01 动态规划基础"></a>05.01 动态规划基础</h1><blockquote><ol><li>把「原问题」分解为「若干个重叠的子问题」，每个子问题的求解过程都构成一个 「阶段」。在完成一个阶段的计算之后，动态规划方法才会执行下一个阶段的计算。</li><li>在求解子问题的过程中，按照「自顶向下的记忆化搜索方法」或者「自底向上的递推方法」求解出「子问题的解」，把结果存储在表格中，当需要再次求解此子问题时，直接从表格中查询该子问题的解，从而避免了大量的重复计算。</li></ol></blockquote><blockquote><p>动态规划与分治算法的不同点在于：</p><ol><li>适用于动态规划求解的问题，在分解之后得到的子问题往往是相互联系的，会出现若干个重叠子问题。</li><li>使用动态规划方法会将这些重叠子问题的解保存到表格里，供随后的计算查询使用，从而避免大量的重复计算。</li></ol></blockquote><p><img src="/2024/09/22/posts/0501%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/image.png" alt="动态规划问题解决步骤"></p><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/description/">不同路径</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li>划分阶段：按照路径的结尾位置（行位置、列位置组成的二维坐标）进行阶段划分。</li><li>定义状态：dp[i][j]表示到达坐标(i,j)位置有多少条不同的路径。</li><li>状态转移：dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]</li><li>初始条件和边界条件：初始dp[0][0] &#x3D; 1；边界条件，当i &#x3D; 0时，dp[0][j] &#x3D; 1，即只能由向右走得到；当j &#x3D; 0时，dp[i][0] &#x3D; 1，即只能由向下走得到。</li><li>最终结果：返回dp[m-1][n-1]。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态数组</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-comment">// 填充行,dp[0][j] = 1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 填充列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 填充剩余部分</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(1)</li></ul><blockquote><p>记忆化搜索是动态规划的一种实现方式。在记忆化搜索中，当算法需要计算某个子问题的结果时，它首先检查是否已经计算过该问题。如果已经计算过，则直接返回已经存储的结果；否则，计算该问题，并将结果存储下来以备将来使用。</p><ul><li>记忆化搜索：「自顶向下」的解决问题，采用自然的递归方式编写过程，在过程中会保存每个子问题的解（通常保存在一个数组或哈希表中）来避免重复计算。</li></ul><p>优点：代码清晰易懂，可以有效的处理一些复杂的状态转移方程。有些状态转移方程是非常复杂的，使用记忆化搜索可以将复杂的状态转移方程拆分成多个子问题，通过递归调用来解决。</p><p>缺点：可能会因为递归深度过大而导致栈溢出问题。</p><ul><li>递推：「自底向上」的解决问题，采用循环的方式编写过程，在过程中通过保存每个子问题的解（通常保存在一个数组或哈希表中）来避免重复计算。</li></ul><p>优点：避免了深度过大问题，不存在栈溢出问题。计算顺序比较明确，易于实现。</p><p>缺点：无法处理一些复杂的状态转移方程。有些状态转移方程非常复杂，如果使用递推方法来计算，就会导致代码实现变得非常困难。</p><p>适合使用「记忆化搜索」的场景：</p><ul><li><p>问题的状态转移方程比较复杂，递推关系不是很明确。</p></li><li><p>问题适合转换为递归形式，并且递归深度不会太深</p></li></ul><p>适合使用「递推」的场景：</p><ul><li><p>问题的状态转移方程比较简单，递归关系比较明确。</p></li><li><p>问题不太适合转换为递归形式，或者递归深度过大容易导致栈溢出。</p></li></ul><ol><li>写出问题的动态规划「状态」和「状态转移方程」。</li><li>定义一个缓存（数组或哈希表），用于保存子问题的解。</li><li>定义一个递归函数，用于解决问题。在递归函数中，首先检查缓存中是否已经存在需要计算的结果，如果存在则直接返回结果，否则进行计算，并将结果存储到缓存中，再返回结果。</li><li>在主函数中，调用递归函数并返回结果。</li></ol></blockquote><h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a href="https://leetcode.cn/problems/target-sum/">目标和</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="/2024/09/22/posts/0501%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/image-1.png" alt="目标和分析"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 定义一个哈希表，存储索引和当前和</span><br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; hash;  <span class="hljs-comment">// 使用字符串作为键</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(nums, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> curSum)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果是最后一个数字</span><br>        <span class="hljs-keyword">if</span> (index == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-comment">// 如果等于目标</span><br>            <span class="hljs-keyword">return</span> curSum == target ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 记忆化搜索，使用字符串作为哈希表的键</span><br>        string key = <span class="hljs-built_in">to_string</span>(index) + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">to_string</span>(curSum);<br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">find</span>(key) != hash.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> hash[key];<br>        &#125;<br>        <br>        <span class="hljs-comment">// 搜索下一个</span><br>        <span class="hljs-type">int</span> cnt = <span class="hljs-built_in">dfs</span>(nums, target, index + <span class="hljs-number">1</span>, curSum - nums[index]) + <br>                  <span class="hljs-built_in">dfs</span>(nums, target, index + <span class="hljs-number">1</span>, curSum + nums[index]);<br>        hash[key] = cnt;  <span class="hljs-comment">// 存储结果</span><br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(2^n)$</li><li>空间复杂度：$O(n)$。递归调用的栈空间深度不超过n。</li></ul><h2 id="猜数字大小II"><a href="#猜数字大小II" class="headerlink" title="猜数字大小II"></a><a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/description/">猜数字大小II</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>通过二分查找方法，能够找到猜中的最小次数，但这个猜中的最小次数所对应的支付金额，并不是最小现金数。</p><p><img src="/2024/09/22/posts/0501%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/image-2.png" alt="猜数字大小II"></p><p>$f(1)(n) &#x3D; min_{x &#x3D; 1}^{x &#x3D; n} \lbrace max \lbrace f(1)(x - 1), f(x + 1)(n) \rbrace + x \rbrace$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义状态数组</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">2</span>));<br>        <span class="hljs-comment">// 枚举区间长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len++)&#123;<br>            <span class="hljs-comment">// 左端点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>                <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 右端点</span><br>                <span class="hljs-keyword">if</span>(j &gt; n)&#123;  <span class="hljs-comment">// 超出数字范围</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 枚举区间内数字</span><br>                dp[i][j] = INT_MAX;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i; k &lt;= j; k++)&#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], <span class="hljs-built_in">max</span>(dp[i][k<span class="hljs-number">-1</span>], dp[k+<span class="hljs-number">1</span>][j])+k);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^3)$</li><li>空间复杂度：$O(n^2)$</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0405位运算</title>
    <link href="/2024/09/19/posts/0405%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2024/09/19/posts/0405%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="04-05-位运算"><a href="#04-05-位运算" class="headerlink" title="04.05 位运算"></a>04.05 位运算</h1><p><img src="/2024/09/19/posts/0405%E4%BD%8D%E8%BF%90%E7%AE%97/image.png" alt="位运算"></p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="判断整数奇偶"><a href="#判断整数奇偶" class="headerlink" title="判断整数奇偶"></a>判断整数奇偶</h3><p>通过与1进行按位与运算，即可判断某个数是奇数还是偶数。</p><ul><li>(x &amp; 1) &#x3D;&#x3D; 0 为偶数。</li><li>(x &amp; 1) &#x3D;&#x3D; 1 为奇数。</li></ul><h3 id="二进制数选取指定位"><a href="#二进制数选取指定位" class="headerlink" title="二进制数选取指定位"></a>二进制数选取指定位</h3><p>如果我们想要从一个二进制数X中取出某几位，使取出位置上的二进位保留原值，其余位置为0，则可以使用另一个二进制数Y，使该二进制数上对应取出位置为 1<br>，其余位置为0。然后令两个数进行按位与运算（X &amp; Y），即可得到想要的数。</p><h3 id="将指定位设置为1"><a href="#将指定位设置为1" class="headerlink" title="将指定位设置为1"></a>将指定位设置为1</h3><p>按位或运算可以实现，要保持原值的为0，要变成1的位置为1。</p><h3 id="反转指定位"><a href="#反转指定位" class="headerlink" title="反转指定位"></a>反转指定位</h3><p>如果我们想要把一个二进制数X的某几位进行反转，则可以使用另一个二进制数Y，使得该二进制上对应选取位置为 1，其余位置为 0。然后令两个数进行按位异或运算。</p><h3 id="交换两个数"><a href="#交换两个数" class="headerlink" title="交换两个数"></a>交换两个数</h3><p>通过按位异或运算可以实现交换两个数的目的（只能用于交换两个整数）。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-number">10</span>, <span class="hljs-number">20</span><br><span class="hljs-selector-tag">a</span> ^= <span class="hljs-selector-tag">b</span><br><span class="hljs-selector-tag">b</span> ^= <span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">a</span> ^= <span class="hljs-selector-tag">b</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a, b)</span></span><br></code></pre></td></tr></table></figure><h3 id="将二进制最右侧为1的二进位改为0"><a href="#将二进制最右侧为1的二进位改为0" class="headerlink" title="将二进制最右侧为1的二进位改为0"></a>将二进制最右侧为1的二进位改为0</h3><p>如果我们想要将一个二进制数最右侧为1的二进制位X改为 0，则只需通过 X &amp; (X - 1) 的操作即可完成。</p><h3 id="计算二进制中二进位为1的个数"><a href="#计算二进制中二进位为1的个数" class="headerlink" title="计算二进制中二进位为1的个数"></a>计算二进制中二进位为1的个数</h3><p>通过 X &amp; (X - 1) 我们可以将二进制X最右侧为1的二进制位改为 0，那么如果我们不断通过 X &amp; (X - 1) 操作，最终将二进制X变为0，并统计执行次数，则可以得到二进制中二进位为1的个数。</p><h3 id="判断某数是否为2的幂次方"><a href="#判断某数是否为2的幂次方" class="headerlink" title="判断某数是否为2的幂次方"></a>判断某数是否为2的幂次方</h3><p>通过判断 X &amp; (X - 1) &#x3D;&#x3D; 0 是否成立，即可判断x<br>是否为2的幂次方。</p><p><img src="/2024/09/19/posts/0405%E4%BD%8D%E8%BF%90%E7%AE%97/image-1.png" alt="常用操作总结"></p><h2 id="颠倒二进制位"><a href="#颠倒二进制位" class="headerlink" title="颠倒二进制位"></a><a href="https://leetcode.cn/problems/reverse-bits/description/">颠倒二进制位</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)&#123;<br>            res = (res &lt;&lt; <span class="hljs-number">1</span>) | (n &amp; <span class="hljs-number">1</span>);<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(1)</li><li>空间复杂度：O(1)</li></ul><h2 id="位1的个数"><a href="#位1的个数" class="headerlink" title="位1的个数"></a><a href="https://leetcode.cn/problems/number-of-1-bits/description/">位1的个数</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>不断通过 X &amp; (X - 1) 操作，最终将二进制X变为0，并统计执行次数，则可以得到二进制中二进位为1的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n)&#123;<br>            n = n &amp; (n<span class="hljs-number">-1</span>);<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(\log n)$。</li><li>空间复杂度：O(1)</li></ul><h2 id="数字范围按位与"><a href="#数字范围按位与" class="headerlink" title="数字范围按位与"></a><a href="https://leetcode.cn/problems/bitwise-and-of-numbers-range/description/">数字范围按位与</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p><img src="/2024/09/19/posts/0405%E4%BD%8D%E8%BF%90%E7%AE%97/image-2.png" alt="按位与"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeBitwiseAnd</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            right = right &amp; (right<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><p><a href="https://github.com/datawhalechina/leetcode-notes/blob/main/docs/ch04/04.05/04.05.03-Exercises.md">https://github.com/datawhalechina/leetcode-notes/blob/main/docs/ch04/04.05/04.05.03-Exercises.md</a></p><h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a><a href="https://leetcode.cn/problems/single-number/description/">只出现一次的数字</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>两个相同的数字做异或运算，得到的是全0，所以只出现一次的数字最后会和全0异或，得到它本身。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            res ^= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="只出现一次的数字II"><a href="#只出现一次的数字II" class="headerlink" title="只出现一次的数字II"></a><a href="https://leetcode.cn/problems/single-number-ii/description/">只出现一次的数字II</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>将出现三次的元素换成二进制形式放在一起，其二进制对应位置上，出现 1的个数一定是3的倍数（包括0）。此时，如果在放进来只出现一次的元素，则某些二进制位置上出现1的个数就不是3的倍数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)&#123;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                cnt += (nums[j] &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cnt % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>)&#123;<br>                res = res | (<span class="hljs-number">1</span> &lt;&lt; i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogm)，本题中$logm &#x3D; log2^{32}$</li><li>空间复杂度：O(1)</li></ul><h2 id="只出现一次的数字III"><a href="#只出现一次的数字III" class="headerlink" title="只出现一次的数字III"></a><a href="https://leetcode.cn/problems/single-number-iii/">只出现一次的数字III</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><ol><li>求所有数字的异或值：如果数组中有两个数字只出现一次，其余每个元素均出现两次。那么经过全部异或运算。我们可以得到只出现一次的两个数字的异或结果。</li><li>找到最低的不同位。</li><li>根据最低不同位分组：<ul><li>根据 mask 的位置，将数组中的数字分为两组：一组在 mask 位置上为 0，另一组在 mask 位置上为 1。</li><li>因为相同的数字会被分到同一组且异或为0，最终每组剩下的数字就是 a 和 b。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 得到异或结果</span><br>        <span class="hljs-type">int</span> all = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            all ^= nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 找到最低位为1的位置，即最低位的两个数字不相同的位</span><br>        <span class="hljs-type">int</span> mask = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>((all &amp; mask) == <span class="hljs-number">0</span>)&#123;<br>            mask &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 分组</span><br>        <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>((mask &amp; nums[i]) == <span class="hljs-number">0</span>)&#123;<br>                a ^= nums[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                b ^= nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;a, b&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>注：运算符 &amp; 的优先级低于 &#x3D;&#x3D;。</p><h2 id="七进制数"><a href="#七进制数" class="headerlink" title="七进制数"></a><a href="https://leetcode.cn/problems/base-7/">七进制数</a></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convertToBase7</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        string res;<br>        <span class="hljs-type">int</span> quotient = <span class="hljs-built_in">abs</span>(num / <span class="hljs-number">7</span>);<br>        <span class="hljs-type">int</span> remainder = <span class="hljs-built_in">abs</span>(num % <span class="hljs-number">7</span>);<br>        <span class="hljs-keyword">while</span>(quotient)&#123;<br>            res += <span class="hljs-built_in">to_string</span>(remainder);<br>            remainder = quotient % <span class="hljs-number">7</span>;<br>            quotient /= <span class="hljs-number">7</span>;<br>        &#125;<br>        res += <span class="hljs-built_in">to_string</span>(remainder);<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> num &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;-&quot;</span> + res : res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(\log |n|)$。</li><li>空间复杂度：$O(\log |n|)$。</li></ul><h2 id="数字转换为十六进制数"><a href="#数字转换为十六进制数" class="headerlink" title="数字转换为十六进制数"></a><a href="https://leetcode.cn/problems/convert-a-number-to-hexadecimal/description/">数字转换为十六进制数</a></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><ul><li>当x为0，直接返回0.</li><li>当x&gt;0，不断做除以16取余的运算。</li><li>当x&lt;0，进行补码运算，即每一位取反+1（也相当于与全1异或再加1，1与1异或是0，0与1异或是1），再按照正数运算。</li><li>最后逆转字符串。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">toHex</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 使用无符号整数表示补码</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(num);<br>        <br>        <span class="hljs-comment">// 不断取余</span><br>        string res;<br>        <span class="hljs-type">int</span> remainder;<br>        <span class="hljs-keyword">while</span>(n) &#123;<br>            remainder = n % <span class="hljs-number">16</span>;<br>            n /= <span class="hljs-number">16</span>;<br>            <span class="hljs-keyword">if</span>(remainder &lt; <span class="hljs-number">10</span>)&#123;<br>                res += <span class="hljs-built_in">to_string</span>(remainder);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                res += <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(remainder - <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;a&#x27;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(k)，k是整数的十六进制数的位数。</li><li>空间复杂度：O(k)。</li></ul><blockquote><p>[!NOTE]<br><a href="https://blog.csdn.net/wangshubo1989/article/details/49105627">static_cast</a></p></blockquote><h2 id="十进制整数的反码"><a href="#十进制整数的反码" class="headerlink" title="十进制整数的反码"></a><a href="https://leetcode.cn/problems/complement-of-base-10-integer/description/">十进制整数的反码</a></h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>确定输入数字的二进制表示的有效位数,只对有效位数进行反码操作。</p><ul><li>找到 n 的二进制有效位数。</li><li>构造一个与 n 有相同位数且每一位都是 1 的掩码(mask)。</li><li>对 n 进行按位异或操作，得到不含前导 0 的反码。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitwiseComplement</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 特殊情况，0 的反码是 1</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 找到 n 的二进制表示的最高位</span><br>        <span class="hljs-type">int</span> mask = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> temp = n;<br>        <span class="hljs-keyword">while</span> (temp &gt; <span class="hljs-number">0</span>) &#123;<br>            mask = (mask &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>;<br>            temp &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 按位取反：使用 n 与 mask 进行按位异或</span><br>        <span class="hljs-keyword">return</span> n ^ mask;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(k)，k为有效二进制位数。</li><li>空间复杂度：O(1)</li></ul><h2 id="两整数之和"><a href="#两整数之和" class="headerlink" title="两整数之和"></a><a href="https://leetcode.cn/problems/sum-of-two-integers/description/">两整数之和</a></h2><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>使用异或运算，同时标记进位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(b)&#123;<br>            <span class="hljs-comment">// 计算进位</span><br>            <span class="hljs-type">int</span> carry = a &amp; b;<br>            <span class="hljs-comment">// 计算和</span><br>            a ^= b;<br>            <span class="hljs-comment">// 将进位移动到正确的位置</span><br>            b = carry &lt;&lt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(log(max_int))</li><li>空间复杂度：O(1)</li></ul><h2 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a><a href="https://leetcode.cn/problems/counting-bits/">比特位计数</a></h2><h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><p>直接位运算+暴力。题解中还有动态规划等等的方法，以后刷到动态规划再来看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">count</span>(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x)&#123;<br>            x = x &amp; (x<span class="hljs-number">-1</span>);<br>            cnt++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：O(1)</li></ul><h2 id="丢失的数字"><a href="#丢失的数字" class="headerlink" title="丢失的数字"></a><a href="https://leetcode.cn/problems/missing-number/description/">丢失的数字</a></h2><h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><p>考虑两个相同的数字异或，得到0。先得到数组中所有数字异或的结果，再与0~n异或，即把题目转换为只出现一次的数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            res ^= nums[i] ^ (i+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="格雷编码"><a href="#格雷编码" class="headerlink" title="格雷编码"></a><a href="https://leetcode.cn/problems/gray-code/description/">格雷编码</a></h2><h2 id="参加考试的最大学生数"><a href="#参加考试的最大学生数" class="headerlink" title="参加考试的最大学生数"></a><a href="https://leetcode.cn/problems/maximum-students-taking-exam/description/">参加考试的最大学生数</a></h2><h2 id="错误的集合"><a href="#错误的集合" class="headerlink" title="错误的集合"></a><a href="https://leetcode.cn/problems/set-mismatch/description/">错误的集合</a></h2><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a><a href="https://leetcode.cn/problems/subsets/">子集</a></h2><h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a><a href="https://leetcode.cn/problems/subsets-ii/">子集II</a></h2>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>贪心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0404贪心算法</title>
    <link href="/2024/09/16/posts/0404%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2024/09/16/posts/0404%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="04-04-贪心算法"><a href="#04-04-贪心算法" class="headerlink" title="04.04 贪心算法"></a>04.04 贪心算法</h1><p>贪心算法是一种改进的「分步解决算法」，其核心思想是：将求解过程分成「若干个步骤」，然后根据题意选择一种「度量标准」，每个步骤都应用「贪心原则」，选取当前状态下「最好 &#x2F; 最优选择（局部最优解）」，并以此希望最后得出的结果也是「最好 &#x2F; 最优结果（全局最优解）」。</p><p>换句话说，贪心算法不从整体最优上加以考虑，而是一步一步进行，每一步只以当前情况为基础，根据某个优化测度做出局部最优选择，从而省去了为找到最优解要穷举所有可能所必须耗费的大量时间。</p><ol><li>贪⼼选择性质：指的是一个问题的全局最优解可以通过一系列局部最优解（贪心选择）来得到。</li><li>最优子结构：指的是一个问题的最优解包含其子问题的最优解。</li></ol><h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a><a href="https://leetcode.cn/problems/assign-cookies/description/">分发饼干</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>为了尽可能的满⾜更多的⼩孩，而且一块饼干不能掰成两半，所以我们应该尽量让胃口小的孩子吃小块饼干，这样胃口大的孩子才有大块饼干吃。</p><p>所以，从贪心算法的角度来考虑，我们应该按照孩子的胃口从小到大对数组进行排序，然后按照饼干的尺寸大小从小到大对数组  进行排序，并且对于每个孩子，应该选择满足这个孩子的胃口且尺寸最小的饼干。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 先进行排序</span><br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">while</span>(i &lt; g.<span class="hljs-built_in">size</span>() &amp;&amp; j &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(g[i] &lt;= s[j])&#123;<br>                res++;<br>                i++;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：排序，O(mlogm + nlogn)</li><li>空间复杂度：O(logm + logn)，排序的额外空间开销。</li></ul><h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/description/">无重叠区间</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题我们可以转换一下思路。原题要求保证移除区间最少，使得剩下的区间互不重叠。换个角度就是：「如何使得剩下互不重叠区间的数目最多」。那么答案就变为了：「总区间个数 - 不重叠区间的最多个数」。我们的问题也变成了求所有区间中不重叠区间的最多个数。</p><p>从贪心算法的角度来考虑，我们应该将区间按照结束时间排序。每次选择结束时间最早的区间，然后再在剩下的时间内选出最多的区间。</p><p>将区间集合按照结束坐标升序排列，然后维护两个变量，一个是当前不重叠区间的结束时间,另一个是不重叠区间的个数。初始情况下，结束坐标为第一个区间的结束坐标。</p><p>依次遍历每段区间。对于每段区间：如果<code>end_pos &lt;= interval[i][0]</code>，说明不重叠，更新count和end_pos。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;<br>        <span class="hljs-comment">// 先对结束坐标按升序排序</span><br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; u, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; v)&#123;<br>            <span class="hljs-keyword">return</span> u[<span class="hljs-number">1</span>] &lt; v[<span class="hljs-number">1</span>];&#125;<br>            );<br>        <span class="hljs-type">int</span> endPos = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 遍历每个区间</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(endPos &lt;= intervals[i][<span class="hljs-number">0</span>])&#123;<br>                count++;<br>                endPos = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)</li></ul><h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a><a href="https://leetcode.cn/problems/lemonade-change/description/">柠檬水找零</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>用一个变量记录现有的零钱，然后遍历每个顾客所能支付的钱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bills)</span> </span>&#123;<br>        <span class="hljs-type">int</span> five = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ten = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bills.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">switch</span>(bills[i])&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <br>                    five++;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>                    <span class="hljs-keyword">if</span>(five &gt; <span class="hljs-number">0</span>)&#123;<br>                        ten++;<br>                        five--;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">20</span>:<br>                    <span class="hljs-keyword">if</span>(five &gt; <span class="hljs-number">0</span> &amp;&amp; ten &gt; <span class="hljs-number">0</span>)&#123;<br>                        five--;<br>                        ten--;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(five &gt;= <span class="hljs-number">3</span>)&#123;<br>                        five -= <span class="hljs-number">3</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><a href="https://leetcode.cn/problems/candy/description/">分发糖果</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>「评分更高的孩子必须比他两侧相邻位置上的孩子分得更多的糖果」：可以看做为以下两种条件：</p><ul><li>当<code>ratings[i] &gt; ratings[i-1]</code>时，第 i 个孩子的糖果数量比第i - 1个孩子的糖果数量多；</li><li>当<code>ratings[i] &gt; ratings[i+1]</code>时，第 i 个孩子的糖果数量比第i + 1个孩子的糖果数量多。</li></ul><p>然后分两次遍历数组计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = ratings.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 初始化全为1</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sweets</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 左规则</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i<span class="hljs-number">-1</span>])&#123;<br>                sweets[i] = sweets[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 右规则</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>])&#123;<br>                sweets[i] = <span class="hljs-built_in">max</span>(sweets[i], sweets[i+<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 和</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            sum += sweets[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/description/">跳跃游戏</a></h2><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p><img src="/2024/09/16/posts/0404%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image.png" alt="跳跃游戏"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(maxLen &gt;= i &amp;&amp; i + nums[i] &gt; maxLen)&#123;<br>                maxLen = i + nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><img src="/2024/09/16/posts/0404%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-1.png" alt="动态规划"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>] &gt;= i)&#123;<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>], i + nums[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                dp[i] = dp[i<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>] &gt;= n<span class="hljs-number">-1</span>; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a><a href="https://leetcode.cn/problems/jump-game-ii/description/">跳跃游戏II</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p><img src="/2024/09/16/posts/0404%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-2.png" alt="贪心算法"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxPos = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>(), end = <span class="hljs-number">0</span>, step = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(maxPos &gt;= i)&#123;<br>                maxPos = <span class="hljs-built_in">max</span>(maxPos, i + nums[i]);<br>                <span class="hljs-keyword">if</span>(i == end)&#123;<br>                    end = maxPos;<br>                    step++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> step;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="救生艇"><a href="#救生艇" class="headerlink" title="救生艇"></a><a href="https://leetcode.cn/problems/boats-to-save-people/description/">救生艇</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>利用贪心算法的思想，让最重的和最轻的人一起走。这样一只船就可以尽可能的带上两个人。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numRescueBoats</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; people, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = people.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 排序</span><br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> cur = people[left] + people[right];<br>            <span class="hljs-comment">// 超重，right上船，right左移</span><br>            <span class="hljs-keyword">if</span>(cur &gt; limit)&#123;<br>                res++;<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                res++;<br>                left++;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 最后一个人</span><br>        <span class="hljs-keyword">if</span>(left == right)&#123;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)</li></ul><h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/">用最少数量的箭引爆气球</a></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>将坐标按结束位置升序排序。对于第一个区间，假设弓箭射在其结束位置，往后依次遍历每个区间，如果弓箭的坐标小于区间的起始坐标，说明需要新的弓箭。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = points.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 排序</span><br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; u, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; v)&#123;<br>            <span class="hljs-keyword">return</span> u[<span class="hljs-number">1</span>] &lt; v[<span class="hljs-number">1</span>];<br>        &#125;);<br>        <span class="hljs-comment">// 弓箭位置</span><br>        <span class="hljs-type">int</span> arrow = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(arrow &lt; points[i][<span class="hljs-number">0</span>])&#123;<br>                res++;<br>                arrow = points[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)</li></ul><h2 id="卡车上的最大单元数"><a href="#卡车上的最大单元数" class="headerlink" title="卡车上的最大单元数"></a><a href="https://leetcode.cn/problems/maximum-units-on-a-truck/description/">卡车上的最大单元数</a></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>使用贪心算法，按每种箱子所能装单元数的降序排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumUnits</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; boxTypes, <span class="hljs-type">int</span> truckSize)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = boxTypes.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 排序</span><br>        <span class="hljs-built_in">sort</span>(boxTypes.<span class="hljs-built_in">begin</span>(), boxTypes.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; u, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; v)&#123;<br>            <span class="hljs-keyword">return</span> u[<span class="hljs-number">1</span>] &gt; v[<span class="hljs-number">1</span>];<br>        &#125;);<br>        <span class="hljs-type">int</span> capacity = truckSize;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历每种箱子</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-comment">// 达到最大容量</span><br>            <span class="hljs-keyword">if</span>(boxTypes[i][<span class="hljs-number">0</span>] &gt;= capacity)&#123;<br>                res += capacity * boxTypes[i][<span class="hljs-number">1</span>];<br>                capacity = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                res += boxTypes[i][<span class="hljs-number">0</span>] * boxTypes[i][<span class="hljs-number">1</span>];<br>                capacity -= boxTypes[i][<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)</li></ul><h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">合并区间</a></h2><h2 id="买股票的最佳时机"><a href="#买股票的最佳时机" class="headerlink" title="买股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买股票的最佳时机</a></h2><h2 id="数组拆分"><a href="#数组拆分" class="headerlink" title="数组拆分"></a><a href="https://leetcode.cn/problems/array-partition/submissions/">数组拆分</a></h2><h2 id="玩筹码"><a href="#玩筹码" class="headerlink" title="玩筹码"></a><a href="https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position/">玩筹码</a></h2><h2 id="交换字符使得字符串相同"><a href="#交换字符使得字符串相同" class="headerlink" title="交换字符使得字符串相同"></a><a href="https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal/description/">交换字符使得字符串相同</a></h2><h2 id="构造K个回文字符串"><a href="#构造K个回文字符串" class="headerlink" title="构造K个回文字符串"></a><a href="https://leetcode.cn/problems/construct-k-palindrome-strings/description/">构造K个回文字符串</a></h2><h2 id="使括号有效的最少添加"><a href="#使括号有效的最少添加" class="headerlink" title="使括号有效的最少添加"></a><a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/description/">使括号有效的最少添加</a></h2><h2 id="两地调度"><a href="#两地调度" class="headerlink" title="两地调度"></a><a href="https://leetcode.cn/problems/two-city-scheduling/">两地调度</a></h2><h2 id="给定行和列求可行矩阵"><a href="#给定行和列求可行矩阵" class="headerlink" title="给定行和列求可行矩阵"></a><a href="https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/description/">给定行和列求可行矩阵</a></h2><h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a><a href="https://leetcode.cn/problems/gas-station/">加油站</a></h2><h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a><a href="https://leetcode.cn/problems/wiggle-subsequence/">摆动序列</a></h2><h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a><a href="https://leetcode.cn/problems/monotone-increasing-digits/">单调递增的数字</a></h2><h2 id="移掉k位数字"><a href="#移掉k位数字" class="headerlink" title="移掉k位数字"></a><a href="https://leetcode.cn/problems/remove-k-digits/">移掉k位数字</a></h2><h2 id="翻转矩阵后的得分"><a href="#翻转矩阵后的得分" class="headerlink" title="翻转矩阵后的得分"></a><a href="https://leetcode.cn/problems/score-after-flipping-matrix/">翻转矩阵后的得分</a></h2><h2 id="最大交换"><a href="#最大交换" class="headerlink" title="最大交换"></a><a href="https://leetcode.cn/problems/score-after-flipping-matrix/">最大交换</a></h2>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>贪心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研二开学记</title>
    <link href="/2024/09/15/diaries/Diary20240915/"/>
    <url>/2024/09/15/diaries/Diary20240915/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="研二开学记"><a href="#研二开学记" class="headerlink" title="研二开学记"></a>研二开学记</h1><p>8月末去看了陈奕迅的演唱会，后来发现，不知道什么时候列的心愿清单，其实也都一个一个在实现，只是可能不是我原本计划的那样。有些事情真的就这样了，改变不了了，只能接受现实了。最近真的觉得，活着真没意思，活着真没意义，虽然很早之前就想明白了，活着的意义就是活着本身，但是自己心里其实还一直期待着，期待着自己是个特别的人。但是渐渐地渐渐地，我真真切切地感受到，自己真的是个普通人，没有什么上天的眷顾，之前我所庆幸的，只不过都是巧合。我不能一直活在对未来的幻想中，听到一句话会幻想，看到一个人会幻想，无时无刻的，都在幻想，我和白日梦想家的主角毫无差别。他是怎么停止幻想的？行动。不管做什么，总比没做要好吧。是的，再幻想的时候，马上停下来，停下来去做事，不管做什么事。</p><p><img src="/2024/09/15/diaries/Diary20240915/img_v3_02eo_87babafe-f515-49ee-9c02-63a23d3d38ag.jpg" alt="更新一下心愿清单"></p><p>但是人活着，总还是要有点期待的。所以我决定，列一个去诺坎普的计划，当我不想学习的时候，不能把时间浪费在刷视频上，要完善我的计划。钱差不多攒够了，但是还要把出行的每一步计划好。只是，好像没有人能跟我一起去o(╥﹏╥)o</p><p><img src="/2024/09/15/diaries/Diary20240915/image.png" alt="旅行计划"></p><p>好吧，去努力实现吧。</p>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0403回溯算法</title>
    <link href="/2024/09/10/posts/0403%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2024/09/10/posts/0403%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="04-03-回溯算法"><a href="#04-03-回溯算法" class="headerlink" title="04.03 回溯算法"></a>04.03 回溯算法</h1><p>一种能避免不必要搜索的穷举式的搜索算法。采用试错的思想，在搜索尝试过程中寻找问题的解，当探索到某一步时，发现原先的选择并不满足求解条件，或者还需要满足更多求解条件时，就退回一步（回溯）重新选择，这种走不通就退回再走的技术称为「回溯法」，而满足回溯条件的某个状态的点称为「回溯点」。</p><ol><li>明确所有选择：画出搜索过程的决策树，根据决策树来确定搜索路径。</li><li>明确终止条件：推敲出递归的终止条件，以及递归终止时的要执行的处理方法。</li><li>将决策树和终止条件翻译成代码：</li></ol><ul><li>定义回溯函数（明确函数意义、传入参数、返回结果等）。</li><li>书写回溯函数主体（给出约束条件、选择元素、递归搜索、撤销选择部分）。</li><li>明确递归终止条件（给出递归终止条件，以及递归终止时的处理方法）。</li></ul><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a><a href="https://leetcode.cn/problems/subsets/description/">子集</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li>明确所有选择：根据数组中每个位置上的元素选与不选两种选择，画出决策树。</li><li>明确终止条件：当遍历到决策树的叶子节点时，就终止了。即当前路径搜索到末尾时，递归终止。</li><li>将决策树和终止条件翻译成代码。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">helper</span>(nums, <span class="hljs-number">0</span>, path, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// 回溯法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> index, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(index == nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 不加入当前数字</span><br>        <span class="hljs-built_in">helper</span>(nums, index+<span class="hljs-number">1</span>, path, res);<br>        <span class="hljs-comment">// 加入当前数字</span><br>        path.<span class="hljs-built_in">push_back</span>(nums[index]);<br>        <span class="hljs-built_in">helper</span>(nums, index+<span class="hljs-number">1</span>, path, res);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>之前在<a href="https://csxuanyang.github.io/2024/06/06/LCR079/">LCR079</a>中做过这道题，当时分析的时间复杂度是$O(2^n)$，但是官方题解中给出的时间复杂度是$O(n \cdot{2^n})$，查了一下剑指offer书中的不够准确。每个递归分支都会生成一个子集，总共有$2^n$个子集，对于每个子集生成过程最多需要$O(n)$的时间。</p><ul><li>时间复杂度：$O(n \cdot 2^n)$</li><li>空间复杂度：leetcode官方题解中在分析空间复杂度时，一般不考虑返回的结果所占用的空间，但是chatgpt说需要考虑结果所占用的空间。<a href="https://www.programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201112%E5%9B%9E%E6%BA%AF%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html">代码随想录</a>给出的解释是<blockquote><p>$O(n)$，递归深度为n，所以系统栈所用空间为$O(n)$，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为$O(n)$。</p></blockquote></li></ul><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a><a href="https://leetcode.cn/problems/n-queens/description/">N皇后</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ol><li>明确所有选择：根据棋盘中当前行的所有列位置上是否选择放置皇后，画出决策树。</li><li>明确终止条件：当遍历到决策树的叶子节点时，就终止了。也就是在最后一行放置完皇后时，递归终止。</li><li>将决策树和终止条件翻译成代码：<br><img src="/2024/09/10/posts/0403%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image.png" alt="翻译代码"></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; res;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-comment">// 定义棋盘</span><br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">chessBoard</span><span class="hljs-params">(n, string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>        <span class="hljs-comment">// 回溯搜索</span><br>        <span class="hljs-built_in">backtrack</span>(chessBoard, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// row 是当前递归到棋盘的第几行</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;string&gt;&amp; chessBoard, <span class="hljs-type">int</span> row)</span></span>&#123;<br>        <span class="hljs-comment">// 搜索到叶子结点，结束</span><br>        <span class="hljs-keyword">if</span>(row == chessBoard.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(chessBoard);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 逐列放置皇后</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; chessBoard.<span class="hljs-built_in">size</span>(); col++)&#123;<br>            <span class="hljs-comment">// 验证合法，放置皇后</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(chessBoard, row, col))&#123;<br>                chessBoard[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                <span class="hljs-built_in">backtrack</span>(chessBoard, row + <span class="hljs-number">1</span>);<br>                chessBoard[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;string&gt;&amp; chessBoard, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span></span>&#123;<br>        <span class="hljs-comment">// 判断这一列的每一行是否有皇后</span><br>        <span class="hljs-type">int</span> n = chessBoard.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)&#123;<br>            <span class="hljs-keyword">if</span>(chessBoard[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 判断45度角方向</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = row<span class="hljs-number">-1</span>, j = col<span class="hljs-number">-1</span>; i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--)&#123;<br>            <span class="hljs-keyword">if</span>(chessBoard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 判断135度角方向</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = row<span class="hljs-number">-1</span>, j = col+<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++)&#123;<br>            <span class="hljs-keyword">if</span>(chessBoard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>时间复杂度：O(n!)，第一个皇后有 n 列可以选择，第二个皇后最多有 n−1 列可以选择，第三个皇后最多有 n−2 列可以选择（如果考虑到不能在同一条斜线上，可能的选择数量更少），因此所有可能的情况不会超过 n! 种。</p></li><li><p>空间复杂度：O(n)</p></li></ul><p>剩下的练习题目应该是在剑指offer里做过的，但是有点忘记了，再重新做一遍。</p><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a><a href="https://leetcode.cn/problems/permutations/description/">全排列</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ol><li>明确所有选择：全排列中每个位置上的元素都可以从剩余可选元素中选出，对此画出决策树。<br><img src="/2024/09/10/posts/0403%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-1.png" alt="全排列决策树"></li><li>明确终止条件：当遍历到决策树的叶子节点时，就终止了。即当前路径搜索到末尾时，递归终止。</li><li>将决策树和终止条件翻译成代码。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">helper</span>(nums, <span class="hljs-number">0</span>, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> index, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 搜索结束</span><br>        <span class="hljs-keyword">if</span>(index == nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(nums);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-built_in">swap</span>(nums[i], nums[index]);<br>            <span class="hljs-built_in">helper</span>(nums, index+<span class="hljs-number">1</span>, res);<br>            <span class="hljs-built_in">swap</span>(nums[i], nums[index]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n!)</li><li>空间复杂度：O(n)</li></ul><h2 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a><a href="https://leetcode.cn/problems/permutations-ii/description/">全排列II</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>和上一题的区别是，nums中可能包含重复的元素，但返回得结果不能有两个一样的排列。用unordered_set保存已经访问过的数字，后面如果再遇到，可以直接不处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">helper</span>(nums, <span class="hljs-number">0</span>, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> index, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(index == nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(nums);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 定义一个集合用于存放当前位置已经使用过的元素</span><br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">find</span>(nums[i]) == set.<span class="hljs-built_in">end</span>())&#123;<br>                set.<span class="hljs-built_in">insert</span>(nums[i]);<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[index]);<br>                <span class="hljs-built_in">helper</span>(nums, index+<span class="hljs-number">1</span>, res);<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[index]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n!)</li><li>空间复杂度：O(n)</li></ul><p>这两道题的复杂度分析和之前做的又不一样。各个资料的分析都不太一样，但是都有一定的道理……以后再回来看看。</p><h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/description/">括号生成</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><ol><li>明确所有选择：$2 \times n$ 的括号组合中的每个位置，都可以从 ( 或者 ) 中选出。并且，只有在 symbol &lt; n 的时候，才能选择 (，在 symbol &gt; 0 的时候，才能选择 )。</li><li>明确终止条件：当遍历到决策树的叶子节点时，就终止了。即当前路径搜索到末尾时，递归终止。</li><li>传入参数：左括号剩余数，右括号剩余数，当前字符串，结果。递归结束条件：左括号右括号剩余数等于0。条件选择：left&gt;0选择左括号；left &lt; right选择右括号，因为当left&#x3D;&#x3D;right时，不能再选择右括号。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        string s;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-built_in">helper</span>(n, n, s, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, string s, vector&lt;string&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 选择左括号</span><br>        <span class="hljs-keyword">if</span>(left &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">helper</span>(left<span class="hljs-number">-1</span>, right, s + <span class="hljs-string">&quot;(&quot;</span>, res);<br>        &#125;<br>        <span class="hljs-comment">// 选择右括号</span><br>        <span class="hljs-keyword">if</span>(left &lt; right)&#123;<br>            <span class="hljs-built_in">helper</span>(left, right<span class="hljs-number">-1</span>, s + <span class="hljs-string">&quot;)&quot;</span>, res);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$\frac{4^n}{\sqrt{n}}$</li><li>空间复杂度：O(n)</li></ul><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">电话号码的字母组合</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>用哈希表保存每个数字键位对应的所有可能的字母，然后进行回溯操作。</p><p>回溯过程中，维护一个字符串 combination，表示当前的字母排列组合。初始字符串为空，每次取电话号码的一位数字，从哈希表中取出该数字所对应的所有字母，并将其中一个插入到 combination 后面，然后继续处理下一个数字，知道处理完所有数字，得到一个完整的字母排列。开始进行回退操作，遍历其余的字母排列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">char</span>, string&gt; hash = &#123;&#123;<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&quot;def&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;&#125;;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">length</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        string combination;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-built_in">backtrack</span>(digits, <span class="hljs-number">0</span>, combination, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(string digits, <span class="hljs-type">int</span> index, string&amp; combination, vector&lt;string&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(index == digits.<span class="hljs-built_in">length</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(combination);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 对于每一个字符</span><br>        <span class="hljs-type">char</span> digit = digits[index];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; hash[digit].<span class="hljs-built_in">length</span>(); i++)&#123;<br>            <span class="hljs-type">char</span> add = hash[digit][i];<br>            combination += add;<br>            <span class="hljs-built_in">backtrack</span>(digits, index+<span class="hljs-number">1</span>, combination, res);<br>            combination = combination.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, combination.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>时间复杂度：$O(3^m \times 4^n)$，其中 m 是输入中对应 3 个字母的数字个数（包括数字 2、3、4、5、6、8），n 是输入中对应 4 个字母的数字个数（包括数字 7、9），m+n 是输入数字的总个数。当输入包含 m 个对应 3 个字母的数字和 n 个对应 4 个字母的数字时，需要遍历每一种字母组合。</p></li><li><p>空间复杂度：O(m+n)</p></li></ul><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/description/">组合总和</a></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>递归结束条件：当前和等于target。</p><p>递归选择条件：选择当前元素&#x2F;不选择当前元素。前提是选择后和不能大于target。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">backtrack</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, path, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> sum, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index == candidates.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 选择当前元素</span><br>        <span class="hljs-keyword">if</span>(sum + candidates[index] &lt;= target)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(candidates[index]);<br>            <span class="hljs-built_in">backtrack</span>(candidates, target, index, sum + candidates[index], path, res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-comment">// 不选择当前元素</span><br>        <span class="hljs-built_in">backtrack</span>(candidates, target, index+<span class="hljs-number">1</span>, sum, path, res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(2^n \times n)$</li><li>空间复杂度：$O(target)$，递归函数需要用到栈空间，栈空间取决于递归深度。</li></ul><h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">组合总和II</a></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>为了方便跳过后面所有值相同的数字，可以将集合中的所有数字排序，把相同的数字放在一起，这样方便比较数字。当决定跳过某个值的数字时，可以按顺序扫描后面的数字，直到找到不同的值为止。当决定跳过数字nums[i]时可以调用函数getNext找到与该数字不同的下一个数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 先进行排序</span><br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">backtrack</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, path, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> sum, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index == candidates.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 不选择当前元素</span><br>        <span class="hljs-built_in">backtrack</span>(candidates, target, <span class="hljs-built_in">getNext</span>(candidates, index), sum, path, res);<br>        <span class="hljs-comment">// 选择当前元素</span><br>        <span class="hljs-keyword">if</span>(sum + candidates[index] &lt;= target)&#123;<br>            path.<span class="hljs-built_in">push_back</span>(candidates[index]);<br>            <span class="hljs-built_in">backtrack</span>(candidates, target, index+<span class="hljs-number">1</span>, sum+candidates[index], path, res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-comment">// 获取下一个索引</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNext</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> index)</span></span>&#123;<br>        <span class="hljs-type">int</span> next = index + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(next &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; candidates[next] == candidates[index])&#123;<br>            next++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times 2 ^ n)$</li><li>空间复杂度：$O(n)$</li></ul><h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a><a href="https://leetcode.cn/problems/subsets-ii/description/">子集II</a></h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>其中可能包含重复元素，可以考虑先进行排序，然后跳过该位置上相同的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">// 对数组进行排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>, path, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> index, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(index == nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 不选择当前元素</span><br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-built_in">getNext</span>(nums, index), path, res);<br>        <span class="hljs-comment">// 选择当前元素</span><br>        path.<span class="hljs-built_in">push_back</span>(nums[index]);<br>        <span class="hljs-built_in">backtrack</span>(nums, index + <span class="hljs-number">1</span>, path, res);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNext</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> index)</span></span>&#123;<br>        <span class="hljs-type">int</span> next = index + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(next &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[next] == nums[index])&#123;<br>            next++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times 2 ^ n)$</li><li>空间复杂度：O(n)</li></ul><h2 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a><a href="https://leetcode.cn/problems/word-search/description/">单词搜索</a></h2><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>设函数<code>backtrack(i, j, index)</code>表示从<code>board[i][j]</code>出发，能否搜索到字母<code>word[index]</code>，及其后续的子串。</p><p>三种情况：</p><ul><li><code>board[i][j] == word[index] &amp;&amp; index == word.length()-1</code>，递归结束，返回true。</li><li><code>board[i][j] == word[index] &amp;&amp; index &lt; word.length()-1</code>，向每个方向递归搜索，如果有返回true的，返回true，否则返回false。</li><li><code>board[i][j] != word[index]</code>，返回false。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = board.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtrack</span>(board, word, i, j, <span class="hljs-number">0</span>, visited)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string&amp; word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> index, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited)</span> </span>&#123;<br>        <span class="hljs-comment">// 检查是否找到了整个单词</span><br>        <span class="hljs-keyword">if</span> (index == word.<span class="hljs-built_in">length</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 检查边界条件和当前字符是否匹配</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= board.<span class="hljs-built_in">size</span>() || j &lt; <span class="hljs-number">0</span> || j &gt;= board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || <br>            visited[i][j] || board[i][j] != word[index]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 标记当前位置为已访问</span><br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 向四个方向搜索</span><br>        <span class="hljs-type">bool</span> result = <span class="hljs-built_in">backtrack</span>(board, word, i+<span class="hljs-number">1</span>, j, index+<span class="hljs-number">1</span>, visited) ||<br>                      <span class="hljs-built_in">backtrack</span>(board, word, i<span class="hljs-number">-1</span>, j, index+<span class="hljs-number">1</span>, visited) ||<br>                      <span class="hljs-built_in">backtrack</span>(board, word, i, j+<span class="hljs-number">1</span>, index+<span class="hljs-number">1</span>, visited) ||<br>                      <span class="hljs-built_in">backtrack</span>(board, word, i, j<span class="hljs-number">-1</span>, index+<span class="hljs-number">1</span>, visited);<br>        <br>        <span class="hljs-comment">// 回溯，将当前位置标记为未访问</span><br>        visited[i][j] = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：最坏情况下，我们需要遍历整个板子的每个位置作为起点。对于每个起点，我们可能需要探索所有可能的路径。假设板子的大小为 m × n，单词长度为 k。对于每个起点，在最坏情况下，我们可能需要探索 4^k 条路径（因为每一步有4个方向可以选择，总共k步）。因此，总的时间复杂度为$O(m n 4^k)$。</li><li>空间复杂度：我们使用了一个 visited 数组，大小与板子相同，即 O(m n)。递归调用栈的深度最大为单词的长度 k。因此，总的空间复杂度为 O(mn + k)。</li></ul><p>虽然理论上的最坏时间复杂度是 O(m n 4^k)，但在实际情况中，由于我们有提前终止的条件（如字符不匹配就返回），实际运行时间通常会好很多。</p><p>这个问题是NP完全问题，没有已知的多项式时间解法。当输入规模变大时，最坏情况下的时间复杂度会急剧增加。</p><p>在实际应用中，可以考虑一些优化策略，比如先检查板子中是否包含单词中的所有字符，如果不包含，可以直接返回false，避免不必要的搜索。</p><h2 id="解数读"><a href="#解数读" class="headerlink" title="解数读"></a><a href="https://leetcode.cn/problems/sudoku-solver/description/">解数读</a></h2><h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><p>对于每一行、每一列、每一个数字，都需要一重 for 循环来遍历，这样就是三重 for 循环。</p><p>对于第i行、第j列的元素来说，如果当前位置为空位，则尝试将第k个数字置于此处，并检验数独的有效性。如果有效，则继续遍历下一个空位，直到遍历完所有空位，得到可行方案或者遍历失败时结束。</p><p>遍历完下一个空位之后再将此位置进行回退，置为<code>.</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">backtrack</span>(board);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;board.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 尝试放置数字</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">9</span>; k++)&#123;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(board, i, j, k))&#123;<br>                        board[i][j] = k + <span class="hljs-string">&#x27;0&#x27;</span>;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtrack</span>(board))&#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        &#125;<br>                        board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 这个位置没有可以放置的数字，可以直接返回false</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-comment">// 检查行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; board.<span class="hljs-built_in">size</span>(); col++)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][col]-<span class="hljs-string">&#x27;0&#x27;</span> == k)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 检查列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> row = <span class="hljs-number">0</span>; row &lt; board.<span class="hljs-built_in">size</span>(); row++)&#123;<br>            <span class="hljs-keyword">if</span>(board[row][j]-<span class="hljs-string">&#x27;0&#x27;</span> == k)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 检查九宫格</span><br>        <span class="hljs-type">int</span> r = i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> c = j / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> row = r; row &lt; r + <span class="hljs-number">3</span>; row++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> col = c; col &lt; c + <span class="hljs-number">3</span>; col++)&#123;<br>                <span class="hljs-keyword">if</span>(board[row][col]-<span class="hljs-string">&#x27;0&#x27;</span> == k)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(9^m)$，$m$ 为棋盘中<code>.</code>的数量。</li><li>空间复杂度：$O(9^2)$</li></ul><h2 id="字母大小写全排列"><a href="#字母大小写全排列" class="headerlink" title="字母大小写全排列"></a><a href="https://leetcode.cn/problems/letter-case-permutation/description/">字母大小写全排列</a></h2><h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><ul><li>递归结束条件：当前索引已到达最后一个字符。</li><li>选择条件：每个字母要么翻转，要么不翻转。</li><li>补充ASCII码值：<ul><li>数字0~9：48 ~ 57</li><li>大写A~Z：65 ~ 90</li><li>小写a~z：97 ~ 122</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCasePermutation</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string cur = s;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-built_in">backtrack</span>(<span class="hljs-number">0</span>, cur, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> index, string&amp; cur, vector&lt;string&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(index == cur.<span class="hljs-built_in">length</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(cur);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> type = <span class="hljs-built_in">checkType</span>(cur[index]);<br>        <span class="hljs-comment">// 不翻转当前字符</span><br>        <span class="hljs-built_in">backtrack</span>(index+<span class="hljs-number">1</span>, cur, res);<br>        <span class="hljs-comment">// 翻转当前字符</span><br>        <span class="hljs-comment">// 大写变小写</span><br>        <span class="hljs-keyword">if</span>(type == <span class="hljs-number">1</span>)&#123;<br>            cur[index] += <span class="hljs-number">32</span>;<br>            <span class="hljs-built_in">backtrack</span>(index+<span class="hljs-number">1</span>, cur, res);<br>            cur[index] -= <span class="hljs-number">32</span>;<br>        &#125;<br>        <span class="hljs-comment">// 小写变大写</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type == <span class="hljs-number">2</span>)&#123;<br>            cur[index] -= <span class="hljs-number">32</span>;<br>            <span class="hljs-built_in">backtrack</span>(index+<span class="hljs-number">1</span>, cur, res);<br>            cur[index] += <span class="hljs-number">32</span>;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">checkType</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(ch &gt;= <span class="hljs-number">48</span> &amp;&amp; ch &lt;= <span class="hljs-number">57</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ch &gt;= <span class="hljs-number">65</span> &amp;&amp; ch &lt;= <span class="hljs-number">90</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \times 2 ^ n)$</li><li>空间复杂度：$O(n \times 2 ^ n)$</li></ul><h2 id="火柴拼正方形"><a href="#火柴拼正方形" class="headerlink" title="火柴拼正方形"></a><a href="https://leetcode.cn/problems/matchsticks-to-square/description/">火柴拼正方形</a></h2><h2 id="拆分字符串使唯一字符串的数目最大"><a href="#拆分字符串使唯一字符串的数目最大" class="headerlink" title="拆分字符串使唯一字符串的数目最大"></a><a href="https://leetcode.cn/problems/split-a-string-into-the-max-number-of-unique-substrings/description/">拆分字符串使唯一字符串的数目最大</a></h2><h2 id="活字印刷"><a href="#活字印刷" class="headerlink" title="活字印刷"></a><a href="https://leetcode.cn/problems/letter-tile-possibilities/description/">活字印刷</a></h2><h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/description/">复原IP地址</a></h2><h2 id="24点游戏"><a href="#24点游戏" class="headerlink" title="24点游戏"></a><a href="https://leetcode.cn/problems/24-game/solutions/">24点游戏</a></h2><p>上面的题以后慢慢刷……</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><a href="https://zhuanlan.zhihu.com/p/97619085">卡特兰数</a></p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>回溯法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0402分治算法</title>
    <link href="/2024/09/03/posts/0402%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    <url>/2024/09/03/posts/0402%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="04-02-05-分治算法"><a href="#04-02-05-分治算法" class="headerlink" title="04.02.05 分治算法"></a>04.02.05 分治算法</h1><p>把规模大的问题不断分解为子问题，使得问题规模减小到可以直接求解为止。分治算法从实现方式上来划分，可以分为两种：「递归算法」和「迭代算法」。</p><p>使用分治算法解决问题主要分为3个步骤：</p><ol><li>分解：把要解决的问题分解为成若干个规模较小、相对独立、与原问题形式相同的子问题。</li><li>求解：递归求解各个子问题。</li><li>合并：按照原问题的要求，将子问题的解逐层合并构成原问题的解。</li></ol><h2 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a><a href="https://leetcode.cn/problems/sort-an-array/description/">排序数组</a></h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; tmp; <span class="hljs-comment">// 声明为类成员，用于合并时临时存储</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left &gt;= right)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-built_in">mergeSort</span>(nums, left, mid); <span class="hljs-comment">// 修正递归调用</span><br>        <span class="hljs-built_in">mergeSort</span>(nums, mid+<span class="hljs-number">1</span>, right);<br>        <br>        <span class="hljs-comment">// 清空临时数组</span><br>        tmp.<span class="hljs-built_in">clear</span>();<br>        <br>        <span class="hljs-comment">// 合并两个有序数组</span><br>        <span class="hljs-type">int</span> i = left;<br>        <span class="hljs-type">int</span> j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt;= nums[j])&#123;<br>                tmp.<span class="hljs-built_in">push_back</span>(nums[i++]);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                tmp.<span class="hljs-built_in">push_back</span>(nums[j++]);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span>(i &lt;= mid)&#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(nums[i++]);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j &lt;= right)&#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(nums[j++]);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 将排序好的结果复制回原数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = left, t = <span class="hljs-number">0</span>; k &lt;= right; ++k, ++t)&#123;<br>            nums[k] = tmp[t];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        tmp.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">// 预分配临时数组空间</span><br>        <span class="hljs-built_in">mergeSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(n)</li></ul><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><a href="https://leetcode.cn/problems/binary-search/description/">二分查找</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><a href="https://leetcode.cn/problems/majority-element/description/">多数元素</a></h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>先遍历一遍数组，放入哈希表中，再遍历哈希表，找到多数元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            hash[nums[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; kv : hash)&#123;<br>            <span class="hljs-keyword">if</span>(kv.second &gt; n / <span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">return</span> kv.first;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：哈希表，O(n)</li></ul><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>如果 num 是数组 nums 的众数，那么我们将 nums 分为两部分，则 num 至少是其中一部分的众数。则我们可以用分治法来解决这个问题。具体步骤如下：</p><ol><li>将数组 nums 递归地将当前序列平均分成左右两个数组，直到所有子数组长度为 1。</li><li>长度为1的子数组众数肯定是数组中唯一的数，将其返回即可。</li><li>将两个子数组依次向上两两合并。<ul><li>如果两个子数组的众数相同，则说明合并后的数组众数为：两个子数组的众数。</li><li>如果两个子数组的众数不同，则需要比较两个众数在整个区间的众数。</li></ul></li><li>最后返回整个数组的众数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count_in_range</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = low; i &lt;= high; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == target)&#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majority_element_rec</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(low == high)&#123;<br>            <span class="hljs-keyword">return</span> nums[low];<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">majority_element_rec</span>(nums, low, mid);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">majority_element_rec</span>(nums, mid+<span class="hljs-number">1</span>, high);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">count_in_range</span>(nums, left, low, high) &gt; (high-low+<span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">count_in_range</span>(nums, right, low, high) &gt; (high-low+<span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125;        <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">majority_element_rec</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(logn)</li></ul><h3 id="投票算法"><a href="#投票算法" class="headerlink" title="投票算法"></a>投票算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> candidate = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num == candidate)<br>                ++count;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (--count &lt; <span class="hljs-number">0</span>) &#123;<br>                candidate = num;<br>                count = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/description/">最大子数组和</a></h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            pre = <span class="hljs-built_in">max</span>(pre + nums[i], nums[i]);<br>            res = <span class="hljs-built_in">max</span>(res, pre);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="分治法-1"><a href="#分治法-1" class="headerlink" title="分治法"></a>分治法</h3><p>维护四个变量：</p><ul><li>lSum：以l为左端点的最大子段和，lSum要么等于左子区间的lSum，要么等于左子区间的iSum+右子区间的lSum，取较大值。</li><li>rSum：以r为右端点的最大子段和，rSum要么等于右子区间的rSum，要么等于右子区间的iSum+左子区间的rSum，取较大值。</li><li>mSum：[l, r]区间的最大子段和：mSum可能是左子区间的mSum，也可能是右子区间的mSum，也可能跨越左右子区间，即左子区间的rSum+右子区间的lSum。</li><li>iSum：[l, r]整个区间和，等于左子区间的iSum+右子区间的iSum。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 维护四个状态</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Status</span>&#123;<br>        <span class="hljs-type">int</span> lSum, rSum, mSum, iSum;<br>    &#125;;<br>    <span class="hljs-comment">// 线段树的pushup操作</span><br>    <span class="hljs-function">Status <span class="hljs-title">pushUp</span><span class="hljs-params">(Status left, Status right)</span></span>&#123;<br>        <span class="hljs-type">int</span> iSum = left.iSum + right.iSum;<br>        <span class="hljs-type">int</span> lSum = <span class="hljs-built_in">max</span>(left.lSum, left.iSum + right.lSum);<br>        <span class="hljs-type">int</span> rSum = <span class="hljs-built_in">max</span>(right.rSum, right.iSum + left.rSum);<br>        <span class="hljs-type">int</span> mSum = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(left.mSum, right.mSum), left.rSum + right.lSum);<br>        <span class="hljs-keyword">return</span> (Status)&#123;lSum, rSum, mSum, iSum&#125;;<br>    &#125;<br>    <span class="hljs-comment">// 获取子区间的和</span><br>    <span class="hljs-function">Status <span class="hljs-title">get</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left == right)&#123;<br>            <span class="hljs-keyword">return</span> (Status)&#123;nums[left], nums[left], nums[left], nums[left]&#125;;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        Status lSub = <span class="hljs-built_in">get</span>(nums, left, mid);<br>        Status rSub = <span class="hljs-built_in">get</span>(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pushUp</span>(lSub, rSub);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>).mSum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(logn)</li></ul><h2 id="漂亮数组"><a href="#漂亮数组" class="headerlink" title="漂亮数组"></a><a href="https://leetcode.cn/problems/beautiful-array/description/">漂亮数组</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="/2024/09/03/posts/0402%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/image.png" alt="漂亮数组分析"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">beautifulArray</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>&#125;;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            nums[i] = i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> leftCnt = (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> rightCnt = n - leftCnt;<br>        vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">beautifulArray</span>(leftCnt);<br>        vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">beautifulArray</span>(rightCnt);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; leftCnt; i++)&#123;<br>            nums[i] = <span class="hljs-number">2</span> * left[i] - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rightCnt; i++)&#123;<br>            nums[leftCnt+i] = <span class="hljs-number">2</span> * right[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(nlogn)</li></ul><h2 id="为运算表达式设计优先级"><a href="#为运算表达式设计优先级" class="headerlink" title="为运算表达式设计优先级"></a><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/description/">为运算表达式设计优先级</a></h2><h3 id="分治法-2"><a href="#分治法-2" class="headerlink" title="分治法"></a>分治法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">diffWaysToCompute</span><span class="hljs-params">(string expression)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <br>        <span class="hljs-comment">// 遍历表达式查找操作符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; expression.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-type">char</span> ch = expression[i];<br>            <span class="hljs-comment">// 如果当前字符是操作符，则将表达式划分为左右两部分</span><br>            <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;+&#x27;</span> || ch == <span class="hljs-string">&#x27;-&#x27;</span> || ch == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 递归求解左右子表达式</span><br>                vector&lt;<span class="hljs-type">int</span>&gt; leftRes = <span class="hljs-built_in">diffWaysToCompute</span>(expression.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i));<br>                vector&lt;<span class="hljs-type">int</span>&gt; rightRes = <span class="hljs-built_in">diffWaysToCompute</span>(expression.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">1</span>));<br>                <br>                <span class="hljs-comment">// 对每个左右结果进行计算</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> left : leftRes) &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right : rightRes) &#123;<br>                        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                            res.<span class="hljs-built_in">push_back</span>(left + right);<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                            res.<span class="hljs-built_in">push_back</span>(left - right);<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                            res.<span class="hljs-built_in">push_back</span>(left * right);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果 res 为空，说明没有找到任何操作符，整个表达式是一个数字</span><br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">empty</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">stoi</span>(expression));  <span class="hljs-comment">// 将整个表达式转换为整数</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(2^n)$</li><li>空间复杂度：$O(2^n)$</li></ul><h2 id="合并k个升序链表"><a href="#合并k个升序链表" class="headerlink" title="合并k个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">合并k个升序链表</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>如果只剩一个链表，就结束。然后合并两个链表，按照归并排序的方式合并。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 归并排序</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(left == right)&#123;<br>            <span class="hljs-keyword">return</span> lists[left];<br>        &#125;<br>        <span class="hljs-comment">// 一分为二</span><br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        ListNode* leftList = <span class="hljs-built_in">mergeSort</span>(lists, left, mid);<br>        ListNode* rightList = <span class="hljs-built_in">mergeSort</span>(lists, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-comment">// 合并</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(leftList, rightList);<br>    &#125;<br>    <span class="hljs-comment">// 合并两个链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* leftList, ListNode* rightList)</span></span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* cur = dummy;<br>        <span class="hljs-keyword">while</span>(leftList &amp;&amp; rightList)&#123;<br>            <span class="hljs-keyword">if</span>(leftList-&gt;val &lt;= rightList-&gt;val)&#123;<br>                cur-&gt;next = leftList;<br>                leftList = leftList-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cur-&gt;next = rightList;<br>                rightList = rightList-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(leftList)&#123;<br>            cur-&gt;next = leftList;<br>            leftList = leftList-&gt;next;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(rightList)&#123;<br>            cur-&gt;next = rightList;<br>            rightList = rightList-&gt;next;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(lists.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeSort</span>(lists, <span class="hljs-number">0</span>, lists.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(knlogk)$</li><li>空间复杂度：$O(logk)$</li></ul><h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/">寻找两个正序数组的中位数</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>先用归并排序合并两个数组，然后返回中间索引的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span></span>&#123;<br>        <span class="hljs-type">int</span> m = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(m + n)</span></span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)&#123;<br>            <span class="hljs-keyword">if</span>(nums1[i] &lt;= nums2[j])&#123;<br>                res[k++] = nums1[i++];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                res[k++] = nums2[j++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i &lt; m)&#123;<br>            res[k++] = nums1[i++];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j &lt; n)&#123;<br>            res[k++] = nums2[j++];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-comment">// 合并两个数组</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; nums = <span class="hljs-built_in">mergeSort</span>(nums1, nums2);<br>        <span class="hljs-comment">// 求中位数</span><br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len % <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[len / <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">return</span> (nums[len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] + nums[len / <span class="hljs-number">2</span>]) / <span class="hljs-number">2.0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(m+n)</li></ul><h3 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a>二分算法</h3><p>有点迷糊，之后再看看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-comment">// 设nums1为较短的数组</span><br>        <span class="hljs-type">int</span> n1 = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n2 = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n1 &gt; n2) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">findMedianSortedArrays</span>(nums2, nums1);<br>        &#125;<br><br>        <span class="hljs-type">int</span> k = (n1 + n2 + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = n1;<br>        <br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;  <span class="hljs-comment">// 修改终止条件</span><br>            <span class="hljs-type">int</span> m1 = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> m2 = k - m1;<br><br>            <span class="hljs-comment">// 检查 m1 和 m2 的边界，确保不会越界</span><br>            <span class="hljs-keyword">if</span> (m1 &lt; n1 &amp;&amp; m2 &gt; <span class="hljs-number">0</span> &amp;&amp; nums1[m1] &lt; nums2[m2 - <span class="hljs-number">1</span>]) &#123;<br>                left = m1 + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m1 &gt; <span class="hljs-number">0</span> &amp;&amp; m2 &lt; n2 &amp;&amp; nums1[m1 - <span class="hljs-number">1</span>] &gt; nums2[m2]) &#123;<br>                right = m1 - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 满足条件，划分完成</span><br>                <span class="hljs-type">int</span> c1;<br>                <span class="hljs-keyword">if</span> (m1 == <span class="hljs-number">0</span>) &#123;<br>                    c1 = nums2[m2 - <span class="hljs-number">1</span>];  <span class="hljs-comment">// nums1 全部被划分到右侧</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m2 == <span class="hljs-number">0</span>) &#123;<br>                    c1 = nums1[m1 - <span class="hljs-number">1</span>];  <span class="hljs-comment">// nums2 全部被划分到右侧</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    c1 = <span class="hljs-built_in">max</span>(nums1[m1 - <span class="hljs-number">1</span>], nums2[m2 - <span class="hljs-number">1</span>]);  <span class="hljs-comment">// 左侧最大值</span><br>                &#125;<br><br>                <span class="hljs-comment">// 如果总数为奇数，直接返回</span><br>                <span class="hljs-keyword">if</span> ((n1 + n2) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> c1;<br>                &#125;<br><br>                <span class="hljs-comment">// 否则，计算右半部分的最小值</span><br>                <span class="hljs-type">int</span> c2;<br>                <span class="hljs-keyword">if</span> (m1 == n1) &#123;<br>                    c2 = nums2[m2];  <span class="hljs-comment">// nums1 全部被划分到左侧</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m2 == n2) &#123;<br>                    c2 = nums1[m1];  <span class="hljs-comment">// nums2 全部被划分到左侧</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    c2 = <span class="hljs-built_in">min</span>(nums1[m1], nums2[m2]);  <span class="hljs-comment">// 右侧最小值</span><br>                &#125;<br><br>                <span class="hljs-comment">// 返回中位数</span><br>                <span class="hljs-keyword">return</span> (c1 + c2) / <span class="hljs-number">2.0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;  <span class="hljs-comment">// 理论上不会到达此处</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(log min(m,n))</li><li>空间复杂度：0(1)</li></ul><h2 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a><a href="https://leetcode.cn/problems/longest-common-prefix/description/">最长公共前缀</a></h2><h3 id="纵向遍历"><a href="#纵向遍历" class="headerlink" title="纵向遍历"></a>纵向遍历</h3><p>纵向遍历，从第一个字符开始，比较每一个字符串的第一个字符是否相等。若相等，则比较第二个字符，若不相等，则结束循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; strs[<span class="hljs-number">0</span>].<span class="hljs-built_in">length</span>(); i++)&#123;<br>            <span class="hljs-type">char</span> ch = strs[<span class="hljs-number">0</span>][i];<br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; strs.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-keyword">if</span>((i &lt; strs[j].<span class="hljs-built_in">length</span>() &amp;&amp; strs[j][i] != ch) || i &gt;= strs[j].<span class="hljs-built_in">length</span>())&#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;   <br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                res += ch;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(1)</li></ul><h2 id="验证二叉搜索树的后序遍历序列"><a href="#验证二叉搜索树的后序遍历序列" class="headerlink" title="验证二叉搜索树的后序遍历序列"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/description/">验证二叉搜索树的后序遍历序列</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>可以把数组最右侧元素作为二叉搜索树的根节点值。然后判断数组的左右两侧是否符合左侧值都小于该节点值，右侧值都大于该节点值。如果不满足，则说明不是某二叉搜索树的后序遍历结果。找到左右分界线位置，然后递归左右数组继续查找。</p><p>终止条件为数组 开始位置 &gt; 结束位置，此时该树的子节点数目小于等于 1，直接返回 True 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verifyTreeOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = postorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">verify</span>(postorder, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(left &gt;= right)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 根是right，找到左右分界线</span><br>        <span class="hljs-type">int</span> index = left;<br>        <span class="hljs-keyword">while</span>(postorder[index] &lt; postorder[right])&#123;<br>            index++;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = index;<br>        <span class="hljs-keyword">while</span>(postorder[index] &gt; postorder[right])&#123;<br>            index++;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果，left~mid-1是左子树，mid~right-1是右子树，right是根</span><br>        <span class="hljs-keyword">return</span> index == right &amp;&amp; <span class="hljs-built_in">verify</span>(postorder, left, mid<span class="hljs-number">-1</span>) &amp;&amp; <span class="hljs-built_in">verify</span>(postorder, mid, right<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(n)</li></ul><h3 id="辅助单调栈"><a href="#辅助单调栈" class="headerlink" title="辅助单调栈"></a>辅助单调栈</h3><p><img src="/2024/09/03/posts/0402%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/image-1.png" alt="辅助栈算法"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verifyTreeOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-type">int</span> root = INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(postorder[i] &gt; root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() &gt; postorder[i])&#123;<br>                root = stk.<span class="hljs-built_in">top</span>();<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            stk.<span class="hljs-built_in">push</span>(postorder[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://github.com/datawhalechina/leetcode-notes/blob/main/docs/ch04/04.02/04.02.05-Divide-And-Conquer-Algorithm.md">分治算法</a></p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>分治</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0402递归算法</title>
    <link href="/2024/08/01/posts/0402%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    <url>/2024/08/01/posts/0402%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="04-02-递归算法"><a href="#04-02-递归算法" class="headerlink" title="04.02 递归算法"></a>04.02 递归算法</h1><p>递推过程：指的是将原问题一层一层地分解为与原问题形式相同、规模更小的子问题，直到达到结束条件时停止，此时返回最底层子问题的解。<br>回归过程：指的是从最底层子问题的解开始，逆向逐一回归，最终达到递推开始时的原问题，返回原问题的解。</p><p>具体步骤如下：</p><ol><li>写出递推公式：找到将原问题分解为子问题的规律，并且根据规律写出递推公式。</li><li>明确终止条件：推敲出递归的终止条件，以及递归终止时的处理方法。</li><li>将递推公式和终止条件翻译成代码：</li></ol><ul><li>定义递归函数（明确函数意义、传入参数、返回结果等）。</li><li>书写递归主体（提取重复的逻辑，缩小问题规模）。</li><li>明确递归终止条件（给出递归终止条件，以及递归终止时的处理方法）。</li></ul><p>递归的注意点：</p><ol><li>避免栈溢出：在程序执行中，递归是利用堆栈来实现的。每一次递推都需要一个栈空间来保存调用记录，每当进入一次函数调用，栈空间就会加一层栈帧。每一次回归，栈空间就会减一层栈帧。由于系统中的栈空间大小不是无限的，所以，如果递归调用的次数过多，会导致栈空间溢出。</li><li>避免重复计算：为了避免重复计算，我们可以使用一个缓存（哈希表、集合或数组）来保存已经求解过的f(k)的结果，这也是动态规划算法中的做法。当递归调用用到f(k)时，先查看一下之前是否已经计算过结果，如果已经计算过，则直接从缓存中取值返回，而不用再递推下去，这样就避免了重复计算问题。</li></ol><h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode.cn/problems/fibonacci-number/description/">509. 斐波那契数</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O((\frac{1 + \sqrt{5}}{2})^n)$ <a href="https://zhuanlan.zhihu.com/p/256344121">证明过程</a>。</li><li>空间复杂度： 调用栈的深度为O(n)。</li></ul><h2 id="204-二叉树的最大深度"><a href="#204-二叉树的最大深度" class="headerlink" title="204. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">204. 二叉树的最大深度</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>写出递推公式：当前二叉树的最大深度 &#x3D; max(当前二叉树左子树的最大深度, 当前二叉树右子树的最大深度) + 1。</p><p>明确终止条件：当前二叉树为空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>写出递推公式：当前方法数等于，跨一级台阶的f(n-1)，加上跨两级台阶的f(n-2)，即f(n) &#x3D; f(n-1) + f(n-2)，就是斐波那契数列问题。</p><p>递归结束条件：n&#x3D;0,f(0)&#x3D;0; n&#x3D;1,f(1)&#x3D;1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">climbStairs</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-built_in">climbStairs</span>(n<span class="hljs-number">-2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度和空间复杂度与斐波那契数列问题一致。但本题使用这种方法会超出时间限制。</li></ul><h2 id="0226-翻转二叉树"><a href="#0226-翻转二叉树" class="headerlink" title="0226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/description/">0226. 翻转二叉树</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>翻转当前节点的左右子树。</p><p>递归结束：空节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        TreeNode* left = <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        TreeNode* right = <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        root-&gt;left = right;<br>        root-&gt;right = left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表</a></h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode* next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* newHead = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。</li><li>空间复杂度：O(n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。</li></ul><h2 id="反转链表II"><a href="#反转链表II" class="headerlink" title="反转链表II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/description/">反转链表II</a></h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>记录待反转的前一个节点和后一个节点，然后反转，再连接起来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        ListNode *pre = <span class="hljs-literal">NULL</span>;<br>        ListNode *cur = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode* next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">// 找到衔接处的节点</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = head;<br>        <br>        ListNode* pre = dummy;<br>        <span class="hljs-comment">// pre最终指向left的前一个节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++)&#123;<br>            pre = pre-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// rightNode最终指向right</span><br>        ListNode* rightNode = pre;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right-left+<span class="hljs-number">1</span>; i++)&#123;<br>            rightNode = rightNode-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 截取链表</span><br>        ListNode* leftNode = pre-&gt;next;<br>        ListNode* suc = rightNode-&gt;next;<br>        <span class="hljs-comment">// 切断链接</span><br>        pre-&gt;next = <span class="hljs-literal">NULL</span>;<br>        rightNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 反转链表</span><br>        <span class="hljs-built_in">reverseList</span>(leftNode);<br>        <span class="hljs-comment">// 接回链表</span><br>        pre-&gt;next = rightNode;<br>        leftNode-&gt;next = suc;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>方法一的缺点是：如果 left 和 right 的区域很大，恰好是链表的头节点和尾节点时，找到 left 和 right 需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为 O(N)，但遍历了链表 2 次。解决：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。</p><p><img src="/2024/08/01/posts/0402%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/image.png" alt="图解反转部分链表"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">// 设置dummy</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = head;<br>        <span class="hljs-comment">// 记录left的前一个节点</span><br>        ListNode* pre = dummy;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++)&#123;<br>            pre = pre-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 在反转区间内</span><br>        ListNode* cur = pre-&gt;next;<br>        ListNode* next;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right - left; i++)&#123;<br>            next = cur-&gt;next;<br>            cur-&gt;next = next-&gt;next;<br>            next-&gt;next = pre-&gt;next;<br>            pre-&gt;next = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="第K个语法符号"><a href="#第K个语法符号" class="headerlink" title="第K个语法符号"></a><a href="https://leetcode.cn/problems/k-th-symbol-in-grammar/description/">第K个语法符号</a></h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>$num &#x3D; (k &amp; 1) \oplus 1 \oplus \lfloor \frac{k+1}{2} \rfloor$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthGrammar</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (k &amp; <span class="hljs-number">1</span>) ^ <span class="hljs-number">1</span> ^ <span class="hljs-built_in">kthGrammar</span>(n<span class="hljs-number">-1</span>, (k+<span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="找规律-递归"><a href="#找规律-递归" class="headerlink" title="找规律+递归"></a>找规律+递归</h3><p>每一行的后半部分正好为前半部分的“翻转”——前半部分是 0 后半部分变为 1，前半部分是 1，后半部分变为 0。且每一行的前半部分和上一行相同。我们可以通过「数学归纳法」来进行证明。</p><p>对于查询某一个行第 k 个数字，如果 k 在后半部分，那么原问题就可以转化为求解该行前半部分的对应位置的“翻转”数字，又因为该行前半部分与上一行相同，所以又转化为上一行对应对应的“翻转”数字。那么按照这样一直递归下去，并在第一行时返回数字 0 即可。</p><p>$1 &lt;&lt; (n - 2)$ 是 $2^{n-2}$，表示当前行的前半部分的列数。<br>如果 k 大于 $2^{n-2}$，那么第 k 列位于当前行的后半部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthGrammar</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k &gt; (<span class="hljs-number">1</span> &lt;&lt; (n<span class="hljs-number">-2</span>)))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> ^ <span class="hljs-built_in">kthGrammar</span>(n<span class="hljs-number">-1</span>, k - (<span class="hljs-number">1</span> &lt;&lt; (n<span class="hljs-number">-2</span>)));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">kthGrammar</span>(n<span class="hljs-number">-1</span>, k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="找规律-位运算"><a href="#找规律-位运算" class="headerlink" title="找规律+位运算"></a>找规律+位运算</h3><p>利用 k-1 的二进制表示中 1 的个数来判断符号的值。将 k 转换为 0-based 索引。题目中 k 是从 1 开始的，但我们使用 0-based 索引来简化计算。</p><p>k &amp;&#x3D; k - 1：这是一个经典的位运算技巧，用来清除 k 中最低位的 1。每次执行这个操作，k 中的 1 的个数减少 1。</p><p>如果 k - 1 的二进制中 1 的个数是偶数，则翻转了偶数次，结果是 0。<br>如果 k - 1 的二进制中 1 的个数是奇数，则翻转了奇数次，结果是 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthGrammar</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        k--;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">0</span>)&#123;<br>            k &amp;= k<span class="hljs-number">-1</span>;<br>            res ^= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(logk)$</li><li>空间复杂度：O(1)</li></ul><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/description/">反转字符串</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>可以使用双指针，左指针从第一个元素向后走，右指针从最后一个元素向前走，不断交换左右指针所指元素，直到两指针相撞。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>            <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><blockquote><p>[!NOTE]<br>为什么把这道题归到递归算法类？</p></blockquote><h2 id="两两交换链表中的结点"><a href="#两两交换链表中的结点" class="headerlink" title="两两交换链表中的结点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">两两交换链表中的结点</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>定义两个指针，同时还需要保存第一个节点的前驱和第二个节点的后继。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 边界条件处理</span><br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br>        ListNode* pre = dummy;<br>        ListNode* left = head;<br>        ListNode* right = left-&gt;next;<br>        <span class="hljs-keyword">while</span>(left &amp;&amp; right)&#123;<br>            ListNode* suc = right-&gt;next;<br>            pre-&gt;next = right;<br>            right-&gt;next = left;<br>            left-&gt;next = suc;<br><br>            pre = left;<br>            left = suc;<br>            <span class="hljs-keyword">if</span>(left)&#123;<br>                right = left-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a><a href="https://leetcode.cn/problems/pascals-triangle/description/">杨辉三角</a></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>每一行的第一列和最后一列一定都是1，第i行有i+1个数字，f(0,0) &#x3D; 1，表示第0行第0列是1。f(i,0)&#x3D;1，f(i,i)&#x3D;1,f(i,j) &#x3D; f(i-1, j-1) + f(i-1, j)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generate</span>(<span class="hljs-type">int</span> numRows) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        res.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">1</span>&#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; numRows; i++)&#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cur</span><span class="hljs-params">(i + <span class="hljs-number">1</span>)</span></span>;<br>            cur[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>            cur[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 当前数组应该有i+1个数字</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)&#123;<br>                cur[j] = res[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + res[i<span class="hljs-number">-1</span>][j];<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n^2)$</li></ul><h2 id="杨辉三角II"><a href="#杨辉三角II" class="headerlink" title="杨辉三角II"></a><a href="https://leetcode.cn/problems/pascals-triangle-ii/description/">杨辉三角II</a></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>题目提示要用O(rowIndex)的复杂度实现。</p><p>组合数$C_n^m &#x3D; \frac{n!}{m!(n-m)!}$，可推$C_n^{m-1} &#x3D; \frac{n!}{(m-1)!(n-m+1)!}$，即$C_n^m &#x3D; C_n^{m-1} \times \frac{n-m+1}{m}$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-type">int</span> rowIndex)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(rowIndex + <span class="hljs-number">1</span>)</span></span>;<br>        res[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= rowIndex; i++)&#123;<br>            res[i] = <span class="hljs-number">1ll</span> * res[i<span class="hljs-number">-1</span>] * (rowIndex - i + <span class="hljs-number">1</span>) / i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(rowIndex)</li><li>空间复杂度：O(1)，不考虑返回值所占用的空间。</li></ul><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">合并两个有序链表</a></h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><ol><li>使用哑节点 dummy 构造一个头节点，并使用 cur 指向 dummy 用于遍历。</li><li>然后判断 list1 和 list2 头节点的值，将较小的头节点加入到合并后的链表中。并向后移动该链表的头节点指针。</li><li>然后重复上一步操作，直到两个链表中出现链表为空的情况。</li><li>将剩余链表链接到合并后的链表中。</li><li>将哑节点dummy的下一个链节点 dummy.next 作为合并后有序链表的头节点返回。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode *cur = dummy;<br>        <span class="hljs-keyword">while</span>(list1 &amp;&amp; list2)&#123;<br>            <span class="hljs-keyword">if</span>(list1-&gt;val &lt;= list2-&gt;val)&#123;<br>                cur-&gt;next = list1;<br>                list1 = list1-&gt;next;      <br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cur-&gt;next = list2;<br>                list2 = list2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 剩余节点直接链接到后面</span><br>        <span class="hljs-keyword">if</span>(list1)&#123;<br>            cur-&gt;next = list1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(list2)&#123;<br>            cur-&gt;next = list2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n+m)</li><li>空间复杂度：O(1)</li></ul><h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">二叉树中的最大路径和</a></h2><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>使用深度优先搜索递归遍历二叉树。递归遍历的同时，维护一个最大路径和变量。计算的结果可能的情况有<br>2种：</p><ul><li>经过空节点的最大贡献值等于 0。</li><li>经过非空节点的最大贡献值等于「当前节点值」+「左右子节点的最大贡献值中较大的一个」。</li></ul><ol><li>如果根节点 root 为空，则返回 0。</li><li>递归计算左子树的最大贡献值为 left_max。</li><li>递归计算右子树的最大贡献值为 right_max。</li><li>更新维护最大路径和变量，即 max_sum &#x3D; max(max_sum, root.val + left_max + right_max)。</li><li>返回以当前节点为根节点，并且经过该节点的最大贡献值。即返回「当前节点值」+「左右子节点的最大贡献值中较大的一个」。</li><li>最终 max_sum 即为答案。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> res = -INT_MAX;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> maxLeft = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(root-&gt;left), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> maxRight = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(root-&gt;right), <span class="hljs-number">0</span>);<br>        res = <span class="hljs-built_in">max</span>(res, root-&gt;val + maxLeft + maxRight);<br>        <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">max</span>(maxLeft, maxRight);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)，取决于递归栈的深度，最大是n。</li></ul><h2 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x,n)"></a><a href="https://leetcode.cn/problems/powx-n/description/">Pow(x,n)</a></h2><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> N = n;<br>        <span class="hljs-keyword">return</span> N &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">quickMul</span>(x, N) : <span class="hljs-number">1.0</span> / <span class="hljs-built_in">quickMul</span>(x, -N);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">quickMul</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">long</span> <span class="hljs-type">long</span> N)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(N == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>        &#125;<br>        <span class="hljs-type">double</span> y = <span class="hljs-built_in">quickMul</span>(x, N / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> N % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? y * y : y * y * x;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(logn)</li></ul><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> N = n;<br>        <span class="hljs-keyword">if</span>(N == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(N &lt; <span class="hljs-number">0</span>)&#123;<br>            x = <span class="hljs-number">1.0</span> / x;<br>            N = -N;<br>        &#125;<br>        <span class="hljs-type">double</span> res = <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">while</span>(N)&#123;<br>            <span class="hljs-comment">// 如果N是奇数</span><br>            <span class="hljs-keyword">if</span>(N % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>                res *= x;<br>            &#125;<br>            x *= x;<br>            N &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">quickMul</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">long</span> <span class="hljs-type">long</span> N)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(N == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>        &#125;<br>        <span class="hljs-type">double</span> y = <span class="hljs-built_in">quickMul</span>(x, N / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> N % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? y * y : y * y * x;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><h2 id="不同的二叉搜索树II"><a href="#不同的二叉搜索树II" class="headerlink" title="不同的二叉搜索树II"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/description/">不同的二叉搜索树II</a></h2><h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><p><img src="/2024/08/01/posts/0402%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/image-1.png" alt="分析"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(start &gt; end)&#123;<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">NULL</span>&#125;;<br>        &#125;<br>        <span class="hljs-comment">// 定义结果</span><br>        vector&lt;TreeNode*&gt; res;<br>        <span class="hljs-comment">// 枚举可行根节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start; i &lt;= end; i++)&#123;<br>            vector&lt;TreeNode*&gt; leftTrees = <span class="hljs-built_in">dfs</span>(start, i<span class="hljs-number">-1</span>);<br>            vector&lt;TreeNode*&gt; rightTrees = <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>, end);<br>            <span class="hljs-comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; left : leftTrees)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; right : rightTrees)&#123;<br>                    TreeNode* cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(i);<br>                    cur-&gt;left = left;<br>                    cur-&gt;right = right;<br>                    res.<span class="hljs-built_in">push_back</span>(cur);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, n);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/2024/08/01/posts/0402%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/image-2.png" alt="复杂度分析"></p><h2 id="破冰游戏"><a href="#破冰游戏" class="headerlink" title="破冰游戏"></a><a href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/description/">破冰游戏</a></h2><h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><p><img src="/2024/08/01/posts/0402%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/image-3.png" alt="递推公式"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">iceBreakingGame</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= num; i++)&#123;<br>            res = (target + res) % i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>​</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>递归</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0401枚举算法</title>
    <link href="/2024/07/29/posts/0401%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/29/posts/0401%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="04-01-枚举算法"><a href="#04-01-枚举算法" class="headerlink" title="04.01 枚举算法"></a>04.01 枚举算法</h1><h2 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a><a href="https://leetcode.cn/problems/count-primes/description/">204. 计数质数</a></h2><h3 id="枚举（超时）"><a href="#枚举（超时）" class="headerlink" title="枚举（超时）"></a>枚举（超时）</h3><p>考虑到如果i是x的因数，则$\frac{x}{i}$也必然是x的因数，则我们只需要检验这两个因数中的较小数即可。而较小数一定会落在$[2, \sqrt{x}]$上。因此我们在检验x是否为质数时，只需要枚举$[2, \sqrt{x}]$中的所有数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> sqrtx = <span class="hljs-built_in">sqrt</span>(x);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= sqrtx; i++)&#123;<br>            <span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isPrime</span>(i))&#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n \sqrt{n})$</li><li>空间复杂度：O(1)</li></ul><p><img src="/2024/07/29/posts/0401%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/image.png" alt="超出时间限制"></p><h3 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h3><p>如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，设 isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">isPrime</span><span class="hljs-params">(n, <span class="hljs-literal">true</span>)</span></span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(isPrime[i])&#123;<br>                res++;<br>                <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)i * i &lt; n)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i*i; j &lt; n; j += i)&#123;<br>                    isPrime[j] = <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nloglogn)</li><li>空间复杂度：O(n)</li></ul><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><p>使用已知的质数来标记非质数。如果 i 是当前质数 primes[j] 的倍数，则退出内部循环。这个检查用于优化：当 i 已经是 primes[j] 的倍数时，后续的 i * primes[j] 将不会是质数，因为 i 本身已经被标记了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; primes;  <span class="hljs-comment">// 用于存储找到的质数</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">isPrime</span><span class="hljs-params">(n, <span class="hljs-literal">true</span>)</span></span>;  <span class="hljs-comment">// 标记数组，初始时所有数都标记为质数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(isPrime[i])&#123;<br>                primes.<span class="hljs-built_in">push_back</span>(i);     <span class="hljs-comment">// 如果i是质数，将其加入质数列表</span><br>            &#125;<br>            <span class="hljs-comment">// 遍历当前质数列表</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; primes.<span class="hljs-built_in">size</span>() &amp;&amp; i * primes[j] &lt; n;j++)&#123;<br>                isPrime[i * primes[j]] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 标记i * primes[j]为非质数</span><br>                 <span class="hljs-comment">// 如果i是当前质数列表中的质数的倍数，退出循环</span><br>                 <span class="hljs-keyword">if</span>(i % primes[j] == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                 &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> primes.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><h2 id="1925-统计平方和三元组的数目"><a href="#1925-统计平方和三元组的数目" class="headerlink" title="1925. 统计平方和三元组的数目"></a><a href="https://leetcode.cn/problems/count-square-sum-triples/description/">1925. 统计平方和三元组的数目</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>注意：在计算中，为了防止浮点数造成的误差，并且两个相邻的完全平方正数之间的距离一定大于1，所以我们可以用$\sqrt{a^2 + b^2 + 1}$来代替$\sqrt{a^2 + b^2}$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countTriples</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>; a &lt;= n; a++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b = <span class="hljs-number">1</span>; b &lt;= n; b++)&#123;<br>                <span class="hljs-type">int</span> c = (<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(a*a+b*b+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(c &lt;= n &amp;&amp; a*a + b*b == c*c)&#123;<br>                    res++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(1)</li></ul><h2 id="2427-公因子的数目"><a href="#2427-公因子的数目" class="headerlink" title="2427. 公因子的数目"></a><a href="https://leetcode.cn/problems/number-of-common-factors/description/">2427. 公因子的数目</a></h2><h3 id="枚举到较小值"><a href="#枚举到较小值" class="headerlink" title="枚举到较小值"></a>枚举到较小值</h3><p>最大的公因子也只能小于等于a和b中较小的数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">commonFactors</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-type">int</span> small = <span class="hljs-built_in">min</span>(a, b);<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= small; i++)&#123;<br>            <span class="hljs-keyword">if</span>(a % i == <span class="hljs-number">0</span> &amp;&amp; b % i == <span class="hljs-number">0</span>)&#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="枚举到最大公约数"><a href="#枚举到最大公约数" class="headerlink" title="枚举到最大公约数"></a>枚举到最大公约数</h3><p>因子一定是成对出现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">commonFactors</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-type">int</span> c = <span class="hljs-built_in">gcd</span>(a, b), ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x * x &lt;= c; ++x) &#123;<br>            <span class="hljs-keyword">if</span> (c % x == <span class="hljs-number">0</span>) &#123;<br>                ++ans;<br>                <span class="hljs-keyword">if</span> (x * x != c) &#123;<br>                    ++ans;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(\sqrt{n})$</li><li>空间复杂度：O(1)</li></ul><h2 id="LCR-180-文件组合"><a href="#LCR-180-文件组合" class="headerlink" title="LCR 180. 文件组合"></a><a href="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/description/">LCR 180. 文件组合</a></h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>序列的起点一定小于给定数字编号的$\frac{1}{2}$，枚举每个正整数为起点，判断以它为起点的序列和 sum 是否等于 target 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fileCombination</span>(<span class="hljs-type">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> limit = (target - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;   <span class="hljs-comment">// (target - 1) / 2 等效于 target / 2 下取整</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= limit; i++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; cur;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; ; j++)&#123;<br>                sum += j;<br>                cur.<span class="hljs-built_in">push_back</span>(j);<br>                <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>                    sum = <span class="hljs-number">0</span>;<br>                    cur.<span class="hljs-built_in">clear</span>();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(cur);<br>                    sum = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(target \sqrt{target})$</li><li>空间复杂度：O(1)，除了答案数组只需要常数的空间存放若干变量。</li></ul><h3 id="枚举-数学优化"><a href="#枚举-数学优化" class="headerlink" title="枚举+数学优化"></a>枚举+数学优化</h3><p><img src="/2024/07/29/posts/0401%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/image-1.png" alt="分析"></p><p>求根公式：$\frac{-b \pm \sqrt{b^2 - 4ac}}{2a}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fileCombination</span>(<span class="hljs-type">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> limit = (target - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= limit; x++)&#123;<br>            <span class="hljs-comment">// 计算delta</span><br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> delta = <span class="hljs-number">1</span> - <span class="hljs-number">4</span> * (x - <span class="hljs-number">1ll</span>*x*x - <span class="hljs-number">2</span>*target);<br>            <span class="hljs-comment">// 判断是否有解</span><br>            <span class="hljs-keyword">if</span>(delta &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> delta_sqrt = (<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(delta + <span class="hljs-number">0.5</span>);<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">1ll</span> * delta_sqrt * delta_sqrt == delta &amp;&amp; (delta_sqrt<span class="hljs-number">-1</span>) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> y = (<span class="hljs-number">-1</span> + delta_sqrt) / <span class="hljs-number">2</span>;<br>                <span class="hljs-comment">// 符合要求</span><br>                <span class="hljs-keyword">if</span>(x &lt; y)&#123;<br>                    vector&lt;<span class="hljs-type">int</span>&gt; cur;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &lt;= y; i++)&#123;<br>                        cur.<span class="hljs-built_in">push_back</span>(i);<br>                    &#125;<br>                    res.<span class="hljs-built_in">push_back</span>(cur);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(target)</li><li>空间复杂度：O(1)</li></ul><h2 id="2249-统计圆内格点数目"><a href="#2249-统计圆内格点数目" class="headerlink" title="2249. 统计圆内格点数目"></a><a href="https://leetcode.cn/problems/count-lattice-points-inside-a-circle/description/">2249. 统计圆内格点数目</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>根据半径和坐标的范围确定枚举的范围。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countLatticePoints</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; circles)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">200</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">200</span>; j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; circle : circles)&#123;<br>                    <span class="hljs-type">int</span> x = circle[<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> y = circle[<span class="hljs-number">1</span>];<br>                    <span class="hljs-type">int</span> r = circle[<span class="hljs-number">2</span>];<br>                    <span class="hljs-keyword">if</span>((i-x)*(i-x) + (j-y)*(j-y) &lt;= r*r)&#123;<br>                        res++;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>枚举算法是一种基础而直接的解题方法，适用于解答各种组合问题、计数问题、搜索问题等。它的核心思想是列举所有可能的情况，逐一进行验证，找到符合条件的解。确定需要解决的问题，并明确需要枚举的目标是什么。例如，枚举可能的数值、组合、子集等。确定需要枚举的范围，包括起始值和终止值。确定这个范围有助于限定算法的搜索空间。通过循环或递归的方式，遍历所有可能的选项或组合。例如，通过循环遍历所有整数或所有可能的子集。通过循环或递归的方式，遍历所有可能的选项或组合。例如，通过循环遍历所有整数或所有可能的子集。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>枚举</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode-notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR116-LCR119并查集</title>
    <link href="/2024/07/25/posts/LCR116/"/>
    <url>/2024/07/25/posts/LCR116/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）15-4-并查集"><a href="#剑指offer（专项突破版）15-4-并查集" class="headerlink" title="剑指offer（专项突破版）15.4 并查集"></a>剑指offer（专项突破版）15.4 并查集</h1><p>并查集是一种树形的数据结构，用来表示不相交集合的数据。并查集中的每个子集是一棵树，每个元素是某棵树中的一个节点。树中的每个节点有一个指向父节点的指针，树的根节点的指针指向它自己。并查集支持两种操作，即合并和查找。合并操作将两个子集合并成一个集合，只需要将一个子集对应的树的根节点的指针指向另一个子集对应的树的根节点。另一种操作是查找，即确定某个元素v处于哪个子集中。并查集中的子集由对应的树的根节点代表。从元素v对应的节点开始沿着指向父节点的指针一直找到树的根节点，即节点的祖先节点。并查集的查找操作经常用来判断两个元素是否属于同一个子集。如果两个元素的祖先节点相同，那么它们属于同一个子集。</p><p>并查集经常用来解决图的动态连接问题。假设一个图中有n个节点，最开始的时候这n个节点互不连通，形成n个只有一个节点的子图。每次从图中选取两个节点，如果这两个节点不在同一个子图中，添加一条边连接这两个节点，那么它们所在的子图也就连通了。在添加m条边之后，这个图中子图的数目是多少？最大的子图有多少个节点？这类问题都可以用并查集解决。图中的每个子图对应并查集中的子集，判断图中的两个节点是否在同一个子图就是判断它们对应的元素是否在并查集的同一个子集中，连通图中的两个子图就是合并并查集中的两个子集。</p><h2 id="LCR116-省份数量"><a href="#LCR116-省份数量" class="headerlink" title="LCR116.省份数量"></a><a href="https://leetcode.cn/problems/bLyHh0/description/">LCR116.省份数量</a></h2><h3 id="图搜索"><a href="#图搜索" class="headerlink" title="图搜索"></a>图搜索</h3><p>一个班级可以包含一个或多个朋友圈，对应的图中可能包含一个或多个子图，每个朋友圈对应一个子图。因此，这个问题可以转化为如何求图中子图的数目。</p><p>图的搜索算法可以用来计算图中子图的数目。扫描图中所有的节点。如果某个节点v之前没有访问过，就搜索它所在的子图。当所有节点都访问完之后，就可以知道图中有多少个子图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = isConnected.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(!visited[i])&#123;<br>                <span class="hljs-built_in">findCircle</span>(isConnected, visited, i);<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findCircle</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; isConnected, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited, <span class="hljs-type">int</span> i)</span></span>&#123;<br>        <span class="hljs-comment">// 定义队列</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; que;<br>        que.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-comment">// 遍历所有队列中的节点</span><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> cur = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            visited[cur] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 对于所有相邻节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; isConnected.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(isConnected[cur][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[j])&#123;<br>                    que.<span class="hljs-built_in">push</span>(j);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(n)</li></ul><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集的子集和图中的子图对应，并查集中的子集用树形结构表示。子集的节点都有父节点，根节点的父节点就是它自身。同一个子集中不同节点的根节点一定相同。判断两个节点是不是连通，也就是判断它们是不是属于同一个子集，只需要看它们的根节点是不是相同就可以。</p><p>创建长度为n的数组fathers存储n个节点的父节点。有了这个数组fathers，如果想知道节点i所在的子集的根节点，就可以从节点i开始沿着指向父节点的指针搜索，时间复杂度看起来是O（n），但可以将从节点i到根节点的路径压缩，从而优化时间效率。</p><p>我们真正关心的是节点i的根节点是谁而不是它的父节点，因此可以在fathers[i]中存储它的根节点。当第1次找节点i的根节点时，还需要沿着指向父节点的边遍历直到找到根节点。一旦找到了它的根节点，就把根节点存放到fathers[i]中。不仅如此，还可以一起更新从节点i到根节点的路径上所有节点的根节点。以后只需要O（1）的时间就能知道这些节点的根节点。这种优化叫作路径压缩，因为从节点i到根节点的路径被压缩成若干长度为1的路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义根节点数组并初始化</span><br>        <span class="hljs-type">int</span> n = isConnected.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fathers</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            fathers[i] = i;<br>        &#125;<br>        <span class="hljs-comment">// 不断合并</span><br>        <span class="hljs-type">int</span> res = n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(isConnected[i][j] == <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">unionFathers</span>(fathers, i, j))&#123;<br>                    res--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// 找到根节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fathers, <span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (fathers[x] != x) &#123;<br>            fathers[x] = <span class="hljs-built_in">find</span>(fathers, fathers[x]); <span class="hljs-comment">// 路径压缩</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> fathers[x];<br>    &#125;<br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unionFathers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fathers, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(fathers, x);<br>        <span class="hljs-type">int</span> fy = <span class="hljs-built_in">find</span>(fathers, y);<br>        <span class="hljs-keyword">if</span>(fx != fy)&#123;<br>            fathers[fx] = fy;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：O(n)</li></ul><h2 id="LCR117-相似字符串组"><a href="#LCR117-相似字符串组" class="headerlink" title="LCR117.相似字符串组"></a><a href="https://leetcode.cn/problems/H6lPxb/description/">LCR117.相似字符串组</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>函数similar用来判断两个字符串是否相似。由于题目假设输入的字符串为一组变位词，因此只要两个字符串之间对应位置不同字符的个数不超过两个，那么它们一定相似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSimilarGroups</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义根节点数组</span><br>        <span class="hljs-type">int</span> n = strs.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fathers</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            fathers[i] = i;<br>        &#125;<br>        <span class="hljs-comment">// 判断是否符合条件</span><br>        <span class="hljs-type">int</span> res = n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isSimilar</span>(strs[i], strs[j]) &amp;&amp; <span class="hljs-built_in">unionStr</span>(fathers, i, j))&#123;<br>                    res--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// 判断相似性</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSimilar</span><span class="hljs-params">(string str1, string str2)</span></span>&#123;<br>        <span class="hljs-type">int</span> diff = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str1.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(str1[i] != str2[i])&#123;<br>                diff++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> diff &lt;= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-comment">// 查找</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fathers, <span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(fathers[x] != x)&#123;<br>            fathers[x] = <span class="hljs-built_in">find</span>(fathers, fathers[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> fathers[x];<br>    &#125;<br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unionStr</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fathers, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(fathers, x);<br>        <span class="hljs-type">int</span> fy = <span class="hljs-built_in">find</span>(fathers, y);<br>        <span class="hljs-keyword">if</span>(fx != fy)&#123;<br>            fathers[fx] = fy;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2 \cdot L)$</li><li>空间复杂度：O(n)</li></ul><h2 id="LCR118-冗余连接"><a href="#LCR118-冗余连接" class="headerlink" title="LCR118.冗余连接"></a><a href="https://leetcode.cn/problems/7LpjUW/description/">LCR118.冗余连接</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>判断一条边会不会导致环的规律。如果两个节点分别属于两个不同的子图，添加一条边连接这两个节点，会将它们所在的子图连在一起，但不会形成环。如果两个节点属于同一个子图，添加一条边连接这两个节点就会形成一个环。</p><p>因此，为了找到多余的边需要解决两个问题：一是如何判断两个节点是否属于同一个子图，二是如何合并两个子图。并查集刚好可以解决这两个问题，由此可见，这是一个适合用并查集解决的问题。</p><p>由于题目指出节点的编号从1到n，逐一扫描边的数组edges得到最大的节点编号确定n的值。接下来初始化并查集，将n个节点初始化为n个子集，每个节点的根节点都指向它自己，即“fathers[i]&#x3D;i”。接下来逐一在图中添加边，直到某条边的两个节点属于同一个子集，此时函数union将返回false。添加这条边将导致图中出现环，对于树而言这条边就是多余的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-comment">// 找到最大节点编号</span><br>        <span class="hljs-type">int</span> maxVertex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; edge : edges)&#123;<br>            maxVertex = <span class="hljs-built_in">max</span>(maxVertex, edge[<span class="hljs-number">0</span>]);<br>            maxVertex = <span class="hljs-built_in">max</span>(maxVertex, edge[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 初始化并查集</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fathers</span><span class="hljs-params">(maxVertex + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= maxVertex; i++)&#123;<br>            fathers[i] = i;<br>        &#125;<br>        <span class="hljs-comment">// 不断合并</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; edge : edges)&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">unionEdges</span>(fathers, edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]))&#123;<br>                <span class="hljs-keyword">return</span> edge;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fathers, <span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(fathers[x] != x)&#123;<br>            fathers[x] = <span class="hljs-built_in">find</span>(fathers, fathers[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> fathers[x];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unionEdges</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fathers, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(fathers, x);<br>        <span class="hljs-type">int</span> fy = <span class="hljs-built_in">find</span>(fathers, y);<br>        <span class="hljs-keyword">if</span>(fx != fy)&#123;<br>            fathers[fx] = fy;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(E)</li><li>空间复杂度：O(V)</li></ul><h2 id="LCR119-最长连续序列"><a href="#LCR119-最长连续序列" class="headerlink" title="LCR119.最长连续序列"></a><a href="https://leetcode.cn/problems/WhsWhI/description/">LCR119.最长连续序列</a></h2><h3 id="图搜索-1"><a href="#图搜索-1" class="headerlink" title="图搜索"></a>图搜索</h3><p>如果将每个整数看成图中的一个节点，相邻的（数值大小相差1）两个整数有一条边相连，那么这些整数将形成若干子图，每个连续数值序列对应一个子图。计算最长连续序列的长度就转变成求最大子图的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 存到集合中便于查找</span><br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; hashset;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            hashset.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-comment">// 逐节点进行广度优先搜索</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            <span class="hljs-keyword">if</span>(hashset.<span class="hljs-built_in">count</span>(num))&#123;<br>                res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">bfs</span>(hashset, num));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// 广度优先搜索</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(unordered_set&lt;<span class="hljs-type">int</span>&gt;&amp; hashset, <span class="hljs-type">int</span> num)</span></span>&#123;<br>        <span class="hljs-comment">// 定义队列</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; que;<br>        que.<span class="hljs-built_in">push</span>(num);<br>        <span class="hljs-comment">// 广度优先</span><br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> cur = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            hashset.<span class="hljs-built_in">erase</span>(cur);<br>            len++;<br>            <span class="hljs-keyword">if</span>(hashset.<span class="hljs-built_in">count</span>(cur + <span class="hljs-number">1</span>))&#123;<br>                que.<span class="hljs-built_in">push</span>(cur + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(hashset.<span class="hljs-built_in">count</span>(cur - <span class="hljs-number">1</span>))&#123;<br>                que.<span class="hljs-built_in">push</span>(cur - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：假设输入n个整数，两个相邻的整数存在一条边，因此图中有n个节点、O（n）条边。在图中进行广度优先搜索的时间复杂度是O（n）。</li><li>空间复杂度：hashset和queue存储最多n个数，即O(n)。</li></ul><h3 id="并查集-1"><a href="#并查集-1" class="headerlink" title="并查集"></a>并查集</h3><p>在初始化并查集的时候输入数组中的每个整数放入一个子集中，父节点的指针指向它自己。然后对于每个整数n，如果存在整数n-1和n+1，则将它们所在的子集合并。每个子集的根节点记录它所在子集的元素的数目，在合并子集的时候需要更新合并之后新子集的根节点中子集元素的数目。</p><p>用哈希表fathers记录每个整数所在子集的父节点，哈希表counts用来记录以某个整数为根节点的子集中整数的数目。初始化并查集的时候每个整数的父节点都指向自己，也就是每个子集中只包含一个数字，所以哈希表counts的每个整数对应的值都被初始化为1。</p><p>接下来对于每个整数num，如果存在num-1和num+1，当它们在不同的子图中时将它们所在的子图用函数union合并，并更新合并后子集中元素的数目。判断两个整数是否在同一个子集中的方法是用函数findFather得到它们所在子集的根节点并判断根节点是否相同。</p><p>在将所有可能合并的子集合并之后，扫描哈希表就能得到最大子集的大小，即最长连续数值序列的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义fathers，键是num，值是father</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; fathers;<br>        <span class="hljs-comment">// 定义counts，记录每个以key为根节点的节点个数</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; counts;<br>        <span class="hljs-comment">// 定义集合，便于查找</span><br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; hashset;<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            fathers[num] = num;<br>            counts[num] = <span class="hljs-number">1</span>;<br>            hashset.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-comment">// 对于每个数字</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            <span class="hljs-keyword">if</span>(hashset.<span class="hljs-built_in">count</span>(num + <span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-built_in">unionNum</span>(fathers, counts, num, num + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(hashset.<span class="hljs-built_in">count</span>(num - <span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-built_in">unionNum</span>(fathers, counts, num, num - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 找到最长连续序列</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; iter : counts)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, iter.second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; fathers, <span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(fathers[x] != x)&#123;<br>            fathers[x] = <span class="hljs-built_in">find</span>(fathers, fathers[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> fathers[x];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionNum</span><span class="hljs-params">(unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; fathers, unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; counts, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(fathers, x);<br>        <span class="hljs-type">int</span> fy = <span class="hljs-built_in">find</span>(fathers, y);<br>        <span class="hljs-keyword">if</span>(fx != fy)&#123;<br>            fathers[fx] = fy;<br>            counts[fy] += counts[fx];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：上述代码可能需要合并相邻的整数O（n）次。由于函数findFather在查找根节点的同时进行了路径压缩，查找操作的平均时间复杂度可以近似看成O（1）。因此，这种基于并查集的解法的时间复杂度是O（n）。</li><li>空间复杂度：fathers,counts,hashset都是O(n)。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>图在算法面试中经常出现，它的背景可能会千变万化，有可能是关于一个矩阵，也可能是关于某些物体或人物，但万变不离其宗，只要深刻理解图是用来研究物体与物体之间的关系的。物体就是图中的节点，如果两个物体之间存在某种关系，那么这两个物体在图中对应的节点之间就有一条边相连。很多时候找到图中的节点和边是解决图的问题的关键。</p><p>图的搜索算法是关于图的最重要的算法。很多图的问题都可以用广度优先搜索或深度优先搜索解决。但如果要求无权图中最短路径的长度，那么广度优先搜索是更好的选择；如果路径及路径上节点的顺序对于解决某个图的问题非常关键，那么可以考虑使用深度优先搜索。</p><p>拓扑排序可以解决与任务顺序相关的问题。如果某些任务必须在其他任务之前（或之后）完成，则可以用一个有向图描述任务之间的依赖关系，然后通过拓扑排序得到所有任务的执行顺序。</p><p>如果一个问题对应的图可以分成若干子图，并且需要判断两个节点是否在同一个子图中且在某些时候合并两个子图，那么可以考虑采用并查集来解决这个问题。并查集用一个树形结构表示集合中的一个子集，每个子集对应图中的一个子图。</p><h2 id="刷题心得"><a href="#刷题心得" class="headerlink" title="刷题心得"></a>刷题心得</h2><p>至此，《剑指offer专项突破版》的119道题目都刷了一遍，能够感受到在同一种问题下，知道前面的题怎么做了之后，后面的题会做得更轻松。但是还是有点一边做一边忘了，需要再进行复习，复习的时候需要再进行一些拓展。</p><p>严格来说是从3月1日开始刷的，中间也因为期末考试等等原因暂停过一段时间，将近五个月的时间，可以说是非常慢了。这学期的行动力非常差，经常陷入到无休止地内耗中，一边焦虑一边无所事事。但还好，起码在这件事上坚持了下来，虽然很慢，但好歹是做了东西的。不敢想象如果连这件事都没坚持下来，这个学期会是多么失败。</p><p><img src="/2024/07/25/posts/LCR116/image.png" alt="leetcode算法笔记"></p><p>之后的计划是按照<a href="https://datawhalechina.github.io/leetcode-notes/#/">leetcode算法笔记</a>来继续刷，从04. 基础算法篇开始，到08. 各章节习题解析结束，大概需要两个月的时间。以后一定要提高学习效率，不能一心多用，想一些和自己无关的事，把时间白白浪费掉。</p><p>研一基本上算是结束了，如果说自己什么都没干，一点收获都没有的话，好像也太苛责自己了，毕竟还有那么多焦虑的时间，也不能全怪自己。悟已往之不谏，既然过去了，那就让它过去吧。</p><p>种一棵树最好的时间是十年前，其次是现在。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR113-LCR115拓扑排序</title>
    <link href="/2024/07/23/posts/LCR113/"/>
    <url>/2024/07/23/posts/LCR113/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）15-3-拓扑排序"><a href="#剑指offer（专项突破版）15-3-拓扑排序" class="headerlink" title="剑指offer（专项突破版）15.3 拓扑排序"></a>剑指offer（专项突破版）15.3 拓扑排序</h1><h2 id="LCR113-课程排序"><a href="#LCR113-课程排序" class="headerlink" title="LCR113.课程排序"></a><a href="https://leetcode.cn/problems/QA2IGt/">LCR113.课程排序</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>将课程看成图中的节点，如果两门课程存在先修顺序那么它们在图中对应的节点之间存在一条从先修课程到后修课程的边，因此这是一个有向图。</p><p>对有向图进行拓扑排序的算法是每次找出一个入度为0的节点添加到序列中，然后删除该节点及所有以该节点为起点的边。重复这个过程，直到图为空或图中不存在入度为0的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        <span class="hljs-comment">// 构建有向图，键是先修课程，它的值是必须在键对应的课程之后学习的所有课程</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; hashmap;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            hashmap[i] = temp;<br>        &#125;<br>        <span class="hljs-comment">// 初始化图和入度数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(numCourses, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; preq : prerequisites)&#123;<br>            hashmap[preq[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(preq[<span class="hljs-number">0</span>]);<br>            inDegree[preq[<span class="hljs-number">0</span>]]++;<br>        &#125;<br>        <span class="hljs-comment">// 定义队列，并把入度为0的加入到队列中</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; que;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)&#123;<br>            <span class="hljs-keyword">if</span>(inDegree[i] == <span class="hljs-number">0</span>)&#123;<br>                que.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 定义数组，不断加入删除的节点</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; order;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> course = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            order.<span class="hljs-built_in">push_back</span>(course);<br>            <span class="hljs-comment">// 删除course，即对于course出发的节点，入度-1</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> next : hashmap[course])&#123;<br>                inDegree[next]--;<br>                <span class="hljs-keyword">if</span>(inDegree[next] == <span class="hljs-number">0</span>)&#123;<br>                    que.<span class="hljs-built_in">push</span>(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 判断最后的图是否为空</span><br>        <span class="hljs-keyword">return</span> order.<span class="hljs-built_in">size</span>() == numCourses ? order : <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(v+e)</li><li>空间复杂度：O(v+e)</li></ul><h2 id="LCR114-火星词典"><a href="#LCR114-火星词典" class="headerlink" title="LCR114.火星词典"></a><a href="https://leetcode.cn/problems/Jf1JuT/description/">LCR114.火星词典</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>如果已知两个字母的大小关系，那么图中就有一条从较小的字母指向较大的字母的边。如果能够得出该有向图的拓扑排序序列，那么任意一条边的起始节点（较小的字母）在拓扑排序序列中一定出现在终止节点（较大的字母）的前面。因此，这个问题实质上一个关于拓扑排序的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">alienOrder</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义图，键是字符，值是所有大于它的字符</span><br>        unordered_map&lt;<span class="hljs-type">char</span>, unordered_set&lt;<span class="hljs-type">char</span>&gt;&gt; graph;<br>        <span class="hljs-comment">// 定义入度哈希表，键是字符，值是入度值</span><br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; inDegree;<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span>(string word : words)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : word)&#123;<br>                unordered_set&lt;<span class="hljs-type">char</span>&gt; temp;<br>                graph[ch] = temp;<br>                inDegree[ch] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 对于每个单词</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; words.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            string word1 = words[i<span class="hljs-number">-1</span>];<br>            string word2 = words[i];<br>            <span class="hljs-comment">// 如果w1&lt;w2，但word2是word1的前缀，说明没有符合的顺序</span><br>            <span class="hljs-keyword">if</span>(word1.<span class="hljs-built_in">size</span>() &gt; word2.<span class="hljs-built_in">size</span>() &amp;&amp; word1.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, word2.<span class="hljs-built_in">size</span>()) == word2)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<br>            <span class="hljs-comment">// 否则对于两个单词的每个字符</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; word1.<span class="hljs-built_in">size</span>() &amp;&amp; j &lt; word2.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-type">char</span> ch1 = word1[j];<br>                <span class="hljs-type">char</span> ch2 = word2[j];<br>                <span class="hljs-comment">// 两个字符不相等，存在有向边</span><br>                <span class="hljs-keyword">if</span>(ch1 != ch2)&#123;<br>                    <span class="hljs-keyword">if</span>(!graph[ch1].<span class="hljs-built_in">count</span>(ch2))&#123;<br>                        <span class="hljs-comment">// 更新图和入度</span><br>                        graph[ch1].<span class="hljs-built_in">insert</span>(ch2);<br>                        inDegree[ch2]++;<br>                    &#125;<br>                    <span class="hljs-comment">// 后续字符不再需要比较</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 定义队列，存放入度为0的字符</span><br>        queue&lt;<span class="hljs-type">char</span>&gt; que;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; kv : inDegree)&#123;<br>            <span class="hljs-keyword">if</span>(kv.second == <span class="hljs-number">0</span>)&#123;<br>                que.<span class="hljs-built_in">push</span>(kv.first);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 拓扑排序</span><br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">char</span> ch = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            res += ch;<br>            <span class="hljs-comment">// 删除ch，从它出发的节点入度减一</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> next : graph[ch])&#123;<br>                inDegree[next]--;<br>                <span class="hljs-keyword">if</span>(inDegree[next] == <span class="hljs-number">0</span>)&#123;<br>                    que.<span class="hljs-built_in">push</span>(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">size</span>() == graph.<span class="hljs-built_in">size</span>() ? res : <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：如果单词列表的长度为m，平均每个单词的长度为n，由于上述代码在构建有向图时需要扫描并比较每个字母，因此构建有向图的时间复杂度是O（mn）。该外星文的所有字母为英文字母。有向图中的节点为外星文的字母，最多只有26个，可以将其看成常数。最多根据单词列表words相邻的两个单词在图中添加一条边，所以边的数目是O（n）。于是，采用广度优先搜索的拓扑排序的时间复杂度是O（n）。综合来看，上述算法的总的时间复杂度是O（mn）。</li><li>空间复杂度：O(mn)</li></ul><h2 id="LCR115-序列重建"><a href="#LCR115-序列重建" class="headerlink" title="LCR115.序列重建"></a><a href="https://leetcode.cn/problems/ur2n8P/description/">LCR115.序列重建</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>如果得到的是有向图的拓扑排序序列，那么任意一条边的起始节点在拓扑排序序列中一定位于终止节点的前面。因此，由seqs重建的序列就是由seqs构建的有向图的拓扑排序的序列。这个问题就转变成判断一个有向图的拓扑排序序列是否唯一。</p><p>由于目标是判断图的拓扑排序序列是否唯一，而当某个时刻队列中的节点数目大于1时，就知道此时有多个入度为0的节点，那么按任意顺序排列这个入度为0的节点都能生成有效的拓扑排序序列，因此拓扑排序的序列不是唯一的。由此可知，只在队列的大小为1的时候重复添加入度为0的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sequenceReconstruction</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; sequences)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义图和入度</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, unordered_set&lt;<span class="hljs-type">int</span>&gt;&gt; graph;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; inDegree;<br>        <br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; seq : sequences)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : seq)&#123;<br>                graph[num]; <span class="hljs-comment">// 确保每个数都有一个图节点</span><br>                inDegree[num] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化入度为0</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 对于每个数字，建立图关系</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; seq : sequences)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; seq.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)&#123;<br>                <span class="hljs-type">int</span> num1 = seq[i];<br>                <span class="hljs-type">int</span> num2 = seq[i+<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(!graph[num1].<span class="hljs-built_in">count</span>(num2))&#123;<br>                    graph[num1].<span class="hljs-built_in">insert</span>(num2);<br>                    inDegree[num2]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 定义队列并初始化</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; que;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; kv : inDegree)&#123;<br>            <span class="hljs-keyword">if</span>(kv.second == <span class="hljs-number">0</span>)&#123;<br>                que.<span class="hljs-built_in">push</span>(kv.first);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 拓扑排序</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">if</span>(que.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果队列中有多个元素，说明不是唯一的</span><br>            <span class="hljs-type">int</span> num = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">push_back</span>(num);<br>            <span class="hljs-comment">// 对所有邻接节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> next : graph[num])&#123;<br>                inDegree[next]--;<br>                <span class="hljs-keyword">if</span>(inDegree[next] == <span class="hljs-number">0</span>)&#123;<br>                    que.<span class="hljs-built_in">push</span>(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vectorsAreEqual</span>(nums, res);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">vectorsAreEqual</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; v2)</span> </span>&#123;<br>        <span class="hljs-comment">// 检查大小是否相同</span><br>        <span class="hljs-keyword">if</span> (v1.<span class="hljs-built_in">size</span>() != v2.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 利用 std::equal 比较元素</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">equal</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(v+e)</li><li>空间复杂度：O(v+e)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>拓扑排序是指对一个有向无环图的节点进行排序之后得到的序列。如果存在一条从节点A指向节点B的边，那么在拓扑排序的序列中节点A出现在节点B的前面。一个有向无环图可以有一个或多个拓扑排序序列，但无向图或有环的有向图都不存在拓扑排序。节点v的入度指的是以节点v为终点的边的数目，而节点v的出度是指以节点v为起点的边的数目。</p><p>一种常用的拓扑排序算法是每次从有向无环图中取出一个入度为0的节点添加到拓扑排序序列之中，然后删除该节点及所有以它为起点的边。重复这个步骤，直到图为空或图中不存在入度为0的节点。如果最终图为空，那么图是有向无环图，此时就找到了该图的一个拓扑排序序列。如果最终图不为空并且已经不存在入度为0的节点，那么图中一定有环。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR105-LCR112图的搜索</title>
    <link href="/2024/07/08/posts/LCR105/"/>
    <url>/2024/07/08/posts/LCR105/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）15-2-图的搜索"><a href="#剑指offer（专项突破版）15-2-图的搜索" class="headerlink" title="剑指offer（专项突破版）15.2 图的搜索"></a>剑指offer（专项突破版）15.2 图的搜索</h1><h2 id="LCR105-岛屿的最大面积"><a href="#LCR105-岛屿的最大面积" class="headerlink" title="LCR105.岛屿的最大面积"></a><a href="https://leetcode.cn/problems/ZL6zAn/description/">LCR105.岛屿的最大面积</a></h2><p>可以逐一扫描矩阵中的每个格子，如果遇到一个值为1的格子并且它不在之前已知的岛屿上，那么就到达了一个新的岛屿，于是搜索这个岛屿并计算它的面积。在比较所有岛屿的面积之后就可以知道最大的岛屿的面积。</p><h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h3><p>广度优先搜索通常需要一个队列。先将起始节点添加到队列中。接下来每步从队列中取出一个节点进行访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> maxArea = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[i][j])&#123;<br>                    <span class="hljs-type">int</span> area = <span class="hljs-built_in">getArea</span>(grid, visited, i, j);<br>                    maxArea = <span class="hljs-built_in">max</span>(maxArea, area);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>    <span class="hljs-comment">// 广度优先搜索</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getArea</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>        <span class="hljs-comment">// 定义一个队列</span><br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>        que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(i, j));<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 左右上下四个方向</span><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; directions = &#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;; <br>        <span class="hljs-comment">// 广度优先</span><br>        <span class="hljs-type">int</span> area = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            area++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; dir : directions)&#123;<br>                <span class="hljs-type">int</span> r = dir.first + cur.first;<br>                <span class="hljs-type">int</span> c = dir.second + cur.second;<br>                <span class="hljs-keyword">if</span>(r &lt; grid.<span class="hljs-built_in">size</span>() &amp;&amp; r &gt;= <span class="hljs-number">0</span> &amp;&amp; c &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; grid[r][c] == <span class="hljs-number">1</span> &amp;&amp; !visited[r][c])&#123;<br>                    que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(r, c));<br>                    visited[r][c] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> area;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><p><img src="/2024/07/08/posts/LCR105/image.png" alt="LCR105广度优先搜索"></p><h3 id="用栈实现深度优先搜索"><a href="#用栈实现深度优先搜索" class="headerlink" title="用栈实现深度优先搜索"></a>用栈实现深度优先搜索</h3><p>这个问题也可以用深度优先搜索解决。如果将前面代码中的队列替换成栈，由于栈按照“后进先出”的顺序进行压栈、出栈操作，因此图搜索的顺序相应地变成深度优先搜索。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> maxArea = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[i][j])&#123;<br>                    <span class="hljs-type">int</span> area = <span class="hljs-built_in">getArea</span>(grid, visited, i, j);<br>                    maxArea = <span class="hljs-built_in">max</span>(maxArea, area);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>    <span class="hljs-comment">// 深度优先搜索</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getArea</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>        <span class="hljs-comment">// 定义一个栈</span><br>        stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(i, j));<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 左右上下四个方向</span><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; directions = &#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;; <br>        <span class="hljs-comment">// 深度优先</span><br>        <span class="hljs-type">int</span> area = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>            pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            area++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; dir : directions)&#123;<br>                <span class="hljs-type">int</span> r = dir.first + cur.first;<br>                <span class="hljs-type">int</span> c = dir.second + cur.second;<br>                <span class="hljs-keyword">if</span>(r &lt; grid.<span class="hljs-built_in">size</span>() &amp;&amp; r &gt;= <span class="hljs-number">0</span> &amp;&amp; c &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; grid[r][c] == <span class="hljs-number">1</span> &amp;&amp; !visited[r][c])&#123;<br>                    st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(r, c));<br>                    visited[r][c] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> area;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><p><img src="/2024/07/08/posts/LCR105/image-1.png" alt="LCR105栈深度优先搜索结果"></p><h3 id="基于递归实现深度优先搜索"><a href="#基于递归实现深度优先搜索" class="headerlink" title="基于递归实现深度优先搜索"></a>基于递归实现深度优先搜索</h3><p>深度优先搜索还可以用递归代码实现。从起始节点出发的岛屿的面积等于起始节点的面积（一个节点的面积为1）加上与之相邻并且没有访问过的节点能到达的岛屿的面积。求相邻节点能到达的岛屿的面积和初始问题完全一样，可以用递归函数求得。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> maxArea = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[i][j])&#123;<br>                    <span class="hljs-type">int</span> area = <span class="hljs-built_in">getArea</span>(grid, visited, i, j);<br>                    maxArea = <span class="hljs-built_in">max</span>(maxArea, area);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>    <span class="hljs-comment">// 深度优先搜索</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getArea</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>        visited[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 左右上下四个方向</span><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; directions = &#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;; <br>        <span class="hljs-comment">// 深度优先</span><br>        <span class="hljs-type">int</span> area = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; dir : directions)&#123;<br>            <span class="hljs-type">int</span> r = dir.first + i;<br>            <span class="hljs-type">int</span> c = dir.second + j;<br>            <span class="hljs-keyword">if</span>(r &lt; grid.<span class="hljs-built_in">size</span>() &amp;&amp; r &gt;= <span class="hljs-number">0</span> &amp;&amp; c &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; grid[r][c] == <span class="hljs-number">1</span> &amp;&amp; !visited[r][c])&#123;<br>                visited[r][c] = <span class="hljs-literal">true</span>;<br>                area += <span class="hljs-built_in">getArea</span>(grid, visited, r, c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> area;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><p><img src="/2024/07/08/posts/LCR105/image-2.png" alt="LCR105用递归实现深度优先搜索"></p><h2 id="LCR106-判断二分图"><a href="#LCR106-判断二分图" class="headerlink" title="LCR106.判断二分图"></a><a href="https://leetcode.cn/problems/vEAB3K/">LCR106.判断二分图</a></h2><p>可以为图中的所有节点着色，两种不同类型的节点分别涂上不同的颜色。如果任意一条边的两个节点都能被涂上不同的颜色，那么整个图就是一个二分图。</p><h3 id="利用广度优先搜索对子图着色"><a href="#利用广度优先搜索对子图着色" class="headerlink" title="利用广度优先搜索对子图着色"></a>利用广度优先搜索对子图着色</h3><p>可以用广度优先搜索算法搜索与节点i连通的所有节点。广度优先搜索需要一个队列，先将起始节点i添加到队列中。接下来每次从队列中取出一个节点，如果与该节点相邻的节点之前没有访问过，那么相邻的节点被添加到队列中。本题用一个二维数组graph表示图，graph实际上是图的邻接表，与节点i相邻的节点保存在graph[i]中。重复这个过程，直到队列为空，此时与起始节点i连通的所有节点已经搜索完毕。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 对每个节点进行着色</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">colors</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(colors[i] == <span class="hljs-number">-1</span> &amp;&amp; !<span class="hljs-built_in">setColor</span>(graph, colors, i, <span class="hljs-number">0</span>))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">setColor</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">int</span>&gt;&amp; colors, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> color)</span></span>&#123;<br>        <span class="hljs-comment">// 使用广度优先搜索</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; que;<br>        que.<span class="hljs-built_in">push</span>(i);<br>        colors[i] = color;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> v = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 对v的每个邻接节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; neighbor : graph[v])&#123;<br>                <span class="hljs-comment">// 如果已经着色，判断邻接颜色是否相等</span><br>                <span class="hljs-keyword">if</span>(colors[neighbor] &gt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(colors[neighbor] == colors[v])&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 否则着色，加入队列</span><br>                <span class="hljs-keyword">else</span>&#123;<br>                    colors[neighbor] = <span class="hljs-number">1</span> - colors[v];<br>                    que.<span class="hljs-built_in">push</span>(neighbor);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(v+e)</li><li>空间复杂度：O(v)</li></ul><p><img src="/2024/07/08/posts/LCR105/image-3.png" alt="LCR106广度优先结果"></p><h3 id="利用深度优先搜索对子图着色"><a href="#利用深度优先搜索对子图着色" class="headerlink" title="利用深度优先搜索对子图着色"></a>利用深度优先搜索对子图着色</h3><p>深度优先搜索可以用递归代码实现。函数setColor将节点i的颜色设为color。如果该节点在此之前已经着色，并且它的颜色不是color，那么意味着不能按照二分图的规则对图中的节点进行着色，直接返回false。如果此时节点i还没有着色，则将它的颜色设为color，然后给与它相邻的节点涂上颜色1-color。给相邻的节点着色与给节点i着色是相同的问题，可以递归调用函数setColor解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 对每个节点进行着色</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">colors</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(colors[i] == <span class="hljs-number">-1</span> &amp;&amp; !<span class="hljs-built_in">setColor</span>(graph, colors, i, <span class="hljs-number">0</span>))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">setColor</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">int</span>&gt;&amp; colors, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> color)</span></span>&#123;<br>        <span class="hljs-comment">// 使用深度优先搜索</span><br>        <span class="hljs-keyword">if</span>(colors[i] &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> colors[i] == color;<br>        &#125;<br><br>        colors[i] = color;<br>        <span class="hljs-comment">// 对i的每个邻接节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; neighbor : graph[i])&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">setColor</span>(graph, colors, neighbor, <span class="hljs-number">1</span> - colors[i]))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(v+e)</li><li>空间复杂度：O(v)</li></ul><p><img src="/2024/07/08/posts/LCR105/image-4.png" alt="LCR106深度优先搜索结果"></p><h2 id="LCR107-01矩阵"><a href="#LCR107-01矩阵" class="headerlink" title="LCR107.01矩阵"></a><a href="https://leetcode.cn/problems/2bCMpM/description/">LCR107.01矩阵</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据题目的要求，上、下、左、右相邻的两个格子的距离为1。可以将图看成一个无权图，图中两个节点的距离是连通它们的路径经过的边的数目。由于这个问题与无权图的最近距离相关，因此可以考虑应用广度优先搜索解决。</p><p>广度优先搜索需要一个队列。图中的哪些节点可以当作初始节点添加到队列中？这个问题是求每个格子离最近的0的距离，因此可以将所有的0当作初始节点添加到队列中，然后以值为0的节点作为起点做广度优先搜索。如果经过d步到达某个格子，那么该格子离最近的0的距离就是d。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat) &#123;<br>        <span class="hljs-type">int</span> m = mat.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = mat[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">distance</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-comment">// 使用广度优先搜索</span><br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(mat[i][j] == <span class="hljs-number">0</span>)&#123;<br>                    que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(i, j));<br>                    distance[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    distance[i][j] = INT_MAX;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 对每个为0的节点展开搜索</span><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; directions = &#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pos = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> d = distance[pos.first][pos.second];<br>            <span class="hljs-comment">// 对于四个方向</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; dir : directions)&#123;<br>                <span class="hljs-type">int</span> r = pos.first + dir.first;<br>                <span class="hljs-type">int</span> c = pos.second + dir.second;<br>                <span class="hljs-comment">// 更新距离</span><br>                <span class="hljs-keyword">if</span>(r &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;=<span class="hljs-number">0</span> &amp;&amp; c &lt; n)&#123;<br>                    <span class="hljs-comment">// 将该格子添加到队列中，以便接下来搜索与该格子相连的其他节点</span><br>                    <span class="hljs-keyword">if</span>(d + <span class="hljs-number">1</span> &lt; distance[r][c])&#123;<br>                        distance[r][c] = d + <span class="hljs-number">1</span>;<br>                        que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(r, c));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> distance;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><p><img src="/2024/07/08/posts/LCR105/image-5.png" alt="LCR107结果"></p><h2 id="LCR108-单词接龙"><a href="#LCR108-单词接龙" class="headerlink" title="LCR108.单词接龙"></a><a href="https://leetcode.cn/problems/om3reC/description/">LCR108.单词接龙</a></h2><h3 id="单向广度优先搜索"><a href="#单向广度优先搜索" class="headerlink" title="单向广度优先搜索"></a>单向广度优先搜索</h3><p>应用图相关算法的前提是找出图中的节点和边。这个问题是关于单词的演变的，所以每个单词就是图中的一个节点。如果两个单词能够相互演变（改变一个单词的一个字母能变成另一个单词），那么这两个单词之间有一条边相连。</p><p>这个题目要求计算最短演变序列的长度，即求图中两个节点的最短距离。表示单词演变的图也是一个无权图，按照题目的要求，图中两个节点的距离是连通两个节点的路径经过的节点的数目。通常用广度优先搜索计算无权图中的最短路径，广度优先搜索通常需要用到队列。</p><p>为了求得两个节点之间的最短距离，常见的解法是用两个队列实现广度优先搜索算法。一个队列queue1中存放离起始节点距离为d的节点，当从这个队列中取出节点并访问的时候，与队列queue1中节点相邻的节点离起始节点的距离都是d+1，将这些相邻的节点存放到另一个队列queue2中。当队列queue1中的所有节点都访问完毕时，再访问队列queue2中的节点，并将相邻的节点放入queue1中。可以交替使用queue1和queue2这两个队列由近及远地从起始节点开始搜索所有节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;<br>        <span class="hljs-comment">// 两个队列</span><br>        queue&lt;string&gt; que1;<br>        queue&lt;string&gt; que2;<br>        <span class="hljs-comment">// 哈希表</span><br>        unordered_set&lt;string&gt; notVisited;<br>        <span class="hljs-keyword">for</span>(string&amp; word : wordList)&#123;<br>            notVisited.<span class="hljs-built_in">insert</span>(word);<br>        &#125;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br>        que1.<span class="hljs-built_in">push</span>(beginWord);<br>        <span class="hljs-comment">// 广度优先搜索</span><br>        <span class="hljs-keyword">while</span>(!que1.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-comment">// 如果当前单词是endword</span><br>            string word = que1.<span class="hljs-built_in">front</span>();<br>            que1.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(word == endWord)&#123;<br>                <span class="hljs-keyword">return</span> len;<br>            &#125;<br>            <span class="hljs-comment">// 否则获取它的所有邻接节点</span><br>            vector&lt;string&gt; neighbors = <span class="hljs-built_in">getNeighbors</span>(word);<br>            <span class="hljs-keyword">for</span>(string&amp; cur : neighbors)&#123;<br>                <span class="hljs-keyword">if</span>(notVisited.<span class="hljs-built_in">find</span>(cur) != notVisited.<span class="hljs-built_in">end</span>())&#123;<br>                    que2.<span class="hljs-built_in">push</span>(cur);<br>                    notVisited.<span class="hljs-built_in">erase</span>(cur);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 队列1为空</span><br>            <span class="hljs-keyword">if</span>(que1.<span class="hljs-built_in">empty</span>())&#123;<br>                len++;<br>                que1 = que2;<br>                <span class="hljs-built_in">clear</span>(que2);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 清空队列</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(queue&lt;string&gt;&amp; q)</span> </span>&#123;<br>        queue&lt;string&gt; empty;<br>        <span class="hljs-built_in">swap</span>(empty, q);<br>    &#125;<br>    <span class="hljs-comment">// 获取所有邻接节点</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">getNeighbors</span><span class="hljs-params">(string word)</span></span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-comment">// 遍历每一个字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; word.<span class="hljs-built_in">length</span>(); i++)&#123;<br>            string cur = word;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;a&#x27;</span>; ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; ch++)&#123;<br>                <span class="hljs-keyword">if</span>(word[i] != ch)&#123;<br>                    cur[i] = ch;<br>                    res.<span class="hljs-built_in">push_back</span>(cur);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(N \times C^2)$</li><li>空间复杂度：$O(N \times C^2)$</li></ul><p><img src="/2024/07/08/posts/LCR105/image-6.png" alt="LCR108单向广度优先搜索结果"></p><h3 id="双向广度优先搜索"><a href="#双向广度优先搜索" class="headerlink" title="双向广度优先搜索"></a>双向广度优先搜索</h3><p>这个题目是关于单一起始节点、单一目标节点的最短距离问题。前面的解法是从起始节点出发不断朝着目标节点的方向搜索，直到到达目标节点。针对这类问题有一种常见的优化方法，即在从起始节点出发不断朝着目标节点的方向搜索的同时，也从目标节点出发不断朝着起始节点的方向搜索。这种双向搜索的方法能够缩小搜索空间，从而提高搜索的时间效率。</p><p><img src="/2024/07/08/posts/LCR105/00405.jpeg" alt="单、双向广度优先搜索对比"></p><p>一共使用了3个HashSet，其中，set1和set2分别存放两个方向上当前需要访问的节点，set3用来存放与当前访问的节点相邻的节点。之所以这里用的是HashSet而不是Queue，是因为需要判断从一个方向搜索到的节点在另一个方向是否已经访问过。</p><p>先将起始节点beginWord添加到set1中，将目标节点endWord添加到set2中。接下来每次while循环都是从需要访问的节点数目少的方向搜索，这样做是为了缩小搜索的空间。先确保set1中需要访问的节点数更少，接下来访问set1中的每个节点word。如果某个与节点word相邻的节点neighbor在set2中，则说明两个不同方向的搜索相遇，已经找到了一条起始节点和目标节点之间的最短路径，此时路径的长度就是它们之间的最短距离，否则将节点neighbor添加到set3中。当set1中所有的节点都访问完毕，接下来可能会访问set1的节点的相邻节点，即set3中的节点，因此将set1指向set3。然后继续从set1和set2中选择一个节点数目少的方向进行新一轮的搜索。每轮搜索都意味着在起始节点和目标节点之间的最短路径上多前进了一步，因此变量length增加1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;<br>        <span class="hljs-comment">// 两个哈希表</span><br>        unordered_set&lt;string&gt; set1;<br>        unordered_set&lt;string&gt; set2;<br>        set1.<span class="hljs-built_in">insert</span>(beginWord);<br>        set2.<span class="hljs-built_in">insert</span>(endWord);<br>        <span class="hljs-comment">// 哈希表</span><br>        unordered_set&lt;string&gt; notVisited;<br>        <span class="hljs-keyword">for</span>(string&amp; word : wordList)&#123;<br>            notVisited.<span class="hljs-built_in">insert</span>(word);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(notVisited.<span class="hljs-built_in">find</span>(endWord) == notVisited.<span class="hljs-built_in">end</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        notVisited.<span class="hljs-built_in">erase</span>(endWord);<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 遍历两个set</span><br>        <span class="hljs-keyword">while</span>(!set1.<span class="hljs-built_in">empty</span>() &amp;&amp; !set2.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-comment">// set1指向元素更少的集合</span><br>            <span class="hljs-keyword">if</span>(set1.<span class="hljs-built_in">size</span>() &gt; set2.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-built_in">swap</span>(set1, set2);<br>            &#125;<br>            <span class="hljs-comment">// 存放邻接点的哈希表</span><br>            unordered_set&lt;string&gt; set3;<br>            <span class="hljs-keyword">for</span>(unordered_set&lt;string&gt;::iterator it = set1.<span class="hljs-built_in">begin</span>(); it!=set1.<span class="hljs-built_in">end</span>(); it++)&#123;<br>                string word = *it;<br>                <span class="hljs-comment">// 获取所有邻接节点</span><br>                vector&lt;string&gt; neighbors = <span class="hljs-built_in">getNeighbors</span>(word);<br>                <span class="hljs-keyword">for</span>(string&amp; cur : neighbors)&#123;<br>                    <span class="hljs-comment">// 如果在set2中，说明找到相遇的路径</span><br>                    <span class="hljs-keyword">if</span>(set2.<span class="hljs-built_in">find</span>(cur) != set2.<span class="hljs-built_in">end</span>())&#123;<br>                        <span class="hljs-keyword">return</span> len;<br>                    &#125;<br>                    <span class="hljs-comment">// 否则加入set3</span><br>                    <span class="hljs-keyword">if</span>(notVisited.<span class="hljs-built_in">find</span>(cur) != notVisited.<span class="hljs-built_in">end</span>())&#123;<br>                        set3.<span class="hljs-built_in">insert</span>(cur);<br>                        notVisited.<span class="hljs-built_in">erase</span>(cur);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// set1指向set3</span><br>            len++;<br>            set1 = set3;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取所有邻接节点</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">getNeighbors</span><span class="hljs-params">(string word)</span></span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-comment">// 遍历每一个字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; word.<span class="hljs-built_in">length</span>(); i++)&#123;<br>            string cur = word;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;a&#x27;</span>; ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; ch++)&#123;<br>                <span class="hljs-keyword">if</span>(word[i] != ch)&#123;<br>                    cur[i] = ch;<br>                    res.<span class="hljs-built_in">push_back</span>(cur);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(N \times C^2)$</li><li>空间复杂度：$O(N \times C^2)$</li></ul><p><img src="/2024/07/08/posts/LCR105/image-7.png" alt="LCR108双向广度优先搜索结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果面试题要求在无权图中找出两个节点之间的最短距离，那么广度优先搜索可能是更合适的算法。如果面试题要求找出符合条件的路径，那么深度优先搜索可能是更合适的算法。</p><p>前面介绍了如何实现树的广度优先搜索和深度优先搜索。树也可以看成图。实际上，树是一类特殊的图，树中一定不存在环。但图不一样，图中可能包含环。</p><p>当沿着图中的边搜索一个图时，一定要确保程序不会因为沿着环的边不断在环中搜索而陷入死循环。程序陷入死循环是很多应聘者在解决与图相关的面试题时经常出现的问题。</p><p>避免死循环的办法是记录已经搜索过的节点，在访问一个节点之前先判断该节点之前是否已经访问过，如果之前访问过那么这次就略过不再重复访问。</p><p>假设一个图有v个节点、e条边。不管是采用广度优先搜索还是深度优先搜索，每个节点都只会访问一次，并且会沿着每条边判断与某个节点相邻的节点是否已经访问过，因此时间复杂度是O（v+e）。</p><h2 id="LCR109-打开转盘锁"><a href="#LCR109-打开转盘锁" class="headerlink" title="LCR109.打开转盘锁"></a><a href="https://leetcode.cn/problems/zlDJc7/description/">LCR109.打开转盘锁</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>密码锁4个转轮上的数字定义了密码锁的状态，转动密码锁的转轮可以改变密码锁的状态。一般而言，如果一个问题是关于某事物状态的改变，那么可以考虑把问题转换成图搜索的问题。事物的每个状态是图中的一个节点，如果一个状态能够转变到另一个状态，那么这两个状态对应的节点之间有一条边相连。</p><p>对于这个问题而言，密码锁的每个状态都对应着图中的一个节点，如状态”0000”是一个节点，”0001”是另一个节点。如果转动某个转轮一次可以让密码锁从一个状态转移到另一个状态，那么这两个状态之间有一条边相连。例如，将状态”0000”分别向上或向下转动4个转轮中的一个，可以得到8个状态，即”0001”、”0009”、”0010”、”0090”、”0100”、”0900”、”1000”和”9000”，那么图中节点”0000”就有8条边分别和这8个状态对应的节点相连。</p><p>由于题目要求的是找出节点”0000”到密码的对应节点的最短路径的长度，因此应该采用广度优先搜索。这是因为广度优先搜索是从起始节点开始首先达到所有距离为1的节点，接着到达所有距离为2节点。广度优先搜索一定是从起始节点沿着最短路径到达目标节点的。</p><p>搜索密码锁对应的图时还要注意避开死锁状态对应的节点，因为一旦到达这些节点之后就不能继续向下搜索。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;<br>        <span class="hljs-comment">// 为死亡数字创建一个哈希表，便于检索</span><br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">dead</span><span class="hljs-params">(deadends.begin(), deadends.end())</span></span>;<br>        <br>        <span class="hljs-comment">// 边界条件，初始密码/目标密码是死亡数字</span><br>        string init = <span class="hljs-string">&quot;0000&quot;</span>;<br>        <span class="hljs-keyword">if</span> (dead.<span class="hljs-built_in">find</span>(init) != dead.<span class="hljs-built_in">end</span>() || dead.<span class="hljs-built_in">find</span>(target) != dead.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 定义一个Visited</span><br>        unordered_set&lt;string&gt; visited;<br>        <br>        <span class="hljs-comment">// 定义两个队列，que1存放广度优先搜索的节点，que2存放当前节点的邻接节点</span><br>        queue&lt;string&gt; que1;<br>        <br>        <span class="hljs-comment">// 初始化</span><br>        visited.<span class="hljs-built_in">insert</span>(init);<br>        que1.<span class="hljs-built_in">push</span>(init);<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 广度优先搜索</span><br>        <span class="hljs-keyword">while</span> (!que1.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que1.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                string cur = que1.<span class="hljs-built_in">front</span>();<br>                que1.<span class="hljs-built_in">pop</span>();<br>                <br>                <span class="hljs-comment">// 如果是目标密码</span><br>                <span class="hljs-keyword">if</span> (cur == target) &#123;<br>                    <span class="hljs-keyword">return</span> len;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 对于所有邻居节点</span><br>                vector&lt;string&gt; neighbors = <span class="hljs-built_in">getNeighbors</span>(cur);<br>                <span class="hljs-keyword">for</span> (string&amp; str : neighbors) &#123;<br>                    <span class="hljs-comment">// 判断是否是死亡数字，是否访问过</span><br>                    <span class="hljs-keyword">if</span> (dead.<span class="hljs-built_in">find</span>(str) == dead.<span class="hljs-built_in">end</span>() &amp;&amp; visited.<span class="hljs-built_in">find</span>(str) == visited.<span class="hljs-built_in">end</span>()) &#123;<br>                        visited.<span class="hljs-built_in">insert</span>(str);<br>                        que1.<span class="hljs-built_in">push</span>(str);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            len++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 找出所有邻居节点</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">getNeighbors</span><span class="hljs-params">(string cur)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cur.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-comment">// 向上拨动</span><br>            <span class="hljs-type">char</span> newCh = cur[i] == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-string">&#x27;9&#x27;</span> : cur[i] - <span class="hljs-number">1</span>;<br>            string newStr = cur;<br>            newStr[i] = newCh;<br>            res.<span class="hljs-built_in">push_back</span>(newStr);<br>            <br>            <span class="hljs-comment">// 向下拨动</span><br>            newCh = cur[i] == <span class="hljs-string">&#x27;9&#x27;</span> ? <span class="hljs-string">&#x27;0&#x27;</span> : cur[i] + <span class="hljs-number">1</span>;<br>            newStr[i] = newCh;<br>            res.<span class="hljs-built_in">push_back</span>(newStr);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：<img src="/2024/07/08/posts/LCR105/image-8.png" alt="LCR109时间复杂度"></li><li>空间复杂度：<img src="/2024/07/08/posts/LCR105/image-9.png" alt="LCR109空间复杂度"></li></ul><p><img src="/2024/07/08/posts/LCR105/image-10.png" alt="LCR109结果"></p><h2 id="LCR110-所有可能得路径"><a href="#LCR110-所有可能得路径" class="headerlink" title="LCR110.所有可能得路径"></a><a href="https://leetcode.cn/problems/bP4bmD/description/">LCR110.所有可能得路径</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>这个题目要求找出有向无环图中从节点0到节点n-1的所有路径，自然需要搜索图中的所有节点。通常可以用广度优先搜索或深度优先搜索完成图的搜索。由于这个题目要求列出从节点0到节点n-1的所有路径，因此深度优先搜索是更合适的选择。</p><p>深度优先搜索通常用递归实现。从节点0出发开始搜索。每当搜索到节点i时，先将该节点添加到路径中去。如果该节点正好是节点n-1，那么就找到了一条从节点0到节点n-1的路径。如果不是，则从graph[i]找到每个相邻的节点并用同样的方法进行搜索。当从节点i出发能够抵达的所有节点都搜索完毕之后，将回到前一个节点搜索其他与之相邻的节点。在回到前一个节点之前，需要将节点i从路径中删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, graph, path, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> source, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 当前节点加入路径</span><br>        path.<span class="hljs-built_in">push_back</span>(source);<br>        <span class="hljs-comment">// 如果是最后一个节点，即形成一条路径</span><br>        <span class="hljs-keyword">if</span>(source == graph.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 对于每个相连的节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> next : graph[source])&#123;<br>                <span class="hljs-built_in">dfs</span>(next, graph, path, res);<br>            &#125; <br>        &#125;<br>        <span class="hljs-comment">// 从路径中移除最后的节点</span><br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n * 2^n)$</li><li>空间复杂度：O(n)</li></ul><h2 id="LCR111-除法求值"><a href="#LCR111-除法求值" class="headerlink" title="LCR111.除法求值"></a><a href="https://leetcode.cn/problems/vlzXQL/description/">LCR111.除法求值</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">calcEquation</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;<span class="hljs-type">double</span>&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = equations.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 对于每个节点建立邻接表</span><br>        unordered_map&lt;string, vector&lt;pair&lt;string, <span class="hljs-type">double</span>&gt;&gt;&gt; graph;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            graph[equations[i][<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(&#123;equations[i][<span class="hljs-number">1</span>], values[i]&#125;);<br>            graph[equations[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(&#123;equations[i][<span class="hljs-number">0</span>], <span class="hljs-number">1</span> / values[i]&#125;);<br>        &#125;<br>        <span class="hljs-comment">// 定义结果数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(queries.size(), <span class="hljs-number">-1.0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; queries.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(graph.<span class="hljs-built_in">count</span>(queries[i][<span class="hljs-number">0</span>]) &amp;&amp; graph.<span class="hljs-built_in">count</span>(queries[i][<span class="hljs-number">1</span>]))&#123;<br>                unordered_set&lt;string&gt; visited;<br>                res[i] = <span class="hljs-built_in">dfs</span>(graph, visited, queries[i][<span class="hljs-number">0</span>], queries[i][<span class="hljs-number">1</span>], <span class="hljs-number">1.0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dfs</span><span class="hljs-params">(unordered_map&lt;string, vector&lt;pair&lt;string, <span class="hljs-type">double</span>&gt;&gt;&gt;&amp; graph, unordered_set&lt;string&gt;&amp; visited, string start, string end, <span class="hljs-type">double</span> val)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(start == end)&#123;<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>        <span class="hljs-comment">// 标记已访问过</span><br>        visited.<span class="hljs-built_in">insert</span>(start);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; node : graph[start])&#123;<br>            <span class="hljs-comment">// 如果没访问过</span><br>            <span class="hljs-keyword">if</span>(!visited.<span class="hljs-built_in">count</span>(node.first))&#123;<br>                <span class="hljs-type">double</span> cur = <span class="hljs-built_in">dfs</span>(graph, visited, node.first, end, node.second * val);<br>                <span class="hljs-comment">// 如果大于 0 肯定可以直接返回，但如果小于 0, 只能说明当前元素作为起点无法与终点连通，应进行下一循环，换个起点</span><br>                <span class="hljs-keyword">if</span>(cur &gt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">return</span> cur;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1.0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：假设有m个查询，则时间复杂度为$O(m \times (v+e))$</li><li>空间复杂度：图使用邻接表表示，每个节点的邻接表存储相连的节点及其对应的权重。假设图中有V个节点和E条边，那么图的空间复杂度为O(V + E)。使用一个大小为m的结果数组来存储查询结果，所以空间复杂度为O(m)。DFS的递归深度在最坏情况下为图的高度，即最多为V。递归调用栈的空间复杂度为O(V)。使用一个unordered_set来存储访问过的节点，最坏情况下存储所有节点，所以空间复杂度为O(V)。总的空间复杂度为：$O(m+v+e)$。</li></ul><h2 id="LCR112-矩阵中的最长递增路径"><a href="#LCR112-矩阵中的最长递增路径" class="headerlink" title="LCR112.矩阵中的最长递增路径"></a><a href="https://leetcode.cn/problems/fpTFWP/description/">LCR112.矩阵中的最长递增路径</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>两个不同数字在图中对应的节点之间的边是有向边，针对这个问题构建出来的图是一个有向图。同时，由于图中所有边都是从较小的数字指向较大的数字，这样的边不可能形成环，因此构建出来的图一定是有向无环图。</p><p>接着考虑如何计算图中最长递增路径的长度。由于需要搜索图中的所有节点才能确定最长递增路径的长度，因此这也是一个关于图搜索的问题。解决图搜索通常用广度优先搜索和深度优先搜索这两种不同的方法。这个问题中的路径是非常关键的信息，而深度优先搜索能够很方便地记录搜索的路径，因此深度优先搜索更适合这个问题。</p><p>因为不知道从哪个节点开始的递增路径是最长的，所以试着找出从矩阵的每个数字出发的最长递增路径的长度，通过比较可以得出整个矩阵中的最长递增路径的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestIncreasingPath</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 定义路径长度数组</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathLen</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 对于每一个节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-type">int</span> len = <span class="hljs-built_in">dfs</span>(matrix, pathLen, i, j);<br>                res = <span class="hljs-built_in">max</span>(res, len);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; pathLen, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(pathLen[i][j] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> pathLen[i][j];<br>        &#125;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; dir : dirs)&#123;<br>            <span class="hljs-type">int</span> r = i + dir.first;<br>            <span class="hljs-type">int</span> c = j + dir.second;<br>            <span class="hljs-keyword">if</span>(r &lt; m &amp;&amp; r &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; n &amp;&amp; c &gt;= <span class="hljs-number">0</span> &amp;&amp; matrix[r][c] &gt; matrix[i][j])&#123;<br>                <span class="hljs-type">int</span> path = <span class="hljs-built_in">dfs</span>(matrix, pathLen, r, c);<br>                len = <span class="hljs-built_in">max</span>(path+<span class="hljs-number">1</span>, len);<br>            &#125;<br>        &#125;<br>        pathLen[i][j] = len;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>如果面试题要求在无权图中找出两个节点之间的最短距离，那么广度优先搜索可能是更合适的算法。如果面试题要求找出符合条件的路径，那么深度优先搜索可能是更合适的算法。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR101-LCR104背包问题</title>
    <link href="/2024/07/06/posts/LCR101/"/>
    <url>/2024/07/06/posts/LCR101/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）14-5-背包问题"><a href="#剑指offer（专项突破版）14-5-背包问题" class="headerlink" title="剑指offer（专项突破版）14.5 背包问题"></a>剑指offer（专项突破版）14.5 背包问题</h1><h2 id="LCR101-分割等和子集"><a href="#LCR101-分割等和子集" class="headerlink" title="LCR101.分割等和子集"></a><a href="https://leetcode.cn/problems/NUPfPr/description/">LCR101.分割等和子集</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果能够将数组中的数字分成和相等的两部分，那么数组中所有数字的和（记为sum）应该是一个偶数。也可以换一个角度来描述这个问题：能否从数组中选出若干数字，使它们的和等于sum&#x2F;2（将sum&#x2F;2记为t）。如果将数组中的每个数字看成物品的重量，也可以这样描述这个问题：能否选择若干物品，使它们刚好放满一个容量为t的背包？由于每个物品（数字）最多只能选择一次，因此这是一个0-1背包问题。</p><p>可以用函数f（i，j）表示能否从前i个物品（物品标号分别为0，1，…，i-1）中选择若干物品放满容量为j的背包。如果总共有n个物品，背包的容量为t，那么f（n，t）就是问题的解。</p><p>当判断能否从前i个物品中选择若干物品放满容量为j的背包时，对标号为i-1的物品有两个选择。一个选择是将标号为i-1的物品放入背包中，如果能从前i-1个物品（物品标号分别为0，1，…，i-2）中选择若干物品放满容量为j-nums[i-1]的背包（即f（i-1，j-nums[i-1]）为true），那么f（i，j）就为true。另一个选择是不将标号为i-1的物品放入背包中，如果从前i-1个物品中选择若干物品放满容量为j的背包（即f（i-1，j）为true），那么f（i，j）也为true。</p><p>当j等于0时，即背包的容量为0，不论有多少个物品，只要什么物品都不选择，就能使选中的物品的总重量为0，因此f（i，0）都为true。</p><p>当i等于0时，即物品的数量为0，肯定无法用0个物品来放满容量大于0的背包，因此当j大于0时f（0，j）都为false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 定义dp数组，行是物品个数，列是target</span><br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(target+<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 填充第一列，即背包容量为0，每个都不选择装入</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 填充剩余部分</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= target; j++)&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];  <span class="hljs-comment">// 不装入</span><br>                <span class="hljs-keyword">if</span>(!dp[i][j] &amp;&amp; j &gt;= nums[i<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j-nums[i<span class="hljs-number">-1</span>]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nt)</li><li>空间复杂度：O(nt)</li></ul><p><img src="/2024/07/06/posts/LCR101/image.png" alt="LCR101结果"></p><h3 id="优化空间效率"><a href="#优化空间效率" class="headerlink" title="优化空间效率"></a>优化空间效率</h3><p>如果f（i，j）和f（i-1，j）可以保存到数组的同一个位置，那么只需要一个一维数组。如果按照从左到右的顺序填充表格，f（i-1，j）在计算完f（i，j）之后还可能在计算右边其他值时被用到，那么不能用f（i，j）替换f（i-1，j）。但是如果按照从右到左的顺序填充表格，f（i-1，j）在计算完f（i，j）之后就再也不会被用到，f（i-1，j）被f（i，j）替换掉不会引起任何问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 定义dp数组，行是物品个数，列是target</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] =<span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 填充剩余部分</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = target; j &gt; <span class="hljs-number">0</span>; j--)&#123;<br>                <span class="hljs-keyword">if</span>(!dp[j] &amp;&amp; j &gt;= nums[i<span class="hljs-number">-1</span>])&#123;<br>                    dp[j] = dp[j-nums[i<span class="hljs-number">-1</span>]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nt)</li><li>空间复杂度：O(t)</li></ul><p><img src="/2024/07/06/posts/LCR101/image-1.png" alt="LCR101空间优化结果"></p><h2 id="LCR102-目标和"><a href="#LCR102-目标和" class="headerlink" title="LCR102.目标和"></a><a href="https://leetcode.cn/problems/YaVDxD/description/">LCR102.目标和</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>在分析解决这个问题之前，需要先做数学运算。为输入的数组中的有些数字添加“+”，有些数字添加“-”。如果所有添加“+”的数字之和为p，所有添加“-”的数字之和为q，按照题目的要求，p-q&#x3D;S。如果累加数字中的所有数字，就能得到整个数组的数字之和，记为sum，即p+q&#x3D;sum。将这两个等式的左右两边分别相加，就可以得到2p&#x3D;S+sum，即p&#x3D;（S+sum）&#x2F;2。</p><p>上面的等式表明，如果能够找出数组中和为（S+sum）&#x2F;2的数字，并给它们添加“+”，然后给其他数字添加“-”，那么最终的计算结果就是S。因此，这个题目等价于计算从数组中选出和为（S+sum）&#x2F;2的数字的方法的数目。这是和前面的面试题非常类似的题目，是一个典型的0-1背包问题，可以用动态规划解决。</p><p>用动态规划求解问题的关键在于确定状态转移方程。可以用函数f（i，j）表示在数组的前i个数字（即nums[0..i-1]）中选出若干数字使和等于j的方法的数目。如果数组的长度为n，目标和为t，那么f（n，t）就是整个问题的解。</p><p>这个问题的状态转移方程和前面的非常类似，唯一的区别在于这里的f（i，j）的值不再只是一个true或false的标识，而是一个数值。可以用下列等式表示状态转移方程:</p><p><img src="/2024/07/06/posts/LCR101/00373.jpeg" alt="LCR102推导"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 边界条件</span><br>        <span class="hljs-keyword">if</span>(target &gt; sum || (sum + target) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> newTarget = (sum + target) / <span class="hljs-number">2</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(newTarget+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// j == 0, dp[i][0] = 1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 填充剩余部分</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= newTarget; j++)&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>                <span class="hljs-keyword">if</span>(j &gt;= nums[i<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j] += dp[i<span class="hljs-number">-1</span>][j-nums[i<span class="hljs-number">-1</span>]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][newTarget];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nt)</li><li>空间复杂度：O(nt)</li></ul><p><img src="/2024/07/06/posts/LCR101/image-2.png" alt="LCR102结果"></p><h3 id="优化空间效率-1"><a href="#优化空间效率-1" class="headerlink" title="优化空间效率"></a>优化空间效率</h3><p>由于计算“dp[i][j]”只需要用上一行“dp[i-1][j]”和“dp[i-1][j-nums[i]]”的值，因此只保存表格中的两行。如果从右向左计算每行的值，f（i，j）和f（i-1，j）就可以保存到同一个位置。因此，只创建一个一维数组dp，按照从右到左的顺序计算，并将f（i-1，j）和f（i，j）都保存到“dp[j]”中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 边界条件</span><br>        <span class="hljs-keyword">if</span>(target &gt; sum || (sum + target) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> newTarget = (sum + target) / <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(newTarget+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">// j == 0, dp[0] = 1</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 填充剩余部分</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num : nums)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = newTarget; j &gt;= num; j--)&#123;<br>                dp[j] += dp[j-num];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[newTarget];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nt)</li><li>空间复杂度：O(t)</li></ul><p><img src="/2024/07/06/posts/LCR101/image-3.png" alt="LCR102空间优化结果"></p><h2 id="LCR103-零钱兑换"><a href="#LCR103-零钱兑换" class="headerlink" title="LCR103.零钱兑换"></a><a href="https://leetcode.cn/problems/gaM7Ch/description/">LCR103.零钱兑换</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>每种面额的硬币可以使用任意多次，因此这个问题不再是0-1背包问题，而是一个无界背包问题（也叫完全背包问题）。用函数f（i，j）表示用前i种硬币（coins[0，…，i-1]）凑出总额为j需要的硬币的最少数目。当使用0枚标号为i-1的硬币时，f（i，j）等于f（i-1，j）（用前i-1种硬币凑出总额j需要的最少硬币数目，再加上1枚标号为i-1的硬币）；当使用1枚标号为i-1的硬币时，f（i，j）等于f（i-1，j-coins[i-1]）加1（用前i-1种硬币凑出总额j-coins[i-1]需要的最少硬币数目，再加上1枚标号为i-1的硬币）；以此类推，当使用k枚标号为i-1的硬币时，f（i，j）等于f（i-1，j-k×coins[i-1]）加k（用前i-1种硬币凑出总额j-k×coins[i-1]需要的最少硬币数目，再加上k枚标号为i-1的硬币）。由于目标是求出硬币数目的最小值，因此f（i，j）是上述所有情况的最小值。该状态转移方程可以用如下等式表示：</p><p>f (i,j)&#x3D;min(f(i-1,j-k×coins[i-1])+k)(k×coins[i-1]≤j)</p><p>如果硬币有n种，目标总额为t，那么f（n，t）就是问题的解。</p><p>当j等于0（即总额等于0）时，f（i，0）都等于0，即从前i种硬币中选出0个硬币，使总额等于0。当i等于0且j大于0时，即用0种硬币凑出大于0的总额，这显然是不可能的，但可以用一个特殊值表示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建一个大小为 amount+1 的数组 dp，初始值为 amount+1，这个值被选为初始值是因为它比任何有效找零方式都要大</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount+<span class="hljs-number">1</span>, amount+<span class="hljs-number">1</span>)</span></span>;<br>        <br>        <span class="hljs-comment">// 初始化，表示找零金额为 0 时，所需的最小硬币数为 0</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历每种硬币</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; coin : coins)&#123;<br>            <span class="hljs-comment">// 从当前硬币的面值开始遍历到 amount，更新 dp 数组</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = coin; j &lt;= amount; j++)&#123;<br>                <span class="hljs-comment">// 更新 dp[j]，表示找零金额为 j 时所需的最小硬币数</span><br>                <span class="hljs-comment">// dp[j] 可以由两种情况得到：</span><br>                <span class="hljs-comment">// 1. 不使用当前硬币 coin，即 dp[j] 的值保持不变；</span><br>                <span class="hljs-comment">// 2. 使用当前硬币 coin，即 dp[j-coin] 的值加上当前硬币 coin 的面值，此时需要的硬币数加一</span><br>                dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j-coin] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果 dp[amount] 的值仍然为 amount+1，说明没有有效的找零方式，返回 -1；否则返回 dp[amount]</span><br>        <span class="hljs-keyword">return</span> dp[amount] == amount + <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nt)</li><li>空间复杂度：O(t)</li></ul><p><img src="/2024/07/06/posts/LCR101/image-4.png" alt="LCR103结果"></p><h3 id="另一种思路"><a href="#另一种思路" class="headerlink" title="另一种思路"></a>另一种思路</h3><p>用函数f（i）表示凑出总额为i的硬币需要的最少数目。需要注意的是，这个函数只有一个参数，表示硬币的总额。如果目标总额为t，那么f（t）就是整个问题的解。</p><p>为了凑出总额为i的硬币，有如下选择：在总额为i-coins[0]的硬币中添加1枚标号为0的硬币，此时f（i）等于f（i-coins[0]）+1（在凑出总额为i-coins[0]的最少硬币数的基础上加1枚标号为0的硬币）；在总额为i-coins[1]的硬币中添加1枚标号为1的硬币，此时f（i）等于f（i-coins[1]）+1。以此类推，在总额为i-coins[n-1]的硬币中添加1枚标号为n-1的硬币，此时f（i）等于f（i-coins[n-1]）+1。因为目标是计算凑出总额为i的硬币，所以f（i）是上述所有情况的最小值。该状态转移方程可以表示为</p><p>f (i)&#x3D;min(f(i-coins[j])+1)(coins[j]≤i)</p><p>显然，f（0）等于0，即凑出总额0至少需要0枚硬币。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建一个大小为 amount+1 的数组 dp</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 遍历每个金额</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++)&#123;<br>            dp[i] = amount + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 遍历每种硬币</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; coin : coins)&#123;<br>                <span class="hljs-keyword">if</span>(i &gt;= coin)&#123;<br>                    dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i-coin] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果 dp[amount] 的值仍然为 amount+1，说明没有有效的找零方式，返回 -1；否则返回 dp[amount]</span><br>        <span class="hljs-keyword">return</span> dp[amount] == amount + <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nt)</li><li>空间复杂度：O(t)</li></ul><p><img src="/2024/07/06/posts/LCR101/image-5.png" alt="LCR103结果"></p><p>方法一首先遍历每一种硬币，在每次遍历中，尝试将当前硬币加入到已经计算出来的金额组合中，更新最小硬币数。方法二首先遍历每个金额，在每次遍历中，尝试使用每种硬币来更新该金额对应的最小硬币数。</p><h2 id="LCR104-组合总和"><a href="#LCR104-组合总和" class="headerlink" title="LCR104.组合总和"></a><a href="https://leetcode.cn/problems/D0F0SV/description/">LCR104.组合总和</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>用f（i）表示和为i的排列的数目。为了得到和为i的排列，有如下选择：在和为i-nums[0]的排列中添加标号为0的数字，此时f（i）等于f（i-nums[0]）；在和为i-nums[1]的排列中添加标号为1的数字，此时f（i）等于f（i-nums[1]）。以此类推，在和为i-nums[n-1]的排列中添加标号为n-1的数字（n为数组的长度），此时f（i）等于f（i-nums[n-1]）。因为目标是求出所有和为i的排列的数目，所以将上述所有情况全部累加起来。该状态转移方程可以表示为</p><p>f (i)&#x3D;∑f (i-nums[j])(nums[j]≤i)</p><p>由于只有一个空排列的数字之和等于0，因此f（0）等于1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 初始情况：目标和为 0 时有一种组合方式（什么都不选）</span><br>        <span class="hljs-comment">// 遍历目标和从 1 到 target 的每一个可能值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= target; i++)&#123;<br>            <span class="hljs-comment">// 遍历数组 nums 中的每一个数字 num</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num : nums)&#123;<br>                <span class="hljs-keyword">if</span>(i &gt;= num)&#123;<br>                    dp[i] += dp[i-num];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(nt)</li><li>空间复杂度：O(t)</li></ul><p><img src="/2024/07/06/posts/LCR101/image-6.png" alt="LCR104结果"></p><p><img src="/2024/07/06/posts/LCR101/image-7.png" alt="进阶问题"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果解决一个问题需要若干步骤，并且在每个步骤都面临若干选项，不要求列出问题的所有解，而只是要求计算解的数目或找出其中一个最优解，那么这个问题可以应用动态规划加以解决。</p><p>本章介绍了单序列问题、双序列问题、矩阵路径问题和背包问题，这几类问题都适合运用动态规划来解决。运用动态规划解决问题的关键在于根据题目的特点推导状态转移方程。一旦确定了状态转移方程，那么问题就能迎刃而解。</p><p>状态转移方程是递归表达式，很容易就能将其转换成递归的代码。通常，直接用递归的代码实现状态转移方程存在大量的重复计算，因此需要将计算结果进行缓存，以确保每个值只计算一次。</p><p>递归的代码按照自上而下的顺序解决问题，而迭代的代码按照自下而上的顺序解决问题。迭代的代码可以更好地控制计算的顺序，可能会减少缓存所需要的空间复杂度，进一步优化空间效率。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR098-LCR100矩阵路径问题</title>
    <link href="/2024/07/04/posts/LCR098/"/>
    <url>/2024/07/04/posts/LCR098/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）14-4-矩阵路径问题"><a href="#剑指offer（专项突破版）14-4-矩阵路径问题" class="headerlink" title="剑指offer（专项突破版）14.4 矩阵路径问题"></a>剑指offer（专项突破版）14.4 矩阵路径问题</h1><h2 id="LCR098-不同路径"><a href="#LCR098-不同路径" class="headerlink" title="LCR098.不同路径"></a><a href="https://leetcode.cn/problems/2AoeFn/description/">LCR098.不同路径</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>可以用函数f（i，j）表示从格子的左上角坐标为（0，0）的位置出发到达坐标为（i，j）的位置的路径的数目。如果格子的大小为m×n，那么f（m-1，n-1）就是问题的解。</p><p>当i等于0时，机器人位于格子最上面的一行，机器人不可能从某个位置向下走一步到达一个行号i等于0的位置。因此，f（0，j）等于1，即机器人只有一种方法可以到达坐标为（0，j）的位置，即从（0，j-1）的位置向右走一步。</p><p>当j等于0时，机器人位于格子最左边的一列，机器人不可能从某个位置向右走一步到达一个列号j为0的位置。因此，f（i，0）等于1，即机器人只有一种方法可以到达坐标为（i，0）的位置，即从（i-1，0）的位置向下走一步。</p><p>当行号i、列号j都大于0时，机器人有两种方法可以到达坐标为（i，j）的位置。它既可以从坐标为（i-1，j）的位置向下走一步，也可以从坐标为（i，j-1）的位置向右走一步，因此，f（i，j）等于f（i-1，j）与f（i，j-1）之和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 填充剩余部分</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><p><img src="/2024/07/04/posts/LCR098/image.png" alt="LCR098结果"></p><h3 id="优化空间效率"><a href="#优化空间效率" class="headerlink" title="优化空间效率"></a>优化空间效率</h3><p>可以进一步优化空间效率，只需要创建一个一维数组dp就可以。在计算f（i，j）时需要用到f（i-1，j）和f（i，j-1）的值。接下来在计算f（i，j+1）时需要用到f（i-1，j+1）和f（i，j）的值。在计算完f（i，j）之后，就不再需要f（i-1，j）的值。在二维表格中，f（i，j）和f（i-1，j）是上下相邻的两个位置。由于在用f（i-1，j）计算出f（i，j）之后就不再需要f（i-1，j），因此可以只用一个位置来保存f（i-1，j）和f（i，j）的值。这个位置在计算f（i，j）之前保存的是f（i-1，j）的值，计算f（i，j）之后保存的是f（i，j）的值。由于每个位置能够用来保存两个值，因此只需要一个一维数组就能保存表格中的两行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 填充剩余部分</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                dp[j] += dp[j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(n)</li></ul><p><img src="/2024/07/04/posts/LCR098/image-1.png" alt="LCR098空间优化结果"></p><h2 id="LCR099-最小路径和"><a href="#LCR099-最小路径和" class="headerlink" title="LCR099.最小路径和"></a><a href="https://leetcode.cn/problems/0i0mDW/">LCR099.最小路径和</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>用函数f（i，j）表示从格子的左上角坐标为（0，0）的位置（用grid[0][0]表示）出发到达坐标为（i，j）的位置（用grid[i][j]表示）的路径的数字之和的最小值。如果格子的大小为m×n，那么f（m-1，n-1）就是问题的解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 填充第一行，即只能从左向右走到J</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = grid[<span class="hljs-number">0</span>][j] + dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 填充第一列，即只能从上往下走到i</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = grid[i][<span class="hljs-number">0</span>] + dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-comment">// 填充其余部分</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]) + grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><p><img src="/2024/07/04/posts/LCR098/image-2.png" alt="LCR099结果"></p><h3 id="优化空间效率-1"><a href="#优化空间效率-1" class="headerlink" title="优化空间效率"></a>优化空间效率</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            dp[j] = grid[<span class="hljs-number">0</span>][j] + dp[j<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 填充其余部分</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            dp[<span class="hljs-number">0</span>] = grid[i][<span class="hljs-number">0</span>] + dp[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j<span class="hljs-number">-1</span>]) + grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(n)</li></ul><p><img src="/2024/07/04/posts/LCR098/image-3.png" alt="LCR099空间优化结果"></p><h2 id="LCR100-三角形最小路径和"><a href="#LCR100-三角形最小路径和" class="headerlink" title="LCR100.三角形最小路径和"></a><a href="https://leetcode.cn/problems/IlPe0q/description/">LCR100.三角形最小路径和</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>同样用f(i,j)来表示走到位置(i,j)时最小的路径和。对于第一行可以直接初始化，第一列的，只能由f(i-1,0)得到，最后一列的，只能由f(i-1, j-1)得到，且j&lt;&#x3D;i。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = triangle.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = triangle[m<span class="hljs-number">-1</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + triangle[i][j];<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == i)&#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + triangle[i][j];<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j]) + triangle[i][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 找到最后一行最小的</span><br>        <span class="hljs-type">int</span> res = dp[m<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            res = <span class="hljs-built_in">min</span>(res, dp[m<span class="hljs-number">-1</span>][j]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><p><img src="/2024/07/04/posts/LCR098/image-4.png" alt="LCR100结果"></p><h3 id="优化空间效率-2"><a href="#优化空间效率-2" class="headerlink" title="优化空间效率"></a>优化空间效率</h3><p>假设在计算f（i，j）之前“dp[j]”中保存的是f（i-1，j）的值。在计算f（i，j）时需要f（i-1，j-1）和f（i-1，j）。在计算完f（i，j）之后能否用f（i，j）的值覆盖保存在“dp[j]”中的f（i-1，j）取决于是否还需要f（i-1，j）的值。如果每行按照从左到右的顺序，那么在计算完f（i，j）之后将计算f（i，j+1），而计算f（i，j+1）可能需要f（i-1，j）和f（i-1，j+1）的值，也就是f（i-1，j）的值在计算f（i，j+1）时可能会被用到，因此在计算完f（i，j）之后不能将f（i-1，j）的值丢掉。</p><p>但计算f（i，j）时并不依赖同一行左侧的f（i，j-1），因此并不一定要按照从左到右的顺序计算每行，按照从右到左的顺序计算也可以。如果按照从右到左的顺序，则先计算f（i，j），需要用到f（i-1，j-1）和f（i-1，j）。接下来计算f（i，j-1），需要用到f（i-1，j-1）和f（i-1，j-2）。计算f（i-1，j-1）并不需要用到f（i-1，j）。因此，按照从右到左的顺序在计算完f（i，j）之后，将f（i，j）的值保存到“dp[j]”中并替换f（i-1，j）的值，并且不会带来任何问题，因此f（i-1，j）的值以后就不再需要。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = triangle.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = triangle[m<span class="hljs-number">-1</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;<br>                    dp[j] += triangle[i][j];<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == i)&#123;<br>                    dp[j] = dp[j<span class="hljs-number">-1</span>] + triangle[i][j];<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[j] = <span class="hljs-built_in">min</span>(dp[j<span class="hljs-number">-1</span>], dp[j]) + triangle[i][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 找到最后一行最小的</span><br>        <span class="hljs-type">int</span> res = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            res = <span class="hljs-built_in">min</span>(res, dp[j]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(n)</li></ul><p><img src="/2024/07/04/posts/LCR098/image-5.png" alt="LCR100空间优化结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>矩阵路径是一类常见的可以用动态规划来解决的问题。这类问题通常输入的是一个二维的格子，一个机器人按照一定的规则从格子的某个位置走到另一个位置，要求计算路径的条数或找出最优路径。</p><p>矩阵路径相关问题的状态方程通常有两个参数，即f（i，j）的两个参数i、j通常是机器人当前到达的坐标。需要根据路径的特点找出到达坐标（i，j）之前的位置，通常是坐标（i-1，j-1）、（i-1，j）、（i，j-1）中的一个或多个。相应地，状态转移方程就是找出f（i，j）与f（i-1，j-1）、f（i-1，j）或f（i，j-1）的关系。</p><p>可以根据状态转移方程写出递归代码，但值得注意的是一定要将f（i，j）的计算结果用一个二维数组缓存，以避免不必要的重复计算。也可以将计算所有f（i，j）看成填充二维表格的过程，相应地，可以创建一个二维数组并逐一计算每个元素的值。通常，矩阵路径相关问题的代码都可以优化空间效率，用一个一维数组就能保存所有必需的数据。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR095-LCR097双序列问题</title>
    <link href="/2024/07/03/posts/LCR095/"/>
    <url>/2024/07/03/posts/LCR095/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）14-3-双序列问题"><a href="#剑指offer（专项突破版）14-3-双序列问题" class="headerlink" title="剑指offer（专项突破版）14.3 双序列问题"></a>剑指offer（专项突破版）14.3 双序列问题</h1><h2 id="LCR095-最长公共子序列"><a href="#LCR095-最长公共子序列" class="headerlink" title="LCR095.最长公共子序列"></a><a href="https://leetcode.cn/problems/qJnOS7/description/">LCR095.最长公共子序列</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>由于输入有两个字符串，因此状态转移方程有两个参数。用函数f（i，j）表示第1个字符串中下标从0到i的子字符串（记为s1[0..i]）和第2个字符串中下标从0到j的子字符串（记为s2[0..j]）的最长公共子序列的长度。如果第1个字符串的长度是m，第2个字符串的长度是n，那么f（m-1，n-1）就是整个问题的解。</p><p>如果第1个字符串中下标为i的字符（记为s1[i]）与第2个字符串中下标为j（记为s2[j]）的字符相同，那么f（i，j）相当于在s1[0..i-1]和s2[0..j-1]的最长公共子序列的后面添加一个公共字符，也就是f（i，j）&#x3D;f（i-1，j-1）+1。</p><p>如果字符s1[i]与字符s2[j]不相同，则这两个字符不可能同时出现在s1[0..i]和s2[0..j]的公共子序列中。此时s1[0..i]和s2[0..j]的最长公共子序列要么是s1[0..i-1]和s2[0..j]的最长公共子序列，要么是s1[0..i]和s2[0..j-1]的最长公共子序列。也就是说，此时f（i，j）是f（i-1，j）和f（i，j-1）的最大值。</p><p><img src="/2024/07/03/posts/LCR095/00331.jpeg" alt="LCR095状态转移方程"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1 = text1.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> len2 = text2.<span class="hljs-built_in">length</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len1+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2+<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 填充表格</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len2; j++)&#123;<br>                <span class="hljs-keyword">if</span>(text1[i] == text2[j])&#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i][j+<span class="hljs-number">1</span>], dp[i+<span class="hljs-number">1</span>][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len1][len2];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><p><img src="/2024/07/03/posts/LCR095/image.png" alt="LCR095结果"></p><h3 id="优化空间效率，只保存表格中的两行"><a href="#优化空间效率，只保存表格中的两行" class="headerlink" title="优化空间效率，只保存表格中的两行"></a>优化空间效率，只保存表格中的两行</h3><p>接着尝试优化空间效率。需要注意的是，f（i，j）的值依赖于表格中左上角f（i-1，j-1）的值、正上方f（i-1，j）的值和同一行左边f（i，j-1）的值。由于计算f（i，j）的值时只需要使用上方一行的值和同一行左边的值，因此实际上只需要保存表格中的两行就可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1 = text1.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> len2 = text2.<span class="hljs-built_in">length</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2+<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 填充表格</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len2; j++)&#123;<br>                <span class="hljs-keyword">if</span>(text1[i] == text2[j])&#123;<br>                    dp[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>][j+<span class="hljs-number">1</span>] = dp[i%<span class="hljs-number">2</span>][j] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>][j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i%<span class="hljs-number">2</span>][j+<span class="hljs-number">1</span>], dp[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len1%<span class="hljs-number">2</span>][len2];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(n)</li></ul><p><img src="/2024/07/03/posts/LCR095/image-1.png" alt="LCR095空间优化结果"></p><h2 id="LCR096-交错字符串"><a href="#LCR096-交错字符串" class="headerlink" title="LCR096.交错字符串"></a><a href="https://leetcode.cn/problems/IY6buf/description/">LCR096.交错字符串</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>如果字符串s1的长度为m，字符串s2的长度为n，那么它们交织得到的字符串s3的长度一定是m+n。可以用函数f（i，j）表示字符串s1的下标从0到i的子字符串（记为s1[0..i]，长度为i+1）和字符串s2的下标从0到j的子字符串（记为s2[0..j]，长度为j+1）能否交织得到字符串s3的下标从0到i+j+1（记为s3[0..i+j+1]，长度为i+j+2）的子字符串。f（m-1，n-1）就是整个问题的解。</p><p>按照字符串的交织规则，字符串s3的下标为i+j+1的字符（s3[i+j+1]）既可能是来自字符串s1的下标为i的字符（s1[i]），也可能是来自字符串s2的下标为j的字符（s2[j]）。如果s3[i+j+1]和s1[i]相同，只要s1[0..i-1]和s2[0..j]能交织得到子字符串s3[i+j]，那么s1[0..i]一定能和s2[0..j]交织得到s3[0..i+j+1]。也就是说，当s3[i+j+1]和s1[i]相同时，f（i，j）的值等于f（i-1，j）的值。类似地，当s3[i+j+1]和s2[j]相同时，f（i，j）的值等于f（i，j-1）的值。如果s1[i]和s2[j]都和s3[i+j+1]相同，此时只要f（i-1，j）和f（i，j-1）有一个值为true，那么f（i，j）的值为true。</p><p>由此可知，f（i，j）的值依赖于f（i-1，j）和f（i，j-1）的值。如果i等于0，那么f（0，j）的值依赖于f（-1，j）和f（0，j-1）的值。状态转移方程中的i是指字符串s1中当前处理的子字符串的最后一个字符的下标。当i等于0时，当前处理的字符串s1的子字符串中只有一个下标为0的字符。那么当i等于-1时，当前处理的字符串s1的子字符串中一个字符也没有，是空的。f（-1，j）的含义是当字符串s1的子字符串是空字符串的时候，它和字符串s2从下标从0到j的子字符串（即s2[0..j]）能否交织出字符串s3中下标从0到j的子字符串（即s3[0..j]）。由于空字符和s2[0..j]交织的结果一定还是s2[0..j]，因此f（-1，j）的值其实取决于子字符串s2[0..j]和s3[0..j]是否相同。如果s2[j]和s3[j]不同，那么f（-1，j）的值为false；如果s2[j]和s3[j]相同，那么f（-1，j）的值等于f（-1，j-1）的值。</p><p>类似地，f（i，-1）的含义是当字符串s2的子字符串是空字符串时，它和s1[0..i]能否交织得到s3[0..i]，因此f（i，-1）的值取决于子字符串s1[0..i]和s3[0..i]是否相同。如果s1[i]和s3[i]不同，那么f（i，-1）的值为false；如果s1[i]和s3[i]相同，那么f（i，-1）的值等于f（i-1，-1）的值。</p><p>当i和j都等于-1时，f（-1，-1）的值的含义是两个空字符串能否交织得到一个空字符串。这显然是可以的，因此f（-1，-1）的值为true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isInterleave</span><span class="hljs-params">(string s1, string s2, string s3)</span> </span>&#123;<br>        <span class="hljs-comment">// 边界条件</span><br>        <span class="hljs-type">int</span> m = s1.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> n = s2.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span>(m + n != s3.<span class="hljs-built_in">length</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 二维数组存储结果</span><br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n+<span class="hljs-number">1</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 填充第一行，即s1为空，s2 == s3</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; s2[j] == s3[j]; j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j+<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 填充第一列，即s2为空，s1 == s3</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m &amp;&amp; s1[i] == s3[i]; i++)&#123;<br>            dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 填充剩余部分</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-type">char</span> ch1 = s1[i];<br>                <span class="hljs-type">char</span> ch2 = s2[j];<br>                <span class="hljs-type">char</span> ch3 = s3[i+j+<span class="hljs-number">1</span>];<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = ((ch1==ch3 &amp;&amp; dp[i][j+<span class="hljs-number">1</span>]) || (ch2==ch3 &amp;&amp; dp[i+<span class="hljs-number">1</span>][j]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><p><img src="/2024/07/03/posts/LCR095/image-2.png" alt="LCR096结果"></p><h3 id="优化空间效率"><a href="#优化空间效率" class="headerlink" title="优化空间效率"></a>优化空间效率</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isInterleave</span><span class="hljs-params">(string s1, string s2, string s3)</span> </span>&#123;<br>        <span class="hljs-comment">// 边界条件</span><br>        <span class="hljs-type">int</span> m = s1.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> n = s2.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span>(m + n != s3.<span class="hljs-built_in">length</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 二维数组存储结果</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// s1为空，s2 == s3</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; s2[j] == s3[j]; j++)&#123;<br>            dp[j+<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 填充剩余部分</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">0</span>] &amp;&amp; s1[i] == s3[i];    <span class="hljs-comment">// s2为空</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-type">char</span> ch1 = s1[i];<br>                <span class="hljs-type">char</span> ch2 = s2[j];<br>                <span class="hljs-type">char</span> ch3 = s3[i+j+<span class="hljs-number">1</span>];<br>                dp[j+<span class="hljs-number">1</span>] = ((ch1==ch3 &amp;&amp; dp[j+<span class="hljs-number">1</span>]) || (ch2==ch3 &amp;&amp; dp[j]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(n)</li></ul><p><img src="/2024/07/03/posts/LCR095/image-3.png" alt="LCR096空间优化结果"></p><h2 id="LCR097-不同的子序列"><a href="#LCR097-不同的子序列" class="headerlink" title="LCR097.不同的子序列"></a><a href="https://leetcode.cn/problems/21dk04/description/">LCR097.不同的子序列</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>由于这个问题的输入有两个字符串，因此状态转移方程有两个参数。用f（i，j）表示字符串S下标从0到i的子字符串（记为S[0..i]）中等于字符串T下标从0到j的子字符串（记为T[0..j]）的子序列的数目。如果字符串S的长度是m，字符串T的长度是n，那么f（m-1，n-1）就是字符串S中等于字符串T的子序列的数目。</p><p>当字符串S的长度小于字符串T的长度时，字符串S中不可能存在等于字符串T的子序列，所以当i小于j时f（i，j）的值都等于0。</p><p>如果字符串S中下标为i的字符（记为S[i]）等于字符串T中下标为j的字符（记为T[j]），那么对S[i]有两个选择：一个是用S[i]去匹配T[j]，那么S[0..i]中等于T[0..j]的子序列的数目等于S[0..i-1]中等于T[0..j-1]的子序列的数目；另一个是舍去S[i]，那么S[0..i]中等于T[0..j]的子序列的数目等于S[0..i-1]中等于T[0..j]的子序列的数目。因此，当S[i]等于T[j]时，f（i，j）等于f（i-1，j-1）+f（i-1，j）。</p><p>如果S[i]和T[j]不相同，则只能舍去S[i]，此时f（i，j）等于f（i-1，j）。</p><p>接着考虑字符串S和T为空的情形。由于f（0，j）表示S[0..0]（子字符串的长度为1）中等于T[0..j]的子序列的数目，因此f（-1，j）表示字符串S为空。同理，f（i，-1）表示字符串T为空。</p><p>当字符串S、T都为空时，两个字符串匹配，因此f（-1，-1）等于1。如果字符串S为空而字符串T不为空，那么字符串S中不可能存在等于字符串T的子序列，即当j大于或等于0时f（-1，j）等于0。如果字符串S不为空而字符串T为空，那么字符串S的空子序列（舍去字符串S的所有字符）等于字符串T，即当i大于或等于0时f（i，-1）等于1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> n = t.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-comment">// 边界条件</span><br>        <span class="hljs-keyword">if</span>(m &lt; n)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;   <span class="hljs-comment">// s和t都是空字符串</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 填充第一列，s不为空但t为空</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i &amp;&amp; j &lt; n; j++)&#123;<br>                <span class="hljs-comment">// s[i]和t[j]相等，dp[i][j] = dp[i-1][j-1]+dp[i-1][j]</span><br>                <span class="hljs-keyword">if</span>(s[i] == t[j])&#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j] + dp[i][j+<span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j+<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：dp用int型会溢出。</p><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(mn)</li></ul><p><img src="/2024/07/03/posts/LCR095/image-4.png" alt="LCR097结果"></p><h3 id="优化空间效率-1"><a href="#优化空间效率-1" class="headerlink" title="优化空间效率"></a>优化空间效率</h3><p>由于计算f（i，j）只依赖位于它上一行的f（i-1，j-1）和f（i-1，j），并不依赖位于它左边的f（i，j-1），因此不一定要按照从左到右的顺序计算f（i，j）。如果按照从右到左的顺序，则先计算f（i，j）再计算f（i，j-1）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> n = t.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-comment">// 边界条件</span><br>        <span class="hljs-keyword">if</span>(m &lt; n)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;   <span class="hljs-comment">// s和t都是空字符串</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-built_in">min</span>(i,n<span class="hljs-number">-1</span>); j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>                <span class="hljs-comment">// s[i]和t[j]相等</span><br>                <span class="hljs-keyword">if</span>(s[i] == t[j])&#123;<br>                    dp[j+<span class="hljs-number">1</span>] += dp[j];<br>                &#125;<br>                <span class="hljs-comment">// 省略不相等的时候</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述代码省略了S[i]和T[j]不相等的情况。在开始计算f（i，j）之前，f（i-1，j）保存在“dp[j+1]”中。当S[i]和T[j]不相等时，f（i，j）等于f（i-1，j）。因此，此时“dp[j+1]”的值也是f（i，j）的值，并不需要任何改动。</p><ul><li>时间复杂度：O(mn)</li><li>空间复杂度：O(n)</li></ul><p><img src="/2024/07/03/posts/LCR095/image-5.png" alt="LCR097空间优化结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>和单序列问题不同，双序列问题的输入有两个或更多的序列，通常是两个字符串或数组。由于输入是两个序列，因此状态转移方程通常有两个参数，即f（i，j），定义第1个序列中下标从0到i的子序列和第2个序列中下标从0到j的子序列的最优解（或解的个数）。一旦找到了f（i，j）与f（i-1，j-1）、f（i-1，j）和f（i，j-1）的关系，通常问题也就迎刃而解。</p><p>由于双序列的状态转移方程有两个参数，因此通常需要使用一个二维数组来保存状态转移方程的计算结果。但在大多数情况下，可以优化代码的空间效率，只需要保存二维数组中的一行就可以完成状态转移方程的计算，因此可以只用一个一维数组就能实现二维数组的缓存功能。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR089-LCR094单序列问题</title>
    <link href="/2024/06/27/posts/LCR089/"/>
    <url>/2024/06/27/posts/LCR089/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）14-2-单序列问题"><a href="#剑指offer（专项突破版）14-2-单序列问题" class="headerlink" title="剑指offer（专项突破版）14.2 单序列问题"></a>剑指offer（专项突破版）14.2 单序列问题</h1><h2 id="LCR089-打家劫舍"><a href="#LCR089-打家劫舍" class="headerlink" title="LCR089.打家劫舍"></a><a href="https://leetcode.cn/problems/Gu0c2T/description/">LCR089.打家劫舍</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>小偷一次只能进入一幢房屋内盗窃，因此到街道上所有房屋中盗窃需要多个步骤，每一步到一幢房屋内盗窃。由于这条街道有报警系统，因此他每到一幢房屋前都面临一个选择，考虑是不是能进去偷东西。完成一件事情需要多个步骤，并且每一步都面临多个选择，这看起来是一个适合运用回溯法的问题。但由于这个问题并没有要求列举出小偷所有满足条件的偷盗的方法，而只是求最多能偷取的财物的数量，也就是求问题的最优解，因此这个问题适合运用动态规划。</p><p>小偷在标号为i的房屋前有两个选择。一个选择是他进去偷东西。由于街道上有报警系统，因此他不能进入相邻的标号为i-1的房屋内偷东西，之前他最多能偷取的财物的最大值是f（i-2）。因此，小偷如果进入标号为i的房屋并盗窃，他最多能偷得f（i-2）+nums[i]（nums是表示房屋内财物数量的数组）。另一个选择是小偷不进入标号为i的房屋，那么他可以进入标号为i-1的房屋内偷东西，因此此时他最多能偷取的财物的数量为f（i-1）。那么小偷在到达标号为i的房屋时他能偷取的财物的最大值就是两个选项的最大值，即$f（i）&#x3D;max（f（i-2）+nums[i]，f（i-1））$，这就是解决这个问题的状态转移方程。</p><p>上述状态转移方程有一个隐含条件，假设i大于或等于2。当i等于0时，f（0）是街道上只有标号为0的一幢房屋时小偷最多能偷得的财物的数量，此时他无所顾忌，直接进入标号为0的房屋偷东西，因此f（1）&#x3D;nums[0]；当i等于1时，f（1）是街道上只有标号为0和1的两幢房屋时小偷最多能偷得的财物的数量，因为街道上有报警系统，他只能到两幢房屋的其中一幢去偷东西，所以他应该选择到财物数量更多的房屋去偷东西，即f（1）&#x3D;max（nums[0]，nums[1]）。</p><h3 id="带缓存的递归代码"><a href="#带缓存的递归代码" class="headerlink" title="带缓存的递归代码"></a>带缓存的递归代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 创建一个大小为n的dp数组，初始值为-1，用于存储子问题的最优解</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">helper</span>(nums, dp, n<span class="hljs-number">-1</span>), <span class="hljs-built_in">helper</span>(nums, dp, n<span class="hljs-number">-2</span>)); <span class="hljs-comment">// 返回从第0间房子到第n-1间房子中抢劫能获得的最大金额</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 辅助函数，用于计算从第0间房子到第i间房子中能抢劫的最大金额</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; dp, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果房子索引小于0，返回0（递归基础情况）</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[i] &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果dp[i]已经计算过，直接返回其值（记忆化递归）</span><br>            <span class="hljs-keyword">return</span> dp[i];<br>        &#125;<br>        <br>        <span class="hljs-comment">// 递归计算当前房子能抢到的最大金额，分别考虑抢和不抢两种情况</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">helper</span>(nums, dp, i<span class="hljs-number">-1</span>), <span class="hljs-built_in">helper</span>(nums, dp, i<span class="hljs-number">-2</span>) + nums[i]);<br>        dp[i] = result; <span class="hljs-comment">// 将计算得到的最大金额保存到dp数组中</span><br>        <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 返回当前房子能抢到的最大金额</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p><img src="/2024/06/27/posts/LCR089/image.png" alt="LCR089结果"></p><h3 id="空间复杂度为O（n）的迭代代码"><a href="#空间复杂度为O（n）的迭代代码" class="headerlink" title="空间复杂度为O（n）的迭代代码"></a>空间复杂度为O（n）的迭代代码</h3><p>先求出f（0）和f（1）的值，然后用f（0）和f（1）的值求出f（2），用f（1）和f（2）的值求出f（3），以此类推，直至求出f（n-1）。这种自下而上的思路通常可以用一个for循环实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">1</span>], nums[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p><img src="/2024/06/27/posts/LCR089/image-1.png" alt="LCR089结果"></p><h3 id="空间复杂度为O（1）的迭代代码"><a href="#空间复杂度为O（1）的迭代代码" class="headerlink" title="空间复杂度为O（1）的迭代代码"></a>空间复杂度为O（1）的迭代代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>            dp[i % <span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[(i<span class="hljs-number">-2</span>)%<span class="hljs-number">2</span>]+nums[i], dp[(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><img src="/2024/06/27/posts/LCR089/image-2.png" alt="LCR089结果"></p><h3 id="用两个状态转移方程分析解决问题"><a href="#用两个状态转移方程分析解决问题" class="headerlink" title="用两个状态转移方程分析解决问题"></a>用两个状态转移方程分析解决问题</h3><p>由于小偷到达标号为i的房屋时有两个选择，他可以选择进去偷东西或不进去偷东西，因此可以定义两个表达式f（i）和g（i），其中f（i）表示小偷选择不进入标号为i的房屋偷东西时能偷得的最多财物数量，而g（i）表示小偷选择进入标号为i的房屋偷东西时能偷得的最多财物数量。f（n-1）和g（n-1）的最大值就是小偷能从n幢房屋内偷得的财物的最大值。</p><p>接下来尝试找出f（i）和g（i）的状态转移方程。当小偷选择不进入标号为i的房屋偷东西时，那么他不管是不是进入标号为i-1的房屋偷东西都不会触发报警系统，此时他能偷得的财物数量取决于他从标号为0的房屋开始到标号为i-1的房屋为止能偷得的财物数量，因此f（i）&#x3D;max（f（i-1），g（i-1））。当小偷选择进入标号为i的房屋偷取价值为nums[i]的财物时，那么他一定不能进入标号为i-1的房屋偷东西，否则就会触发报警系统，因此g（i）&#x3D;f（i-1）+nums[i-1]。</p><p>这两个状态转移方程有一个隐含条件，要求i大于0，否则i-1没有意义。当i等于0时，f（0）表示街道上只有标号为0的房屋并且小偷选择不进去偷东西，那么他什么也没有偷到，因此f（0）&#x3D;0。g（0）表示当只有标号为0的房屋并且小偷选择进去偷东西，那么房屋内财物的价值就是小偷能偷取的东西的价值，即g（0）&#x3D;nums[0]。</p><p>由于需要同时计算f（i）和g（i）的值，因此需要两个一维数组。可以将两个一维数组看成一个表格，f（i）是表格的第1行，g（i）是表格的第2行。可以从左到右随着i的递增填满整个表格。首先f（0）初始化为0，g（0）初始化为标号为0的房屋的财物数量，即2。接着由状态转移方程f（1）&#x3D;max（f（0），g（0））得出f（1）的值为2，由g（1）&#x3D;f（0）+nums[1]得出g（1）的值为3。表格内其他的值可以以此类推。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>        <span class="hljs-comment">// 初始化</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            dp[<span class="hljs-number">0</span>][i%<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>], dp[<span class="hljs-number">1</span>][(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>]);<br>            dp[<span class="hljs-number">1</span>][i%<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>]+nums[i], dp[<span class="hljs-number">1</span>][(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][(n<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>], dp[<span class="hljs-number">1</span>][(n<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><img src="/2024/06/27/posts/LCR089/image-3.png" alt="LCR089结果"></p><h2 id="LCR090-环形房屋偷盗"><a href="#LCR090-环形房屋偷盗" class="headerlink" title="LCR090.环形房屋偷盗"></a><a href="https://leetcode.cn/problems/PzWKhm/description/">LCR090.环形房屋偷盗</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>由于这个问题和面试题89的区别在于小偷不能同时到标号为0和n-1的两幢房屋内偷东西。如果他考虑去标号为0的房屋，那么他一定不能去标号为n-1的房屋；如果他考虑去标号为n-1的房屋，那么他一定不能去标号为0的房屋。因此，可以将这个问题分解成两个子问题：一个问题是求小偷从标号为0开始到标号为n-2结束的房屋内能偷得的最多财物数量，另一个问题是求小偷从标号为1开始到标号为n-1结束的房屋内能偷得的最多财物数量。小偷从标号为0开始到标号为n-1结束的房屋内能偷得的最多财物数量是这两个子问题的解的最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 计算能够偷窃的最大金额</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 如果只有一个房屋，则偷窃该房屋</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-comment">// 计算偷窃第一个房屋到倒数第二个房屋时能够偷窃的最大金额</span><br>        <span class="hljs-type">int</span> res1 = <span class="hljs-built_in">helper</span>(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">2</span>);        <br>        <span class="hljs-comment">// 计算偷窃第二个房屋到最后一个房屋时能够偷窃的最大金额</span><br>        <span class="hljs-type">int</span> res2 = <span class="hljs-built_in">helper</span>(nums, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);    <br>        <span class="hljs-comment">// 返回两种情况下的最大金额</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(res1, res2);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 辅助函数，计算从索引start到end之间能够偷窃的最大金额</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果只有一个房屋，则返回该房屋的金额</span><br>        <span class="hljs-keyword">if</span> (start == end) &#123;<br>            <span class="hljs-keyword">return</span> nums[start];<br>        &#125;       <br>        <span class="hljs-comment">// 初始化dp数组，用于存储当前房屋能够偷窃的最大金额</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>        dp[start % <span class="hljs-number">2</span>] = nums[start]; <span class="hljs-comment">// 如果只偷窃第一个房屋</span><br>        dp[(start + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(nums[start], nums[start + <span class="hljs-number">1</span>]); <span class="hljs-comment">// 如果偷窃第一个或第二个房屋        </span><br>        <span class="hljs-comment">// 遍历剩余的房屋，计算能够偷窃的最大金额</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start + <span class="hljs-number">2</span>; i &lt;= end; i++) &#123;<br>            dp[i % <span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>], dp[(i - <span class="hljs-number">2</span>) % <span class="hljs-number">2</span>] + nums[i]);<br>        &#125;        <br>        <span class="hljs-comment">// 返回start到end之间能够偷窃的最大金额</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><img src="/2024/06/27/posts/LCR089/image-4.png" alt="LCR090结果"></p><h2 id="LCR091-粉刷房子"><a href="#LCR091-粉刷房子" class="headerlink" title="LCR091.粉刷房子"></a><a href>LCR091.粉刷房子</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>用动态规划解决问题的关键在于找出状态转移方程。根据粉刷的规则，相邻的两幢房子不能被粉刷成相同的颜色，要计算粉刷到标号为i的房子时的成本，还需要考虑标号为i-1的房子的颜色。因此，需要3个表达式，即r（i）、g（i）、b（i），分别表示将标号为i的房子粉刷成红色、绿色和蓝色时粉刷标号从0到i的i+1幢房子的最少成本。假设粉刷每幢房子的成本用一个二维数组costs表示，那么costs[i]中包含的3个数字分别是将标号为i的房子粉刷成红色、绿色和蓝色的成本。当标号为i的房子被粉刷成红色时，标号为i-1的房子可以被粉刷成绿色或蓝色，因此r（i）&#x3D;min（g（i-1），b（i-1））+costs[i][0]。类似地，当标号为i的房子被粉刷成绿色时，标号为i-1的房子可以被粉刷成红色或蓝色，因此g（i）&#x3D;min（r（i-1），b（i-1））+costs[i][1]；当标号为i的房子被粉刷成蓝色时，标号为i-1的房子可以被粉刷成红色或绿色，因此b（i）&#x3D;min（r（i-1），g（i-1））+costs[i][2]。</p><p>这3个状态转移方程有一个隐含条件，要求i大于0，否则i-1没有意义。当i等于时，r（0）就是将标号为0的房子粉刷成红色的成本costs[0][0]，g（0）就是将标号为0的房子粉刷成绿色的成本costs[0][1]，而b（0）就是将标号为0的房子粉刷成蓝色的成本costs[0][2]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCost</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = costs.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> res = <span class="hljs-built_in">min</span>(costs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], costs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]);<br>            res = <span class="hljs-built_in">min</span>(costs[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>], res);<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">3</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 三行表示r,g,b</span><br>        <span class="hljs-comment">// 初始化</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            dp[<span class="hljs-number">0</span>][i%<span class="hljs-number">2</span>] = <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">1</span>][(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>], dp[<span class="hljs-number">2</span>][(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>]) + costs[i][<span class="hljs-number">0</span>];<br>            dp[<span class="hljs-number">1</span>][i%<span class="hljs-number">2</span>] = <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>], dp[<span class="hljs-number">2</span>][(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>]) + costs[i][<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">2</span>][i%<span class="hljs-number">2</span>] = <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>], dp[<span class="hljs-number">1</span>][(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>]) + costs[i][<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-comment">// 最终结果</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][(n<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>], dp[<span class="hljs-number">1</span>][(n<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>]);<br>        res = <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">2</span>][(n<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>], res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><img src="/2024/06/27/posts/LCR089/image-5.png" alt="LCR091结果"></p><h2 id="LCR092-将字符翻转到单调递增"><a href="#LCR092-将字符翻转到单调递增" class="headerlink" title="LCR092.将字符翻转到单调递增"></a><a href="https://leetcode.cn/problems/cyJERH/description/">LCR092.将字符翻转到单调递增</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>如果前i个字符在翻转某些’0’和’1’之后得到的符合要求的字符串的最后一个字符是’0’，那么无论下标为i的字符是’0’还是’1’，这i+1个字符组成的字符串都是符合要求的。如果前i个字符在翻转某些’0’和’1’之后得到的符合要求的字符串的最后一个字符是’1’，那么必须保证下标为i的字符是’1’，这样才能确保这i+1个字符组成的字符串是符合要求的。</p><p>由于翻转下标为i的字符依赖于前i个字符翻转之后最后一个字符是’0’还是’1’，因此要分为两种情况讨论。假设函数f（i）表示把字符串中从下标为0的字符到下标为i的字符（记为S[0..i]，字符串中前i+1个字符组成的子字符串）变成符合要求的字符串并且最后一个字符是’0’所需要的最少翻转次数。假设函数g（i）表示把字符串中S[0..i]变成符合要求的字符串并且最后一个字符是’1’所需要的最少翻转次数。如果字符串的长度是n，那么f（n-1）和g（n-1）就是翻转整个字符串使字符串符合要求并且最后一个字符分别变成’0’和’1’的最少翻转次数，它们的最小值就是整个问题的解。</p><p>如果翻转之后下标为i的字符是’0’，那么下标为i-1的字符一定是’0’，否则就不满足所有的字符’0’位于’1’的前面的这个要求。当输入字符串中下标为i的字符（即S[i]）是’0’时，这一步不需要翻转，f（i）&#x3D;f（i-1）；当输入字符串中下标为i的字符是’1’时，f（i）&#x3D;f（i-1）+1，因为要把下标为i的字符翻转成’0’。</p><p>如果翻转之后下标为i的字符是’1’，那么无论下标为i-1的字符是’0’还是’1’都满足题目的要求。当输入字符串S[i]是’0’时，g（i）&#x3D;min[f（i-1），g（i-1）]+1，因为要把第i个字符翻转成’1’；当S[i]是’1’时，此时不需要翻转字符，因此g（i）&#x3D;min[f（i-1），g（i-1）]。</p><p>当i等于0时，f（0）和g（0）的值取决于下标为0的字符S[0]。如果S[0]为’0’，那么f（0）的值为0；如果S[0]为’1’，那么f（0）的值为1。g（0）则反之，如果S[0]为’0’，那么g（0）的值为1；如果S[0]为’1’，那么g（0）的值为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minFlipsMonoIncr</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 行代表f和g，列代表i</span><br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 不翻转</span><br>            dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 翻转   </span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 翻转</span><br>            dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 不翻转</span><br>        &#125;<br>        <span class="hljs-comment">// 遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                dp[<span class="hljs-number">0</span>][i%<span class="hljs-number">2</span>] = dp[<span class="hljs-number">0</span>][(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>];    <span class="hljs-comment">// 更新f</span><br>                dp[<span class="hljs-number">1</span>][i%<span class="hljs-number">2</span>] = <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>], dp[<span class="hljs-number">1</span>][(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>]) + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 更新g</span><br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                dp[<span class="hljs-number">0</span>][i%<span class="hljs-number">2</span>] = dp[<span class="hljs-number">0</span>][(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br>                dp[<span class="hljs-number">1</span>][i%<span class="hljs-number">2</span>] = <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>], dp[<span class="hljs-number">1</span>][(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][(n<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>], dp[<span class="hljs-number">1</span>][(n<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><img src="/2024/06/27/posts/LCR089/image-6.png" alt="LCR092结果"></p><h2 id="LCR093-最长的斐波那契数列子序列的长度"><a href="#LCR093-最长的斐波那契数列子序列的长度" class="headerlink" title="LCR093.最长的斐波那契数列子序列的长度"></a><a href="https://leetcode.cn/problems/Q91FMA/description/">LCR093.最长的斐波那契数列子序列的长度</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>由于以A[i]为结尾的斐波那契数列的长度依赖于它前一个数字A[j]，不同的A[j]能和A[i]形成不同的斐波那契数列，它们的长度也可能不同。因此，状态转移方程有两个参数i和j，f（i，j）表示以A[i]为最后一个数字、A[j]为倒数第2个数字的斐波那契数列的长度。如果数组中存在一个数字k，使A[i]&#x3D;A[j]+A[k]（0≤k＜j＜i），那么f（i，j）&#x3D;f（j，k）+1，即在以A[j]为最后一个数字、A[k]为倒数第2个数字的斐波那契数列的基础上增加一个数字A[i]，形成更长的一个数列。f（i，j）的值可能是2，此时虽然A[i]和A[j]这两个数字现在还不能形成一个有效的斐波那契数列，但可能会在之后增加一个新的数字使之形成长度为3甚至更长的斐波那契数列。</p><p>由于状态转移方程有两个参数i和j，因此需要一个二维数组来缓存f（i，j）的计算结果。i对应二维数组的行号，j对应二维数组的列号。由于i大于j，因此实际上只用到了二维数组的左下角部分。如果数组的长度是n，那么i的取值范围为1～n-1，而j的取值范围为0～n-2。</p><p>因为需要查询 A[k] &#x3D; A[i] - A[j] 是否存在，并且需要得到下标 k，所以需要一个哈希表将数组内所有的数字和下标保存下来供查询。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lenLongestFibSubseq</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-comment">// 建立哈希表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            mp[arr[i]] = i;<br>        &#125;<br>        <span class="hljs-comment">// 动态规划表</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n<span class="hljs-number">-1</span>; j++)&#123;<br>                <span class="hljs-type">int</span> temp = arr[i] - arr[j];<br>                <span class="hljs-comment">// 存在k使得A[i] = A[j] + A[k]</span><br>                <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(temp) &amp;&amp; mp[temp] &lt; j)&#123;<br>                    dp[i][j] = dp[j][mp[temp]] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-number">2</span>;<br>                &#125;<br>                res = <span class="hljs-built_in">max</span>(res, dp[i][j]);<br>            &#125;            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res &gt; <span class="hljs-number">2</span> ? res : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：上述代码用到了二重循环，因此时间复杂度是$O(n^2)$。</li><li>空间复杂度由于使用了一个大小为$O(n^2)$的二维数组和一个大小为O(n)的哈希表，因此空间复杂度也是$O(n^2)$。</li></ul><p><img src="/2024/06/27/posts/LCR089/image-7.png" alt="LCR093结果"></p><h2 id="LCR094-分割回文串"><a href="#LCR094-分割回文串" class="headerlink" title="LCR094.分割回文串"></a><a href="https://leetcode.cn/problems/omKAoA/description/">LCR094.分割回文串</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>应用动态规划解决问题的关键在于找出状态转移方程。假设字符串为S，下标为i的字符为S[i]，下标从j到i的子字符串为S[j..i]。用f（i）表示从下标为0到i的子字符串S[0..i]的符合条件的最少分割次数。如果字符串的长度是n，那么f（n-1）就是问题的解。</p><p>如果子字符串S[0..i]本身就是一个回文，那么不需要分割就符合要求，此时f（i）等于0。如果子字符串S[0..i]不是一个回文，那么对每个下标j（1≤j≤i）逐一判断子字符串S[j..i]是不是回文。如果是回文，那么这就是一个有效的分割方法，此时的分割次数相当于子字符串S[0..j-1]的分割次数再加1，因为这是将子字符串S[0..j-1]按照要求分割之后再在S[j-1]和S[j]这两个字符中间再分割一次。因此，f（i）就是所有符合条件的j对应的f（j-1）的最小值加1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// 确定回文</span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();  <span class="hljs-comment">// 字符串的长度</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">isPalindrome</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));  <span class="hljs-comment">// 二维数组用于记录从第i到第j个字符是否为回文</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;  <span class="hljs-comment">// 遍历字符串s的每个字符</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++)&#123;  <span class="hljs-comment">// j从0到i遍历，检查s[j]到s[i]是否为回文串</span><br>                <span class="hljs-keyword">if</span>(s[i] == s[j] &amp;&amp; (i &lt;= j+<span class="hljs-number">1</span> || isPalindrome[j+<span class="hljs-number">1</span>][i<span class="hljs-number">-1</span>]))&#123;<br>                    <span class="hljs-comment">// 如果s[i]等于s[j]，并且s[j+1]到s[i-1]也是回文，则s[j]到s[i]是回文串</span><br>                    isPalindrome[j][i] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 动态规划</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// dp数组，dp[i]表示s[0]到s[i]的最小切割次数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;  <span class="hljs-comment">// 遍历每个字符</span><br>            <span class="hljs-comment">// 如果s[0]到s[i]本身就是回文串，无需切割</span><br>            <span class="hljs-keyword">if</span>(isPalindrome[<span class="hljs-number">0</span>][i])&#123;<br>                dp[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 如果不是回文串，则初始化dp[i]为最大可能切割次数，即i</span><br>                dp[i] = i;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;  <span class="hljs-comment">// j从1到i遍历</span><br>                    <span class="hljs-keyword">if</span>(isPalindrome[j][i])&#123;<br>                        <span class="hljs-comment">// 如果s[j]到s[i]是回文串，则更新dp[i]为dp[j-1] + 1的最小值</span><br>                        dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);<br>                    &#125;                    <br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];  <span class="hljs-comment">// 返回s[0]到s[n-1]的最小切割次数</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：代码需要两个二重循环，第1个二重循环做预处理是为了判断每个子字符串是不是回文。长度为n的子字符串有$O(n^2)$个子字符串，因此至少需要$O(n^2)$的时间才能判断所有的子字符串是不是回文。第2个二重循环是为了计算状态转移方程，时间复杂度也是$O(n^2)$。因此，上述解法的总体时间复杂度是$O(n^2)$。</li><li>空间复杂度：上述代码使用了两个数组，一个是大小为$O(n^2)$的二维数组，另一个是大小为O（n）的一维数组dp，因此总的空间复杂度是$O(n^2)$。</li></ul><p><img src="/2024/06/27/posts/LCR089/image-8.png" alt="LCR094结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单序列问题是与动态规划相关的问题中最有可能在算法面试中遇到的题型。这类题目都有适合运用动态规划的问题的特点，如解决问题需要若干步骤，并且每个步骤都面临若干选择，需要计算解的数目或最优解。除此之外，这类题目的输入通常是一个序列，如一个一维数组或字符串。</p><p>应用动态规划解决单序列问题的关键是每一步在序列中增加一个元素，根据题目的特点找出该元素对应的最优解（或解的数目）和前面若干元素（通常是一个或两个）的最优解（或解的数目）的关系，并以此找出相应的状态转移方程。一旦找出了状态转移方程，只要注意避免不必要的重复计算，问题就能迎刃而解。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR088动态规划的基础知识</title>
    <link href="/2024/06/24/posts/LCR088/"/>
    <url>/2024/06/24/posts/LCR088/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）14-1-动态规划的基础知识"><a href="#剑指offer（专项突破版）14-1-动态规划的基础知识" class="headerlink" title="剑指offer（专项突破版）14.1 动态规划的基础知识"></a>剑指offer（专项突破版）14.1 动态规划的基础知识</h1><p>和适合运用回溯法的问题类似，适用动态规划的问题都存在若干步骤，并且每个步骤都面临若干选择。如果题目要求列举出所有的解，那么很有可能需要用回溯法解决。如果题目是求一个问题的最优解（通常是求最大值或最小值），或者求问题的解的数目（或判断问题是否存在解），那么这个题目有可能适合运用动态规划。</p><p>分治法也是采用递归思路把大问题分解成小问题。例如，快速排序算法就是采用分治法。分治法将大问题分解成小问题之后，小问题之间没有重叠的部分。</p><p>如果将大问题分解成若干小问题之后，小问题相互重叠，那么直接用递归的代码实现就会存在大量重复计算。小问题之间存在重叠的部分，这是可以运用动态规划求解问题的另一个显著特点。</p><p>在用代码实现动态规划的算法时，如果采用递归的代码按照从上往下的顺序求解，那么每求出一个小问题的解就缓存下来，这样下次再遇到相同的小问题就不用重复计算。另一个实现动态规划算法的方法是按照从下往上的顺序，从解决最小的问题开始，并把已经解决的小问题的解存储下来（大部分面试题都存储在一维数组或二维数组中），然后把小问题的解组合起来逐步解决大问题。</p><h2 id="LCR088-使用最小花费爬楼梯"><a href="#LCR088-使用最小花费爬楼梯" class="headerlink" title="LCR088.使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/GzCJIP/description/">LCR088.使用最小花费爬楼梯</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>爬上一个有多级台阶的楼梯自然需要若干步。按照题目的要求，每次爬的时候既可以往上爬1级台阶，也可以爬2级台阶，也就是每一步都有两个选择。这看起来像是与回溯法有关的问题。但这个问题不是要找出有多少种方法可以爬上楼梯，而是计算爬上楼梯的最少成本，即计算问题的最优解，因此解决这个问题更适合运用动态规划。</p><p>分析确定状态转移方程:</p><p>$$<br>f(i) &#x3D; \begin{cases}<br>  min（f（i-1），f（i-2））+cost[i] &amp; \text{if } i \geq 2 \<br>  cost[i] &amp; \text{if } i &lt; 2<br>\end{cases}<br>$$</p><h3 id="直接递归"><a href="#直接递归" class="headerlink" title="直接递归"></a>直接递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = cost.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">helper</span>(cost, n<span class="hljs-number">-1</span>), <span class="hljs-built_in">helper</span>(cost, n<span class="hljs-number">-2</span>));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost, <span class="hljs-type">int</span> index)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> cost[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">helper</span>(cost, index<span class="hljs-number">-1</span>), <span class="hljs-built_in">helper</span>(cost, index<span class="hljs-number">-2</span>)) + cost[index];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>超出时间限制，无法通过所有测试点。</p><ul><li>时间复杂度：因为由于重叠子问题，它执行了大量重复的计算，$O(2^n)$</li><li>空间复杂度：取决于递归调用的深度，在最坏情况下，递归深度可以达到n，每个递归调用都会使用额外的空间来存储其调用栈，因此为$O(n)$.</li></ul><h3 id="使用缓存的递归代码"><a href="#使用缓存的递归代码" class="headerlink" title="使用缓存的递归代码"></a>使用缓存的递归代码</h3><p>由于执行了大量重复计算，如图所示，计算f(8)和f(7)都要计算f(6)。</p><p><img src="/2024/06/24/posts/LCR088/00309.jpeg" alt="tree"></p><p>为了避免重复计算带来的问题，一个常用的解决办法是将已经求解过的问题的结果保存下来。在每次求解一个问题之前，应先检查该问题的求解结果是否已经存在。如果问题的求解结果已经存在，则不再重复计算，只需要从缓存中读取之前求解的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = cost.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-built_in">helper</span>(cost, dp, n<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">helper</span>(cost, dp, n<span class="hljs-number">-2</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[n<span class="hljs-number">-1</span>], dp[n<span class="hljs-number">-2</span>]);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;cost, vector&lt;<span class="hljs-type">int</span>&gt;&amp; dp, <span class="hljs-type">int</span> i)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">2</span>)&#123;<br>            dp[i] = cost[i];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[i] == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">helper</span>(cost, dp, i<span class="hljs-number">-1</span>);<br>            <span class="hljs-built_in">helper</span>(cost, dp, i<span class="hljs-number">-2</span>);<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>]) + cost[i];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：每个问题f（i）只需要求解一次。如果楼梯有n级台阶，那么上述代码的时间复杂度是O（n）。</li><li>空间复杂度：需要一个长度为n的数组，因此空间复杂度也是O（n）。</li></ul><p><img src="/2024/06/24/posts/LCR088/image.png" alt="使用缓存的递归代码结果"></p><h3 id="空间复杂度为O（n）的迭代代码"><a href="#空间复杂度为O（n）的迭代代码" class="headerlink" title="空间复杂度为O（n）的迭代代码"></a>空间复杂度为O（n）的迭代代码</h3><p>也可以自下而上地解决这个过程，也就是从子问题入手，根据两个子问题f（i-1）和f（i-2）的解求出f（i）的结果。通常用迭代的代码实现自下而上的求解过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = cost.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>]) + cost[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[n<span class="hljs-number">-1</span>], dp[n<span class="hljs-number">-2</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p><img src="/2024/06/24/posts/LCR088/image-1.png" alt="迭代代码结果"></p><h3 id="空间复杂度为O（1）的迭代代码"><a href="#空间复杂度为O（1）的迭代代码" class="headerlink" title="空间复杂度为O（1）的迭代代码"></a>空间复杂度为O（1）的迭代代码</h3><p>上述迭代代码还能做进一步的优化。前面用一个长度为n的数组将所有f（i）的结果都保存下来。求解f（i）时只需要f（i-1）和f（i-2）的结果，从f（0）到f（i-3）的结果其实对求解f（i）并没有任何作用。也就是说，在求每个f（i）的时候，需要保存之前的f（i-1）和f（i-2）的结果，因此只要一个长度为2的数组即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = cost.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> step1 = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 表示状态 f(i-1)</span><br>        <span class="hljs-type">int</span> step2 = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 表示状态 f(i-2)</span><br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            cur = <span class="hljs-built_in">min</span>(step1 + cost[i<span class="hljs-number">-1</span>], step2 + cost[i<span class="hljs-number">-2</span>]);<br>            step2 = step1;<br>            step1 = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><img src="/2024/06/24/posts/LCR088/image-2.png" alt="空间复杂度为O(1)的迭代代码"></p><h2 id="比较四种解法"><a href="#比较四种解法" class="headerlink" title="比较四种解法"></a>比较四种解法</h2><p>上面用4种不同的方法解决这个问题。第1种解法在找出状态转移方程之后直接将其转换成递归代码，由于计算过程存在大量的重复计算，因此时间复杂度呈指数级增长，使用这种解法的应聘者通常无法通过编程面试。</p><p>第2种解法在第1种解法的基础上添加了一个一维数组，用来缓存已经求解的结果。有了这个长度为O（n）的数组，缓存之后就能够确保每个子问题只需要计算一次，因此时间复杂度是O（n）。</p><p>和第2种解法类似，第3种解法的时间复杂度和空间复杂度也都是O（n），但它们有两方面显著的不同。一是求解的顺序不同。第2种解法从大的子问题出发，即采用自上而下的顺序求解；而第3种解法从子问题出发，即采用自下而上的顺序求解。二是代码实现的思路不同。第2种解法采用递归代码实现算法，而第3种解法采用循环代码实现算法。通常，第2种解法和第3种解法都能达到算法面试的要求。</p><p>第4种解法在第3种解法的基础上进一步优化空间效率，使空间效率变成O（1）。如果在面试过程中能够想出第4种解法并且能写出正确的代码，那么应聘者毫无疑问能通过这轮面试并为之后的薪资谈判增加砝码。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR085-LCR087使用回溯法解决其他类型的问题</title>
    <link href="/2024/06/21/posts/LCR085/"/>
    <url>/2024/06/21/posts/LCR085/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）13-3-使用回溯法解决其他类型的问题"><a href="#剑指offer（专项突破版）13-3-使用回溯法解决其他类型的问题" class="headerlink" title="剑指offer（专项突破版）13.3 使用回溯法解决其他类型的问题"></a>剑指offer（专项突破版）13.3 使用回溯法解决其他类型的问题</h1><h2 id="LCR085-括号生成"><a href="#LCR085-括号生成" class="headerlink" title="LCR085.括号生成"></a><a href="https://leetcode.cn/problems/IDBivT/description/">LCR085.括号生成</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果输入n，那么生成的括号组合包含n个左括号和n个右括号。因此生成这样的组合需要2n步，每一步生成一个括号。每一步都面临两个选项，既可能生成左括号也可能生成右括号。由此来看，这个问题很适合采用回溯法解决。</p><p>在生成括号组合时需要注意每一步都要满足限制条件。第1个限制条件是左括号或右括号的数目不能超过n个。第2个限制条件是括号的匹配原则，即在任意步骤中已经生成的右括号的数目不能超过左括号的数目。例如，如果在已经生成”()”之后再生成第3个括号，此时第3个括号只能是左括号不能是右括号。如果第3个是右括号，那么组合变成”()）”，由于右括号的数目超过左括号的数目，之后不管怎么生成后面的括号，这个组合的左括号和右括号都不能匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-built_in">helper</span>(n, n, <span class="hljs-string">&quot;&quot;</span>, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, string s, vector&lt;string&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 选择左括号</span><br>        <span class="hljs-keyword">if</span>(left &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">helper</span>(left<span class="hljs-number">-1</span>, right, s+<span class="hljs-string">&quot;(&quot;</span>, res);<br>        &#125;<br>        <span class="hljs-comment">// 选择右括号</span><br>        <span class="hljs-keyword">if</span>(left &lt; right)&#123;<br>            <span class="hljs-built_in">helper</span>(left, right<span class="hljs-number">-1</span>, s+<span class="hljs-string">&quot;)&quot;</span>, res);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：在最坏情况下，对于一个给定的 n，递归调用次数是 Catalan number，约为$\frac{4^n}{n^\frac{3}{2}\sqrt{\pi}}$次。因此时间复杂度为$\frac{4^n}{\sqrt{n}}$。</li><li>空间复杂度：最多需要存储2n个字符，即O(n)。</li></ul><p><img src="/2024/06/21/posts/LCR085/image.png" alt="LCR085结果"></p><h2 id="LCR086-分割回文串"><a href="#LCR086-分割回文串" class="headerlink" title="LCR086.分割回文串"></a><a href="https://leetcode.cn/problems/M99OJA/description/">LCR086.分割回文串</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>当处理到字符串中的某个字符时，如果包括该字符在内后面还有n个字符，那么此时面临n个选项，即分割出长度为1的子字符串（只包含该字符）、分割出长度为2子字符串（即包含该字符及它后面的一个字符），以此类推，分割出长度为n的子字符串（即包含该字符在内的后面的所有字符）。由于题目要求分割出来的每个子字符串都是回文，因此需要逐一判断这n个子字符串是不是回文，只有回文子字符串才是符合条件的分割。分割出一段回文子字符串之后，接着分割后面的字符串。</p><p>例如，输入字符串”google”，假设处理到第1个字符’g’。此时包括字符’g’在内后面一共有6个字符，所以此时面临6个选项，即可以分割出6个以字符’g’开头的子字符串，分别为”g”、”go”、”goo”、”goog”、”googl”和”google”，其中只有”g”和”goog”是回文子字符串。分割出”g”和”goog”这两个回文子字符串之后，再用同样的方法分割后面的字符串。</p><p>解决这个问题同样需要很多步，每一步分割出一个回文子字符串。如果处理到某个字符时包括该字符在内后面有n个字符，就面临n个选项。这也是一个典型的适用回溯法的场景。通常用递归的代码实现回溯法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        vector&lt;string&gt; cur;<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        <span class="hljs-built_in">helper</span>(s, <span class="hljs-number">0</span>, cur, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> index, vector&lt;string&gt;&amp; cur, vector&lt;vector&lt;string&gt;&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(index == s.<span class="hljs-built_in">length</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(cur);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 从当前index开始，尝试每一个可能的结束索引</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt; s.<span class="hljs-built_in">length</span>(); i++)&#123;<br>            <span class="hljs-comment">// 如果当前子串是回文串</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isPalindrom</span>(s, index, i))&#123;<br>                string str = s.<span class="hljs-built_in">substr</span>(index, i-index+<span class="hljs-number">1</span>);<br>                cur.<span class="hljs-built_in">push_back</span>(str);<br>                <span class="hljs-built_in">helper</span>(s, i+<span class="hljs-number">1</span>, cur, res);<br>                cur.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 尝试新的结束索引</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 判断是否是回文子串</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrom</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-keyword">if</span>(s[left++] != s[right--])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>举例说明：</p><p>假设字符串 s &#x3D; “aab”，以下是算法的部分执行过程：</p><pre><code class="hljs">第一次递归调用：    index = 0，cur = []    尝试 i = 0，子串 s[0:1] = &quot;a&quot; 是回文：        cur.push_back(&quot;a&quot;)，cur = [&quot;a&quot;]        递归调用 helper(s, 1, ret, cur)第二次递归调用：    index = 1，cur = [&quot;a&quot;]    尝试 i = 1，子串 s[1:2] = &quot;a&quot; 是回文：        cur.push_back(&quot;a&quot;)，cur = [&quot;a&quot;, &quot;a&quot;]        递归调用 helper(s, 2, ret, cur)第三次递归调用：    index = 2，cur = [&quot;a&quot;, &quot;a&quot;]    尝试 i = 2，子串 s[2:3] = &quot;b&quot; 是回文：        cur.push_back(&quot;b&quot;)，cur = [&quot;a&quot;, &quot;a&quot;, &quot;b&quot;]        递归调用 helper(s, 3, ret, cur)达到字符串末尾：    index = 3，已达到字符串末尾，当前结果 [&quot;a&quot;, &quot;a&quot;, &quot;b&quot;] 是一个完整的回文划分：        ret.emplace_back(cur)        回溯，cur.pop_back()，cur = [&quot;a&quot;, &quot;a&quot;]继续回溯和尝试：    回到第二次递归调用，继续尝试 i = 2，但是 s[1:3] = &quot;ab&quot; 不是回文：        回溯，cur.pop_back()，cur = [&quot;a&quot;]再回溯和继续尝试：    回到第一次递归调用，继续尝试 i = 1，但是 s[0:2] = &quot;aa&quot; 是回文：        cur.push_back(&quot;aa&quot;)，cur = [&quot;aa&quot;]        递归调用 helper(s, 2, ret, cur)</code></pre><ul><li>时间复杂度：<ul><li>每个字符都有可能作为一个划分点，这意味着我们最多有$2^n$种不同的划分方式。这是因为每个字符前都可以选择划分或不划分，总共有n−1个位置可供选择，形成$2^(n−1)≈2^n$种组合。</li><li><code>isPalindrom</code> 函数检查一个子串是否为回文，其时间复杂度是 O(n)，因为需要线性扫描子串的每个字符。</li><li>总体的时间复杂度为$O(n \cdot {2^n})$</li></ul></li><li>空间复杂度：<ul><li>最深的递归深度是字符串的长度n，因为每次递归调用中，我们至少处理一个字符。每层递归调用都会在栈上保存一些状态信息，因此递归栈的空间复杂度是O(n)。</li><li>最坏情况下，所有划分结果的总数是$2^n$，每个结果包含的字符串总长度为n。因此，存储所有划分结果的空间复杂度是$O(n \cdot 2^n)$。</li></ul></li></ul><p><img src="/2024/06/21/posts/LCR085/iXIGum2XjQ.jpg" alt="LCR086结果"></p><h2 id="LCR087-复原IP地址"><a href="#LCR087-复原IP地址" class="headerlink" title="LCR087.复原IP地址"></a><a href="https://leetcode.cn/problems/0on3uN/description/">LCR087.复原IP地址</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>针对字符串中的每个数字，通常面临两个选项。第1个选项是将当前字符拼接到当前分段数字的末尾，拼接之后的数字应该在0到255之间。第2个选项是当前字符作为一个新的分段数字的开始。需要注意的是，一个IP地址最多只有4个分段数字，并且当开始一个新的分段数字时前一个分段数字不能是空的。</p><p>如果输入的字符串的长度为n，由于逐一处理字符串中的每个字符，因此需要n步，并且每一步都面临两个可能的选项。由此可见，这个题目也适合采用回溯法解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-built_in">helper</span>(s, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> index, string seg, <span class="hljs-type">int</span> segI, string ip, vector&lt;string&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 加入结果集</span><br>        <span class="hljs-keyword">if</span>(index == s.<span class="hljs-built_in">length</span>() &amp;&amp; segI == <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">isValid</span>(seg))&#123;<br>            res.<span class="hljs-built_in">push_back</span>(ip + seg);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index &lt; s.<span class="hljs-built_in">length</span>() &amp;&amp; segI &lt;= <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-type">char</span> ch = s[index];<br>            <span class="hljs-comment">// 后续字符加到当前子段</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(seg + ch))&#123;<br>                <span class="hljs-built_in">helper</span>(s, index+<span class="hljs-number">1</span>, seg+ch, segI, ip, res);<br>            &#125;<br>            <span class="hljs-comment">// 重新开启新子段</span><br>            <span class="hljs-keyword">if</span>(seg.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; segI &lt; <span class="hljs-number">3</span>)&#123;<br>                <span class="hljs-built_in">helper</span>(s, index+<span class="hljs-number">1</span>, <span class="hljs-built_in">string</span>(<span class="hljs-number">1</span>, ch), segI+<span class="hljs-number">1</span>, ip + seg + <span class="hljs-string">&quot;.&quot;</span>, res);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 判断当前子段是否合法</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string seg)</span></span>&#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-built_in">stoi</span>(seg);<br>        <span class="hljs-keyword">if</span>(num &lt;= <span class="hljs-number">255</span> &amp;&amp; (seg == <span class="hljs-string">&quot;0&quot;</span> || seg[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;0&#x27;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(2^n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="/2024/06/21/posts/LCR085/image-1.png" alt="LCR087结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了用回溯法解决各类典型面试题。如果解决一个问题需要若干步骤，并且在每一步都面临若干选项，那么可以尝试用回溯法解决这个问题。适用回溯法的问题的一个特点是解决这个问题存在多个解，而题目往往要求列出所有的解。</p><p>应用回溯法能够解决集合的排列、组合的很多问题。仔细分析这些问题及其变种的代码就会发现最终的代码大同小异，都可以采用递归的代码实现。递归代码需要先确定递归退出的边界条件，然后逐个处理集合中的元素。对于组合类问题，每个数字都面临两个选项，即添加当前数字到组合中或不添加当前数字到组合中。对于排列类问题，一个数字如果后面有n个数字，那么面临n+1个选择，即可以将该数字和它后面的数字（也包括它自身）交换。根据这些选项做出选择之后再调用递归函数处理后面的数字。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>回溯法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研一小记</title>
    <link href="/2024/06/19/diaries/firstyear/"/>
    <url>/2024/06/19/diaries/firstyear/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="研一小记"><a href="#研一小记" class="headerlink" title="研一小记"></a>研一小记</h1><p>今天考完试了，我的研一生活基本上算是结束了。最近复习得很累，连说话打字的力气都没有了。算法题从上周一开始复习后就没有再刷了，明天要捡起来了。这周把这些作业写完，方案出出来，下周要开始学自己想学的东西了。</p><p>没想到研究生生活是这样的，不知道该从何说起。好像，一年前，我还是坚定读博的，现在，只想能赶紧毕业了。</p><p>感受到时间流逝，就会感受到自己什么都没学会，一点长进都没有，还养成了一堆坏习惯。我总是没完没了地列计划，但从不执行，于是越来越失落，越来越焦虑。前两天想着预约一下学校的心理医生了，每当想到毕业，想到工作，就会有席卷全身的焦虑。</p><p>那天看到弟弟小时候的一个视频，他说他的梦想是当宇航员。可是现在呢，他眼睛近视了，学习也没有那么好，也不再提起“梦想”。我是从什么时候开始变成这样的？</p><p>但是收拾东西的时候看到纸上密密麻麻的字，VSCode里的笔记，就连药都吃了五盒了，好像也不是什么都没干吧。</p><p>要是每天都过得很充实，应该就不会太焦虑了吧。</p><blockquote><p>也许他们会明白莫泊桑的一句话</p><p>生活可能不像你想象的那么好</p><p>但是也不会像你想象的那么糟</p><p>人的脆弱和坚强都超乎了自己的想象</p><p>有时候可能脆弱得一句话就泪流满面</p><p>有时候你发现自己咬着牙</p><p>已经走过了很长的路</p><p>人生当中总是有你能力所不及的范围</p><p>但是如果在你能力所及的范畴内</p><p>你尽到了全部的努力</p><p>那你还有什么可遗憾的呢</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LCR079-LCR084集合的组合、排列</title>
    <link href="/2024/06/06/posts/LCR079/"/>
    <url>/2024/06/06/posts/LCR079/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）13-2-集合的组合、排列"><a href="#剑指offer（专项突破版）13-2-集合的组合、排列" class="headerlink" title="剑指offer（专项突破版）13.2 集合的组合、排列"></a>剑指offer（专项突破版）13.2 集合的组合、排列</h1><h2 id="LCR079-子集"><a href="#LCR079-子集" class="headerlink" title="LCR079.子集"></a><a href="https://leetcode.cn/problems/TVdhkn/description/">LCR079.子集</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果集合中共有 n 个元素，那么确定集合的子集共需要 n 步。每一步都需要从集合中取出一个元素，这时候存在两个选择，添加当前数字或者不添加。生成一个子集需要若干步，并且每一步都有若干种选择，这是应用回溯法的典型问题。</p><p>递归函数helper一共有4个参数。第1个参数是数组nums，它包含输入集合的所有数字。可以逐一从集合中取出一个数字并选择是否将该数字添加到子集中。第2个参数index是当前取出的数字在数组nums中的下标。第3个参数subset是当前子集，而第4个参数result是所有已经生成的子集。</p><p>每当从数组nums中取出一个下标为index的数字时，都要考虑是否将该数字添加到子集subset中。首先需要考虑不将该数字添加到子集的情形。由于不打算将该数字添加到子集中，因此不对子集进行任何操作，只需要调用递归函数helper处理数组nums中的下一个数字（下标增加1）就可以。</p><p>接着考虑将下标为index的数字添加到子集subset的情形。在将该数字添加到子集之后，接下来调用递归函数处理数组nums中的下一个数字（下标增加1）。等递归函数执行完成之后，函数helper也执行完成，接下来将回到前一个数字的函数调用处继续执行。</p><p>在回溯到父节点之前，应该清除已经对子集状态进行的修改。此前在子集subset中添加了一个数字，此时应该将它删除。</p><p>当index等于数组nums的长度时，表示数组中的所有数字都已经处理过，因此已经生成了一个子集，于是将子集subset添加到result中。需要注意的是，在result中添加的是subset的一个拷贝，而不是subset本身。这是因为接下来还需要修改subset以便得到其他的子集，同时避免已经添加到result中的子集被修改。在result中添加subset的拷贝可以避免不必要的修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; cur;<br>        <span class="hljs-built_in">helper</span>(nums, <span class="hljs-number">0</span>, cur, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> index, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cur, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 递归结束：当index等于数组nums的长度时，表示数组中的所有数字都已经处理过</span><br>        <span class="hljs-keyword">if</span>(index == nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(cur);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 不加入第index个数字</span><br>        <span class="hljs-built_in">helper</span>(nums, index+<span class="hljs-number">1</span>, cur, res);<br><br>        <span class="hljs-comment">// 加入第index个数字</span><br>        cur.<span class="hljs-built_in">push_back</span>(nums[index]);<br>        <span class="hljs-built_in">helper</span>(nums, index+<span class="hljs-number">1</span>, cur, res);<br>        <span class="hljs-comment">// 在回溯到父节点之前，应该清除已经对子集状态进行的修改</span><br>        cur.<span class="hljs-built_in">pop_back</span>();<br>     &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：如果输入的集合中有n个元素，由于每个元素都有2个选项，因此总的时间复杂度是$O(2^n)$。</li><li>空间复杂度：res存储所有子集，因此空间复杂度为$O(2^n)$。</li></ul><p><img src="/2024/06/06/posts/LCR079/image.png" alt="LCR079结果"></p><h2 id="LCR080-组合"><a href="#LCR080-组合" class="headerlink" title="LCR080.组合"></a><a href="https://leetcode.cn/problems/uUsW3B/description/">LCR080.组合</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>和上一题思路相同，只是要求每个子集的长度为k。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; cur;<br>        <span class="hljs-built_in">helper</span>(n, k, <span class="hljs-number">1</span>, cur, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> index, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cur, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span></span>&#123;        <br>        <span class="hljs-comment">// 当前子集长度为k</span><br>        <span class="hljs-keyword">if</span>(cur.<span class="hljs-built_in">size</span>() == k)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(cur);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 数字遍历完 </span><br>        <span class="hljs-keyword">if</span>(index &gt; n)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 不加入index</span><br>        <span class="hljs-built_in">helper</span>(n, k, index+<span class="hljs-number">1</span>, cur, res);<br>        <span class="hljs-comment">// 加入index</span><br>        cur.<span class="hljs-built_in">push_back</span>(index);<br>        <span class="hljs-built_in">helper</span>(n, k, index+<span class="hljs-number">1</span>, cur, res);<br>        cur.<span class="hljs-built_in">pop_back</span>();<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(2^n)$</li><li>空间复杂度：$O(n+k⋅C(n,k))O(n+k⋅C(n,k))$</li></ul><p><img src="/2024/06/06/posts/LCR079/image-1.png" alt="LCR080结果"></p><h2 id="LCR081-组合总和"><a href="#LCR081-组合总和" class="headerlink" title="LCR081.组合总和"></a><a href="https://leetcode.cn/problems/Ygoe9J/description/">LCR081.组合总和</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>每一步都从集合中取出一个下标为i的数字，此时面临两个选择。一个选择是跳过这个数字不将该数字添加到组合中，那么这一步实际上什么都不做，接下来处理下标为i+1的数字。另一个选择是将数字添加到组合中，由于一个数字可以重复在组合中出现，也就是说，下一步可能再次选择同一个数字，因此下一步仍然处理下标为i的数字。</p><p>解决这个问题的代码和之前的代码大同小异，最主要的不同在于当选择将数组nums下标为i的数字添加到组合combination中之后，由于nums[i]这个数字可能在组合中重复出现，因此递归调用函数helper时第3个参数传入的值仍然是i，这个参数没有变化，下一步仍然处理数组nums下标为i的数字。</p><p>应用回溯法解决问题时如果有可能应尽可能剪枝以优化时间效率。由于题目明确指出数组中的所有数字都是正整数，因此当组合中已有数字之和已经大于目标值时（递归函数helper的参数target的值小于0时）就没有必要再考虑数组中还没有处理的数字，因为再在组合中添加任意正整数元素之后和会更大，一定找不到新的符合条件的组合，也就没必要再继续尝试。这是函数helper中else if的条件中补充了一个target大于0的判断条件的原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; cur;<br>        <span class="hljs-built_in">helper</span>(candidates, <span class="hljs-number">0</span>, target, cur, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cur, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 达到目标，将当前子集加入结果集</span><br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(cur);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; <span class="hljs-number">0</span> &amp;&amp; index &lt; candidates.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-comment">// 不加入当前数字</span><br>            <span class="hljs-built_in">helper</span>(candidates, index+<span class="hljs-number">1</span>, target, cur, res);<br>            <span class="hljs-comment">// 加入当前数字</span><br>            cur.<span class="hljs-built_in">push_back</span>(candidates[index]);<br>            <span class="hljs-built_in">helper</span>(candidates, index, target-candidates[index], cur, res);<br>            cur.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：取决于所有可行解的长度之和，$O(n * 2^n)$是一个较为宽松的上界。</li><li>空间复杂度：O(target)。</li></ul><p><img src="/2024/06/06/posts/LCR079/image-2.png" alt="LCR081结果"></p><blockquote><p>[!NOTE]举一反三<br>虽然上面几个题目看起来都是关于数学上的组合、集合，其实这些模型可以应用到很多其他问题中。例如，当客人走进餐馆准备吃饭时，服务员会为客人提供一个菜单，菜单上有所有菜品的价格。如果每道菜只点一份，那么客人有哪些不同的点菜方法刚好将身上的钱全部用完？如果客人只想点k道菜，那么又有哪些不同的点菜方法可以将身上的钱全部用完？如果一道菜可以点任意多份呢？</p><p>一种点菜的方法就是生成一个符合条件（菜的总额为客人身上所有的钱）的组合。如果每道菜只点一份，那么就是找出所有符合条件的组合；如果总共只能点k道菜，那么就是找出包含k个元素的所有符合条件的组合；如果每道菜可以点任意多份，那么就是找出允许选择重复元素的符合条件的组合。</p></blockquote><h2 id="LCR082-组合总和II"><a href="#LCR082-组合总和II" class="headerlink" title="LCR082.组合总和II"></a><a href="https://leetcode.cn/problems/4sjJUc/description/">LCR082.组合总和II</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>为了方便跳过后面所有值相同的数字，可以将集合中的所有数字排序，把相同的数字放在一起，这样方便比较数字。当决定跳过某个值的数字时，可以按顺序扫描后面的数字，直到找到不同的值为止。当决定跳过数字nums[i]时可以调用函数getNext找到与该数字不同的下一个数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; cur;<br>        <span class="hljs-comment">// 对数组排序</span><br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">helper</span>(candidates, target, <span class="hljs-number">0</span>, cur, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cur, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 达到目标</span><br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(cur);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; <span class="hljs-number">0</span> &amp;&amp; index &lt; candidates.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-comment">// 不加入当前数字</span><br>            <span class="hljs-built_in">helper</span>(candidates, target, <span class="hljs-built_in">getNext</span>(candidates, index), cur, res);<br>            <span class="hljs-comment">// 加入当前数字</span><br>            cur.<span class="hljs-built_in">push_back</span>(candidates[index]);<br>            <span class="hljs-built_in">helper</span>(candidates, target-candidates[index], index+<span class="hljs-number">1</span>, cur, res);<br>            cur.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNext</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> index)</span></span>&#123;<br>        <span class="hljs-type">int</span> next = index + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(next &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; candidates[next] == candidates[index])&#123;<br>            next++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(2^n * n)$</li><li>空间复杂度：$O(n)$</li></ul><p><img src="/2024/06/06/posts/LCR079/image-3.png" alt="LCR082结果"></p><h2 id="LCR083-全排列"><a href="#LCR083-全排列" class="headerlink" title="LCR083.全排列"></a><a href="https://leetcode.cn/problems/VvJkup/">LCR083.全排列</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>排列和组合不同，排列与元素的顺序相关，交换数字能够得到不同的排列。生成全排列的过程，就是交换输入集合中元素的顺序以得到不同的排列。</p><p>下面以输入集合[1，2，3]为例分析生成全排列的过程。先考虑排列的第1个数字。数字1可以是排列的第1个数字；同样，数字2、3也可以是排列的第1个数字。因此，当生成排列的第1个数字时会面临3个选项，即可以分别选择1、2或3。选择某个数字作为排列的第1个数字之后接下来生成排列的第2个数字。假设选择数字3成为排列的第1个数字，那么生成第2个数字时就面临两个选项，即数字1或2都有可能成为排列的第2个数字。接下来生成排列的第3个数字。由于已经选择了两个数字作为排列的前两个数字，因此到第3个数字时只剩下1个数字，此时也就只有1个选项。</p><p>如果输入的集合中有n个元素，那么生成一个全排列需要n步。当生成排列的第1个数字时会面临n个选项，即n个数字都有可能成为排列的第1个数字。生成排列的第1个数字之后接下来生成第2个数字，此时面临n-1个选项，即剩下的n-1个数字都有可能成为第2个数字。然后以此类推，直到生成最后一个数字，此时只剩下1个数字，也就只有1个选项。看起来解决这个问题可以分成n步，而且每一步都面临若干选项，这是典型的适用回溯法的场景。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">helper</span>(nums, <span class="hljs-number">0</span>, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> index, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 一次全排列</span><br>        <span class="hljs-keyword">if</span>(index == nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(nums);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 从当前index开始，依次将每个元素放在index位置，然后递归处理其余元素的排列</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = index; j &lt; nums.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-built_in">swap</span>(nums[index], nums[j]);<br>                <span class="hljs-built_in">helper</span>(nums, index+<span class="hljs-number">1</span>, res);<br>                <span class="hljs-built_in">swap</span>(nums[index], nums[j]);<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：假设数组nums的长度为n，当index等于0时递归函数helper中的for循环执行n次，当index等于1时for循环执行n-1次，以此类推，当index等于n-1时，for循环执行1次。每一层递归的<code>for</code>循环总次数为<code>n * (n-1) * ... * 1</code>因此，全排列的时间复杂度是O（n！）。</li><li>空间复杂度：用于存储所有排列结果的二维向量。其空间复杂度是O(n×n!)，因为有n!个排列，每个排列有长度为 n 的数组。</li></ul><p><img src="/2024/06/06/posts/LCR079/image-4.png" alt="LCR083结果"></p><h2 id="LCR084-全排列II"><a href="#LCR084-全排列II" class="headerlink" title="LCR084.全排列II"></a><a href="https://leetcode.cn/problems/7p8L0Z/description/">LCR084.全排列II</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>和上一题的区别是，nums中可能包含重复的元素，但返回得结果不能有两个一样的排列。用unordered_set保存已经访问过的数字，后面如果再遇到，可以直接不处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">helper</span>(nums, <span class="hljs-number">0</span> , res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> index, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-comment">// 一次全排列</span><br>        <span class="hljs-keyword">if</span>(index == nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(nums);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 定义一个unordered_set来记录当前位置已经使用过的元素</span><br>            unordered_set&lt;<span class="hljs-type">int</span>&gt; set; <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = index; j &lt; nums.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">find</span>(nums[j]) == set.<span class="hljs-built_in">end</span>())&#123; <span class="hljs-comment">// 如果set中不包含nums[j]，则可以交换并递归处理</span><br>                    set.<span class="hljs-built_in">insert</span>(nums[j]);<br>                    <span class="hljs-built_in">swap</span>(nums[index], nums[j]); <br>                    <span class="hljs-built_in">helper</span>(nums, index+<span class="hljs-number">1</span>, res);<br>                    <span class="hljs-built_in">swap</span>(nums[index], nums[j]);<br>                &#125;<br>            &#125;           <br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n*n!)</li><li>空间复杂度：O(n*n!)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从一个包含m个元素的集合中挑选出n个元素（0≤n≤m）形成一个子集。一个子集又可以称为一个组合。如果两个子集（组合）的元素完全相同只是顺序不同，那么它们可以看作同一个子集（组合）。</p><p>从一个包含m个元素的集合中挑选出n个元素（0≤n≤m）并按照某种顺序形成一个排列。m等于n的排列又称为全排列。如果两个排列的元素完全相同只是顺序不同，那么它们就是两个不同的排列。也就是说，排列与元素的顺序相关，这一点与组合不同。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>回溯法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR074-LCR078排序</title>
    <link href="/2024/06/01/posts/LCR074/"/>
    <url>/2024/06/01/posts/LCR074/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）12-排序"><a href="#剑指offer（专项突破版）12-排序" class="headerlink" title="剑指offer（专项突破版）12 排序"></a>剑指offer（专项突破版）12 排序</h1><h2 id="LCR074-合并区间"><a href="#LCR074-合并区间" class="headerlink" title="LCR074.合并区间"></a><a href="https://leetcode.cn/problems/SsGoHC/description/">LCR074.合并区间</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果先将所有区间按照起始位置排序，那么只需要比较相邻两个区间的结束位置就能知道它们是否重叠。如果区间1的结束位置大于区间2的起始位置，说明存在重叠，取较大的结束位置。如果它们重叠就将它们合并，然后判断合并的区间是否和下一个区间重叠。重复这个过程，直到所有重叠的区间都合并为止。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; merge(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; <span class="hljs-built_in">int</span>ervals) &#123;<br>        <span class="hljs-comment">// 边界条件处理</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span>ervals.size() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>        <span class="hljs-comment">// 将数组按照起始时间排序</span><br>        sort(<span class="hljs-built_in">int</span>ervals.begin(), <span class="hljs-built_in">int</span>ervals.end());<br>        <span class="hljs-comment">// 对每个区间合并</span><br>        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; res&#123;<span class="hljs-built_in">int</span>ervals[<span class="hljs-number">0</span>]&#125;;  <span class="hljs-comment">// 初始时将第一个区间放入</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">int</span>ervals.size(); i++)&#123;<br>            <span class="hljs-comment">// 当前起始时间小于前面的结束时间，说明可以合并</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>] &lt;= res.back()[<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-comment">// 修改结果中的结束时间</span><br>                res.back()[<span class="hljs-number">1</span>] = max(res.back()[<span class="hljs-number">1</span>], <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-comment">// 否则不能合并，将该区间加入结果集</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                res.push_back(<span class="hljs-built_in">int</span>ervals[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：如果输入数组中有n个区间，那么将它排序的时间复杂度是O（nlogn），接着逐一扫描排序的区间数组并将相邻的区间合并。逐一扫描每个区间，时间复杂度为O(n)。总的时间复杂度为O(nlogn)。</li><li>空间复杂度：最多需要O(n)存储结果。</li></ul><p><img src="/2024/06/01/posts/LCR074/image.png" alt="LCR074结果"></p><h2 id="LCR075-数组的相对排序"><a href="#LCR075-数组的相对排序" class="headerlink" title="LCR075.数组的相对排序"></a><a href="https://leetcode.cn/problems/0H97ZC/description/">LCR075.数组的相对排序</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>计数排序是一种线性时间的整数排序算法。如果数组的长度为n，整数范围（数组中最大整数与最小整数的差值）为k，对于k远小于n的场景（如对某公司所有员工的年龄排序），那么计数排序的时间复杂度优于其他基于比较的排序算法（如归并排序、快速排序等）。</p><p>计数排序的基本思想是先统计数组中每个整数在数组中出现的次数，然后按照从小到大的顺序将每个整数按照它出现的次数填到数组中。</p><p>如果数组的长度为n，整数的范围为k，那么计数排序的时间复杂度就是O（n+k）。由于需要创建一个长度为O（k）的辅助数组counts，因此空间复杂度为O（k）。当k较小时，无论从时间复杂度还是空间复杂度来看计数排序都是非常高效的算法。当k很大时，计数排序可能就不如其他排序算法（如快速排序、归并排序）高效。</p><p>题目明确提出数组中的数字都在0到1000的范围内。这是一个很明显的提示，据此可以考虑采用计数排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">relativeSortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr2)</span> </span>&#123;<br>        <span class="hljs-comment">// 统计arr1中的次数</span><br>        <span class="hljs-type">int</span> counts[<span class="hljs-number">1001</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            counts[arr1[i]]++;<br>        &#125;<br>        <span class="hljs-comment">// 按照arr2中的排序</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : arr2)&#123;<br>            <span class="hljs-keyword">while</span>(counts[num] &gt; <span class="hljs-number">0</span>)&#123;<br>                arr1[i++] = num;<br>                counts[num]--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 剩余元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt; <span class="hljs-number">1001</span>; k++)&#123;<br>            <span class="hljs-keyword">while</span>(counts[k] &gt; <span class="hljs-number">0</span>)&#123;<br>                arr1[i++] = k;<br>                counts[k]--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：如果数组arr1的长度为m，数组arr2的长度为n，那么时间复杂度是O（m+n）。</li><li>空间复杂度：由于这个题目中的数字在0到1000的范围内，上述代码用来统计每个数字出现次数的辅助数组counts的长度为1001，是一个常数，因此空间复杂度可以认为是O（1）。</li></ul><p><img src="/2024/06/01/posts/LCR074/image-1.png" alt="LCR075结果"></p><h2 id="LCR076-数组中的第K个最大的元素"><a href="#LCR076-数组中的第K个最大的元素" class="headerlink" title="LCR076.数组中的第K个最大的元素"></a><a href="https://leetcode.cn/problems/xx4gT2/description/">LCR076.数组中的第K个最大的元素</a></h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的基本思想是分治法，排序过程如下：在输入数组中随机选取一个元素作为中间值（pivot），然后对数组进行分区（partition），使所有比中间值小的数据移到数组的左边，所有比中间值大的数据移到数组的右边。接下来对中间值左右两侧的子数组用相同的步骤排序，直到子数组中只有一个数字为止。</p><p>如果partition返回的值为n-k，则找到了第K大元素，如果返回的索引大于n-k，则在start,index-1继续找；如果小于n-k，则在index+1,end区间继续找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-comment">// 随机选取一个值作为pivot</span><br>        <span class="hljs-type">int</span> r = <span class="hljs-built_in">rand</span>() % (end - start + <span class="hljs-number">1</span>) + start;<br>        <span class="hljs-comment">// 将其换到数组最后</span><br>        <span class="hljs-built_in">swap</span>(nums[r], nums[end]);<br>        <span class="hljs-comment">// 初始化指针</span><br>        <span class="hljs-type">int</span> small = start - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start; i &lt; end; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt; nums[end])&#123;<br>                small++;<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[small]);<br>            &#125;<br>        &#125;<br>        small++;<br>        <span class="hljs-built_in">swap</span>(nums[small], nums[end]);<br>        <span class="hljs-keyword">return</span> small;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> end = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> index = <span class="hljs-built_in">partition</span>(nums, start, end);<br>        <span class="hljs-type">int</span> target = nums.<span class="hljs-built_in">size</span>() - k;<br>        <span class="hljs-keyword">while</span>(index != target)&#123;<br>            <span class="hljs-keyword">if</span>(index &gt; target)&#123;<br>                end = index - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                start = index + <span class="hljs-number">1</span>;<br>            &#125;<br>            index = <span class="hljs-built_in">partition</span>(nums, start, end);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>()-k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：由于函数partition随机选择中间值，因此它的返回值也具有随机性，计算这种算法的时间复杂度需要运用概率相关的知识。此处仅计算一种特定场合下的时间复杂度。假设函数partition每次选择的中间值都位于分区后的数组的中间位置，那么第1次函数partition需要扫描长度为n的数组，第2次需要扫描长度为n&#x2F;2的子数组，第3次需要扫描长度为n&#x2F;4的数组，重复这个过程，直到子数组的长度为1。由于n+n&#x2F;2+n&#x2F;4+…+1&#x3D;2n，因此总的时间复杂度是O（n）。</li><li>空间复杂度：O(1)</li></ul><p><img src="/2024/06/01/posts/LCR074/image-2.png" alt="LCR076快速排序方法"></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>建立大小为k的小根堆，堆顶元素就是第k大的数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 小根堆操作：将以节点 i 为根的子树进行小根堆调整</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">minHeapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> heapSize)</span></span>&#123;<br>        <span class="hljs-comment">// 获取左右子节点索引和当前节点索引</span><br>        <span class="hljs-type">int</span> left = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right = i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> smallest = i;<br>        <span class="hljs-comment">// 如果左子节点存在且小于当前节点，则更新最小节点索引</span><br>        <span class="hljs-keyword">if</span>(left &lt; heapSize &amp;&amp; nums[left] &lt; nums[smallest])&#123;<br>            smallest = left;<br>        &#125;<br>        <span class="hljs-comment">// 如果右子节点存在且小于当前节点或左子节点，则更新最小节点索引</span><br>        <span class="hljs-keyword">if</span>(right &lt; heapSize &amp;&amp; nums[right] &lt; nums[smallest])&#123;<br>            smallest = right;<br>        &#125;<br>        <span class="hljs-comment">// 如果最小节点索引不等于当前节点索引，则交换当前节点和最小节点，并继续调整最小堆</span><br>        <span class="hljs-keyword">if</span>(smallest != i)&#123;<br>            <span class="hljs-built_in">swap</span>(nums[i], nums[smallest]);<br>            <span class="hljs-built_in">minHeapify</span>(nums, smallest, heapSize);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 建立小根堆</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildMinHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> heapSize)</span></span>&#123;<br>        <span class="hljs-comment">// 从最后一个非叶子节点开始，依次向前调整节点，保证以每个节点为根的子树都是小根堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = heapSize / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-built_in">minHeapify</span>(nums, i ,heapSize);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 构建一个大小为K的最小堆</span><br>        <span class="hljs-built_in">buildMinHeap</span>(nums, k);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[<span class="hljs-number">0</span>]);<br>                <span class="hljs-built_in">minHeapify</span>(nums, <span class="hljs-number">0</span>, k);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：建堆的复杂度为O(n)，调整堆的复杂度为O(logk)，故时间复杂度为O(nlogk)。</li><li>空间复杂度：递归调用的最大深度为 logk。所以空间复杂度为 O(logk)。</li></ul><p><img src="/2024/06/01/posts/LCR074/image-3.png" alt="LCR076堆排序结果"></p><h2 id="LCR077-链表排序"><a href="#LCR077-链表排序" class="headerlink" title="LCR077.链表排序"></a><a href="https://leetcode.cn/problems/7WHec2/description/">LCR077.链表排序</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>由于题目没有限定数字的范围，因此计数排序就不太适合。但可以考虑使用插入排序、冒泡排序等算法对链表进行排序，这些算法比较直观，实现起来也比较简单。只是这些算法的时间复杂度是O（n2），未必是最高效的算法。</p><p>接下来考虑对数组进行排序的时间复杂度为O（nlogn）的排序算法，常用的有堆排序、快速排序和归并排序。</p><p>如果输入的是一个数组，那么堆排序用数组实现最大堆，该排序算法每次取出其中的最大值，再调整剩余的最大堆，直到所有数字都被取出。</p><p>在数组中只需要O（1）的时间就能根据下标找到一个数字，但在链表中需要O（n）的时间才能根据节点的编号找到对应的节点。因此，不可能直接利用链表实现堆排序，但是如果链表的长度为n就可以创建一个长度为n的数组来实现堆，也就是说，通过O（n）的空间代价来实现堆排序。</p><p>接下来考虑快速排序。通常，快速排序算法首先随机生成一个下标，并以该下标对应的值作为中间值进行分区。如果输入的是数组，那么只需要O（1）的时间就能根据下标找到一个数字。但如果输入的是链表，那么需要O（n）的时间才能根据节点的编号找到对应的节点。快速排序也可以考虑不用随机的中间值，而是始终以某个固定位置的值作为中间值（如链表的头节点或尾节点），这样可能会出现每次分区时两个子链表的大小都不均衡，从而使时间复杂度退化为O（n2）。因此，虽然可以用快速排序算法对链表进行排序，但不如对数组排序高效。</p><p>那么归并排序是否适合链表？归并排序的主要思想是将链表分成两个子链表，在对两个子链表排序后再将它们合并成一个排序的链表。这看起来没有什么问题，所以可以尝试基于归并排序算法对链表进行排序。使用递归可以实现链表的归并排序，首先使用 split 函数将链表分为前后两半并返回后半部分的头节点。再将链表分成的两半使用递归实现排序，之后调用 merge 函数将两个已排序链表进行合并。其中 split 函数可以使用快慢指针法，而 merge 函数可以使用双指针法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 将链表分成两部分</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">split</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        ListNode* slow = head;<br>        ListNode* fast = head-&gt;next;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 前半部分列表的最后一个结点的next指针指向空</span><br>        ListNode* second = slow-&gt;next;<br>        slow-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> second;<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* head1, ListNode* head2)</span></span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* cur = dummy;<br>        <span class="hljs-keyword">while</span>(head1 &amp;&amp; head2)&#123;<br>            <span class="hljs-keyword">if</span>(head1-&gt;val &lt; head2-&gt;val)&#123;<br>                cur-&gt;next = head1;<br>                head1 = head1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cur-&gt;next = head2;<br>                head2 = head2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        cur-&gt;next = (head1 == <span class="hljs-literal">NULL</span>) ? head2 : head1;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束</span><br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 将链表分成两部分</span><br>        ListNode* head1 = head;<br>        ListNode* head2 = <span class="hljs-built_in">split</span>(head);<br>        <span class="hljs-comment">// 将两个链表排序</span><br>        head1 = <span class="hljs-built_in">sortList</span>(head1);<br>        head2 = <span class="hljs-built_in">sortList</span>(head2);<br>        <span class="hljs-comment">// 将两个链表合并</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(head1, head2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>突然发现力扣可以自己分析算法复杂度了！</p><ul><li>时间复杂度：O（nlogn）。</li><li>空间复杂度：由于对链表进行归并排序不需要创建另外一个相同大小的链表来保存合并之后的节点，因此对链表进行归并排序的空间效率更高。由于代码存在递归调用，递归调用栈的深度为O（logn），因此空间复杂度为O（logn）。如果改用迭代的代码实现上述归并排序的过程，那么可以将空间复杂度优化到O（1）。</li></ul><p><img src="/2024/06/01/posts/LCR074/image-4.png" alt="LCR077结果"></p><h2 id="LCR078-合并K个升序链表"><a href="#LCR078-合并K个升序链表" class="headerlink" title="LCR078.合并K个升序链表"></a><a href="https://leetcode.cn/problems/vvXgSW/description/">LCR078.合并K个升序链表</a></h2><h3 id="利用最小堆选取值最小的节点"><a href="#利用最小堆选取值最小的节点" class="headerlink" title="利用最小堆选取值最小的节点"></a>利用最小堆选取值最小的节点</h3><p>这道题有个很朴素的想法，使用 k 个指针分别指向链表的头节点，每次都从这 k 个节点中选取值最小的节点确定为合并后的链表的第一个节点。然后将指向最小值节点的指针向后移动一步，再比较这 k 个节点中选取值最小的节点确定为下一个节点。重复以上过程，所有链表就会被合并。</p><p>这个思路需要反复比较 k 个节点的值，因为只关心值最小的节点，所以可以使用最小堆优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-comment">// 最小堆</span><br>        <span class="hljs-keyword">auto</span> cmp = [&amp;](<span class="hljs-type">const</span> ListNode* lhs, <span class="hljs-type">const</span> ListNode* rhs)&#123;<br>            <span class="hljs-keyword">return</span> lhs-&gt;val &gt; rhs-&gt;val;<br>        &#125;;<br>        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">heap</span>(cmp);<br><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* cur = dummy;<br>        <span class="hljs-comment">// 将每个链表的头结点加入最小堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; node : lists)&#123;<br>            <span class="hljs-keyword">if</span>(node)&#123;<br>                heap.<span class="hljs-built_in">push</span>(node);<br>            &#125; <br>        &#125;<br>        <span class="hljs-comment">// 不断取堆顶元素加到结果链表中</span><br>        <span class="hljs-keyword">while</span>(!heap.<span class="hljs-built_in">empty</span>())&#123;<br>            ListNode* node = heap.<span class="hljs-built_in">top</span>();<br>            heap.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(node-&gt;next)&#123;<br>                heap.<span class="hljs-built_in">push</span>(node-&gt;next);<br>            &#125;<br>            cur-&gt;next = node;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：假设k个排序链表总共有n个节点。如果堆的大小为k，那么空间复杂度就是O（k）。每次用最小堆处理一个节点需要O（logk）的时间，因此这种解法的时间复杂度是O（nlogk）。</li><li>空间复杂度：最小堆最多存储k个元素，即空间复杂度为O(k)。</li></ul><p><img src="/2024/06/01/posts/LCR074/image-5.png" alt="LCR078最小堆结果"></p><h3 id="按照归并排序的思路合并链表"><a href="#按照归并排序的思路合并链表" class="headerlink" title="按照归并排序的思路合并链表"></a>按照归并排序的思路合并链表</h3><p>输入的k个排序链表可以分成两部分，前k&#x2F;2个链表和后k&#x2F;2个链表。如果将前k&#x2F;2个链表和后k&#x2F;2个链表分别合并成两个排序的链表，再将两个排序的链表合并，那么所有链表都合并了。合并k&#x2F;2个链表与合并k个链表是同一个问题，可以调用递归函数解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 合并多个链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(start == end)&#123;<br>            <span class="hljs-keyword">return</span> lists[start];<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        ListNode* head1 = <span class="hljs-built_in">mergeLists</span>(lists, start, mid);<br>        ListNode* head2 = <span class="hljs-built_in">mergeLists</span>(lists, mid+<span class="hljs-number">1</span>, end);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(head1, head2);<br>    &#125;<br>    <span class="hljs-comment">// 合并两个链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode*head1, ListNode* head2)</span></span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* cur = dummy;<br>        <span class="hljs-keyword">while</span>(head1 &amp;&amp; head2)&#123;<br>            <span class="hljs-keyword">if</span>(head1-&gt;val &lt; head2-&gt;val)&#123;<br>                cur-&gt;next = head1;<br>                head1 = head1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cur-&gt;next = head2;<br>                head2 = head2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        cur-&gt;next = (head1 == <span class="hljs-literal">NULL</span>) ? head2 : head1;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(lists.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeLists</span>(lists, <span class="hljs-number">0</span>, lists.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：递归调用的深度是O（logk），每次需要合并n个节点，因此时间复杂度是O（nlogk）。</li><li>空间复杂度：O（logk），用来维护递归调用栈。</li></ul><p><img src="/2024/06/01/posts/LCR074/image-6.png" alt="LCR078归并排序结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果整数在一个有限的范围内，那么可以先统计每个整数出现的次数，然后按照从小到大的顺序根据每个整数出现的次数写入输出数组中。如果n个整数的范围是k，那么计数排序的时间复杂度是O（n+k）。当k较小时，计数排序是非常高效的排序算法。</p><p>快速排序随机地从数组中选取一个中间值，然后对数组分区，使比中间值小的数值都位于左边，比中间值大的数值都位于右边，接下来将左右两边的子数组分别排序即可。快速排序的平均时间复杂度是O（nlogn）。</p><p>快速排序的函数partition可以用来选取第k大的数值。</p><p>归并排序将输入数组分成两半，在分别将左右两个子数组排序之后再将它们合并成一个排序的数组。归并排序的时间复杂度是O（nlogn），空间复杂度是O（n）。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR068-LCR073二分查找</title>
    <link href="/2024/05/27/posts/LCR068/"/>
    <url>/2024/05/27/posts/LCR068/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）11-二分查找"><a href="#剑指offer（专项突破版）11-二分查找" class="headerlink" title="剑指offer（专项突破版）11 二分查找"></a>剑指offer（专项突破版）11 二分查找</h1><h2 id="LCR068-搜索插入位置"><a href="#LCR068-搜索插入位置" class="headerlink" title="LCR068.搜索插入位置"></a><a href="https://leetcode.cn/problems/N6YdxV/description/">LCR068.搜索插入位置</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>若找到，返回位置，若没找到，返回left。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><p><img src="/2024/05/27/posts/LCR068/image.png" alt="LCR068结果"></p><h2 id="LCR069-山脉数组的峰顶索引"><a href="#LCR069-山脉数组的峰顶索引" class="headerlink" title="LCR069.山脉数组的峰顶索引"></a><a href="https://leetcode.cn/problems/B1IidL/description/">LCR069.山脉数组的峰顶索引</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>题目保证给定的数组是一个山脉数组。即对于mid，如果大于左边和右边的元素，则为峰顶；如果大于左边小于右边，则峰顶在右边区域；如果小于左边大于右边，则在左边区域。在比较时需要注意索引是否合法，当mid&#x3D;0时，不用再比较左边，当mid&#x3D;n-1时，不需要再比较右边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peakIndexInMountainArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right =  arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(arr[mid] &gt; arr[mid<span class="hljs-number">-1</span>] &amp;&amp; arr[mid] &gt; arr[mid+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; arr[mid<span class="hljs-number">-1</span>] &amp;&amp; arr[mid] &lt; arr[mid+<span class="hljs-number">1</span>])&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/2024/05/27/posts/LCR068/image-1.png" alt="LCR069结果"></p><h2 id="LCR070-排序数组中的单一元素"><a href="#LCR070-排序数组中的单一元素" class="headerlink" title="LCR070.排序数组中的单一元素"></a><a href="https://leetcode.cn/problems/skFtm2/description/">LCR070.排序数组中的单一元素</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>数组中的数字每两个分成一组，最初的若干组的两个数字都是相同的。但遇到了只出现一次的数字之后，情况发生变化。这个只出现一次的数字和后面的数字结合成一组，导致后面所有出现两次的数字都被分到两个不同的组，即后面所有组的两个数字都不相同。由此可见，只出现一次的数字正好是第1个两个数字不相等的分组的第1个数字。</p><p>接着考虑如何用二分查找的思路来解决这个问题。将数组中的数字每两个分为一组。先找出位于中间的一组，确定这一组的两个数字是否相同。如果两个数字相同，那么那个只出现一次的数字一定在它的后面，因此接着查找它的后半部分。如果两个数字不相同，那么接着检查这一组是不是第1组两个数字不相同的分组。如果是第1组，那么这一组的第1个数字就是只出现一次的数字。如果不是第1组，那么第1组一定在它的前面，因此接着查找它的前半部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNonDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 数组两个分为一组</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> i = mid * <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 如果当前分组内的两个数字不相等</span><br>            <span class="hljs-keyword">if</span>(i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; nums[i] != nums[i+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-comment">//查看是否是第一个不相等的组</span><br>                <span class="hljs-keyword">if</span>(mid == <span class="hljs-number">0</span> || nums[i<span class="hljs-number">-2</span>] == nums[i<span class="hljs-number">-1</span>])&#123;<br>                    <span class="hljs-keyword">return</span> nums[i];<br>                &#125;<br>                <span class="hljs-comment">// 如果不是，向前找</span><br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 相等，继续向后找</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul><p><img src="/2024/05/27/posts/LCR068/image-2.png" alt="LCR070结果"></p><h2 id="LCR071-按权重随机选择"><a href="#LCR071-按权重随机选择" class="headerlink" title="LCR071.按权重随机选择"></a><a href="https://leetcode.cn/problems/cuyjEf/description/">LCR071.按权重随机选择</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; sums;   <span class="hljs-comment">// 记录前i个数字的和</span><br>    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; w) &#123;<br>        sums.<span class="hljs-built_in">resize</span>(w.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            sum += w[i];<br>            sums[i] = sum;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pickIndex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 生成随机数</span><br>        <span class="hljs-type">int</span> p = <span class="hljs-built_in">rand</span>() % sums.<span class="hljs-built_in">back</span>() + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 二分查找，找到第一个大于随机数的</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = sums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(p &lt;= sums[mid])&#123;<br>                <span class="hljs-keyword">if</span>(mid == <span class="hljs-number">0</span> || p &gt; sums[mid<span class="hljs-number">-1</span>])&#123;<br>                    <span class="hljs-keyword">return</span> mid;<br>                &#125;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Solution object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Solution* obj = new Solution(w);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;pickIndex();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li><p>时间复杂度：如果权重数组的长度是n，那么累加权重的数组sums的长度也是n，每次调用函数pickIndex的时间复杂度是O（logn）。</p></li><li><p>空间复杂度：O(n)，存放前缀和。</p></li></ul><p><img src="/2024/05/27/posts/LCR068/image-3.png" alt="LCR071结果"></p><h2 id="LCR072-x的平方根"><a href="#LCR072-x的平方根" class="headerlink" title="LCR072.x的平方根"></a><a href="https://leetcode.cn/problems/jJ0w9p/solutions/">LCR072.x的平方根</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>假设输入的非负整数为n。解决这个问题的直观方法是从0开始每次增加1，对于每个整数m，判断m2是否小于或等于n。如果找到一个m，并且满足m2≤n和（m+1）2&gt;n，那么m就是n的平方根。这种直观的解法从0一直试到n的平方根，因此时间复杂度是O（n0.5）。</p><p>由数学常识可知，整数n的平方根一定小于或等于n。同时，除0之外的所有整数的平方根都大于或等于1。因此，整数n的平方根一定在从1到n的范围内，取这个范围内的中间数字m，并判断m2是否小于或等于n。如果m2≤n，那么接着判断（m+1）2是否大于n。如果满足（m+1）2&gt;n，那么m就是n的平方根。如果m2≤n并且（m+1）2≤n，则n的平方根比m大，接下来搜索从m+1到n的范围。如果m2&gt;n，则n的平方根小于m，接下来搜索从1到m-1的范围。然后在相应的范围内重复这个过程，总是取出位于范围中间的m，计算m2和（m+1）2并与n比较，直到找到一个满足m2≤n并且（m+1）2&gt;n的m。</p><p>这种思路每次都取某个范围的中间值，如果中间值满足条件，则搜索结束；如果中间值不满足条件，则该中间值将下一轮搜索的范围缩小一半。这正是典型的二分查找的过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right = x;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(mid &lt;= x / mid)&#123;<br>                <span class="hljs-keyword">if</span>((mid + <span class="hljs-number">1</span>) &gt; x / (mid + <span class="hljs-number">1</span>))&#123;<br>                    <span class="hljs-keyword">return</span> mid;<br>                &#125;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：二分查找算法每次将搜索范围缩小一半，从1到n的范围只需要搜索O（logn）次，因此基于二分查找的解法的时间复杂度是O（logn）。</li><li>空间复杂度：O(1)</li></ul><p><img src="/2024/05/27/posts/LCR068/image-4.png" alt="LCR072结果"></p><h2 id="LCR073-爱吃香蕉的狒狒"><a href="#LCR073-爱吃香蕉的狒狒" class="headerlink" title="LCR073.爱吃香蕉的狒狒"></a><a href="https://leetcode.cn/problems/nZZqjQ/description/">LCR073.爱吃香蕉的狒狒</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>狒狒吃香蕉的速度应该介于每小时吃1~最大堆香蕉数，因此可以用二分查找，如果以mid为速度吃完所有香蕉的时间大于警卫离开的时间，就在右边部分找，否则在左半部分找。结束的条件是当前mid的时间小于等于H且mid-1的时间大于H，或者mid&#x3D;1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHours</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles, <span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num : piles)&#123;<br>            res += num / k;<br>            res += num % k &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minEatingSpeed</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles, <span class="hljs-type">int</span> h)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right = *<span class="hljs-built_in">max_element</span>(piles.<span class="hljs-built_in">begin</span>(), piles.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">getHours</span>(piles, mid) &lt;= h)&#123;<br>                <span class="hljs-keyword">if</span>(mid == <span class="hljs-number">1</span> || <span class="hljs-built_in">getHours</span>(piles, mid<span class="hljs-number">-1</span>) &gt; h)&#123;<br>                    <span class="hljs-keyword">return</span> mid;<br>                &#125;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：如果总共有m堆香蕉，最大一堆香蕉的数目为n，函数minEatingSpeed在1到n的范围内做二分查找，需要尝试O（logn）次，每尝试一次需要遍历整个数组求出按某一速度吃完所有香蕉需要的时间，因此总的时间复杂度是O（mlogn）。</li><li>空间复杂度：O(1)</li></ul><p><img src="/2024/05/27/posts/LCR068/image-5.png" alt="LCR073结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了二分查找算法。如果要求在一个排序数组中查找一个数字，那么可以用二分查找算法优化查找的效率。二分查找算法的基本思路是在查找范围内选取位于中间的数字。如果中间数字刚好符合要求，那么就找到了目标数字。如果中间数字不符合要求，则比较中间数字和目标数字的大小并相应地确定下一轮查找的范围是当前查找范围的前半部分还是后半部分。由于每轮查找都将查找范围缩小一半，如果排序数组的长度为n，那么二分查找算法的时间复杂度是O（logn）。</p><p>二分查找除了可以在排序数组中查找某个数字，还可以在数值范围内实现快速查找。可以先根据数值的最小值和最大值确定查找范围，然后按照二分查找的思路尝试数值范围的中间值。如果这个中间值不符合要求，则尝试数值范围的前半部分或后半部分。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>二分查找</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR062-LCR067前缀树</title>
    <link href="/2024/05/22/posts/LCR062/"/>
    <url>/2024/05/22/posts/LCR062/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）10-前缀树"><a href="#剑指offer（专项突破版）10-前缀树" class="headerlink" title="剑指offer（专项突破版）10 前缀树"></a>剑指offer（专项突破版）10 前缀树</h1><h2 id="LCR062-实现前缀树"><a href="#LCR062-实现前缀树" class="headerlink" title="LCR062.实现前缀树"></a><a href="https://leetcode.cn/problems/QC3q1f/description/">LCR062.实现前缀树</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;Trie*&gt; children;<br>    <span class="hljs-type">bool</span> isEnd;<br>    <span class="hljs-function">Trie* <span class="hljs-title">searchPrefix</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : prefix)&#123;<br>            ch -= <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(node-&gt;children[ch] == <span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>            node = node-&gt;children[ch];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">children</span>(<span class="hljs-number">26</span>), <span class="hljs-built_in">isEnd</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br>    <br>    <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-comment">// 初始化node</span><br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-comment">// 遍历每一个字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : word)&#123;<br>            ch -= <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-comment">// 如果没有这个字符，new一个结点</span><br>            <span class="hljs-keyword">if</span>(node-&gt;children[ch] == <span class="hljs-literal">NULL</span>)&#123;<br>                node-&gt;children[ch] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            node = node-&gt;children[ch];<br>        &#125;<br>        node-&gt;isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if the word is in the trie. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-comment">// 初始化node</span><br>        Trie* node = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">searchPrefix</span>(word);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;isEnd;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">searchPrefix</span>(prefix) != <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Trie* obj = new Trie();</span><br><span class="hljs-comment"> * obj-&gt;insert(word);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;search(word);</span><br><span class="hljs-comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：如果输入的单词的长度为n，那么函数insert、search和startWith的时间复杂度都是O（n）。</li><li>空间复杂度：$O(∣T∣⋅Σ)$，其中$|T|$为所有插入字符串的长度之和，$Σ$为字符集的大小，本题$Σ&#x3D;26$。</li></ul><p><img src="/2024/05/22/posts/LCR062/image.png" alt="LCR062结果"></p><h2 id="LCR063-单词替换"><a href="#LCR063-单词替换" class="headerlink" title="LCR063.单词替换"></a><a href="https://leetcode.cn/problems/UhWRSj/description/">LCR063.单词替换</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>对于句子的每个单词，判断字典中有没有其前缀，如果有，就用前缀替换它。如果有多个满足的前缀，则用最短的那个，即每次判断isEnd，为true就直接返回，不需要再找下一个节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 前缀树</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;Trie*&gt; children;<br>    <span class="hljs-type">bool</span> isEnd;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">children</span>(<span class="hljs-number">26</span>), <span class="hljs-built_in">isEnd</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br>    <span class="hljs-comment">// 插入单词</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string prefix)</span></span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : prefix)&#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;children[ch-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">NULL</span>)&#123;<br>                node-&gt;children[ch-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            node = node-&gt;children[ch-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        node-&gt;isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 查找前缀</span><br>    <span class="hljs-function">string <span class="hljs-title">searchPrefix</span><span class="hljs-params">(string prefix)</span></span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : prefix)&#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;children[ch-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            res += ch;<br>            node = node-&gt;children[ch-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span>(node-&gt;isEnd)&#123;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;  <br>        &#125;<br>        <span class="hljs-keyword">return</span> prefix;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceWords</span><span class="hljs-params">(vector&lt;string&gt;&amp; dictionary, string sentence)</span> </span>&#123;<br>        <span class="hljs-comment">// 建立前缀树</span><br>        Trie* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>        <span class="hljs-keyword">for</span>(string word : dictionary)&#123;<br>            root-&gt;<span class="hljs-built_in">insert</span>(word);<br>        &#125;<br><br>        <span class="hljs-comment">// 按照空格分隔字符串</span><br>        <span class="hljs-function">istringstream <span class="hljs-title">iss</span><span class="hljs-params">(sentence)</span></span>;<br>        string str;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(iss &gt;&gt; str)&#123;<br>            res += root-&gt;<span class="hljs-built_in">searchPrefix</span>(str);<br>            res += <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        res = res.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, res.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O((N+K)⋅L)，N为词典的单词总数，K为句子中的单词总数，L 是单词的平均长度。</li><li>空间复杂度：O((N+K)⋅L)</li></ul><p><img src="/2024/05/22/posts/LCR062/image-1.png" alt="LCR063结果"></p><h2 id="LCR064-实现一个魔法字典"><a href="#LCR064-实现一个魔法字典" class="headerlink" title="LCR064.实现一个魔法字典"></a><a href="https://leetcode.cn/problems/US1pGT/description/">LCR064.实现一个魔法字典</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>首先建立一棵前缀树，然后根据深度优先的顺序搜索前缀树的每条路径。如果到达的节点与字符串中的字符不匹配，则表示此时修改了字符串中的一个字符以匹配前缀树中的路径。如果到达对应字符串最后一个字符对应的节点时该节点的isWord字段的值为true，而且此时正好修改了字符串中的一个字符，那么就找到了修改字符串中一个字符对应的路径，符合题目的条件，可以返回true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 构造前缀树</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;Trie*&gt; children;<br>    <span class="hljs-type">bool</span> isEnd;<br>    <span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">children</span>(<span class="hljs-number">26</span>), <span class="hljs-built_in">isEnd</span>(<span class="hljs-literal">false</span>)&#123;&#125;<br>    <span class="hljs-comment">// 插入单词</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string prefix)</span></span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : prefix)&#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;children[ch-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">NULL</span>)&#123;<br>                node-&gt;children[ch-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            node = node-&gt;children[ch-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        node-&gt;isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicDictionary</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    Trie* root;<br>    <span class="hljs-built_in">MagicDictionary</span>() &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildDict</span><span class="hljs-params">(vector&lt;string&gt; dictionary)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(string str : dictionary)&#123;<br>            root-&gt;<span class="hljs-built_in">insert</span>(str);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; word, Trie* node, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> modified)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!node) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pos == word.<span class="hljs-built_in">length</span>()) &#123;<br>            <span class="hljs-keyword">return</span> node-&gt;isEnd &amp;&amp; modified == <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> idx = word[pos] - <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>        <span class="hljs-comment">// 尝试不修改当前字符继续搜索</span><br>        <span class="hljs-keyword">if</span> (node-&gt;children[idx] &amp;&amp; <span class="hljs-built_in">dfs</span>(word, node-&gt;children[idx], pos + <span class="hljs-number">1</span>, modified)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 尝试修改当前字符后继续搜索</span><br>        <span class="hljs-keyword">if</span> (modified == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (i != idx &amp;&amp; node-&gt;children[i]) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(word, node-&gt;children[i], pos + <span class="hljs-number">1</span>, modified + <span class="hljs-number">1</span>)) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string searchWord)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(searchWord, root, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MagicDictionary object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MagicDictionary* obj = new MagicDictionary();</span><br><span class="hljs-comment"> * obj-&gt;buildDict(dictionary);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;search(searchWord);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><img src="/2024/05/22/posts/LCR062/image-2.png" alt="LCR064复杂度分析"></p><p><img src="/2024/05/22/posts/LCR062/image-3.png" alt="LCR064结果"></p><h2 id="LCR065-单词的压缩编码"><a href="#LCR065-单词的压缩编码" class="headerlink" title="LCR065.单词的压缩编码"></a><a href="https://leetcode.cn/problems/iSwD2y/description/">LCR065.单词的压缩编码</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>首先反转每个单词，由于在最短编码之中出现的每个单词之后都有一个字符’＃’，因此计算长度时出现的每个单词的长度都要加1。在前缀树中统计路径长度时，可以统计从根节点到每个叶节点的路径的长度。前缀树的根节点并不对应单词的任何字符，在统计路径时将根节点包括进去相当于将单词的长度加1。通常用深度优先遍历的算法统计路径的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 构造前缀树</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;Trie*&gt; childen;<br>    <span class="hljs-type">bool</span> isEnd;<br><br>    <span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">childen</span>(<span class="hljs-number">26</span>), <span class="hljs-built_in">isEnd</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string prefix)</span></span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : prefix)&#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;childen[ch-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">NULL</span>)&#123;<br>                node-&gt;childen[ch-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            node = node-&gt;childen[ch-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        node-&gt;isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumLengthEncoding</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        Trie* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>        <span class="hljs-comment">// 逆转字符串</span><br>        <span class="hljs-keyword">for</span>(string str :words)&#123;<br>            <span class="hljs-built_in">reverse</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-comment">// 插入前缀树</span><br>            root-&gt;<span class="hljs-built_in">insert</span>(str);<br>        &#125;<br>        <span class="hljs-comment">// 计算长度</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">1</span>, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Trie* root, <span class="hljs-type">int</span> curLen, <span class="hljs-type">int</span>&amp; res)</span></span>&#123;<br>        <span class="hljs-type">bool</span> isLeaf = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(Trie* child : root-&gt;childen)&#123;<br>            <span class="hljs-keyword">if</span>(child)&#123;<br>                isLeaf = <span class="hljs-literal">false</span>;<br>                <span class="hljs-built_in">dfs</span>(child, curLen + <span class="hljs-number">1</span>, res);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isLeaf)&#123;<br>            res += curLen;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(N⋅L)，N为单词个数，L为单词平均长度。</li><li>空间复杂度：构造前缀树的空间复杂度为O(N⋅L)。DFS递归栈的空间复杂度为O(L)，整体空间复杂度为O(N⋅L)。</li></ul><p><img src="/2024/05/22/posts/LCR062/image-4.png" alt="LCR065结果"></p><h2 id="LCR066-单词之和"><a href="#LCR066-单词之和" class="headerlink" title="LCR066.单词之和"></a><a href="https://leetcode.cn/problems/z1R5dt/description/">LCR066.单词之和</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>在查找每个包含给定前缀的单词时，需要加上它的值，因此可以在构造前缀树时提供一个val。因为val是大于等于1的，所以可以取消之前的isEnd字段，用一个整型来替代，当val&#x3D;0时就不是单词，但是也不需要关注，可以直接相加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;Trie*&gt; children;<br>    <span class="hljs-type">int</span> val;<br><br>    <span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">children</span>(<span class="hljs-number">26</span>), <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MapSum</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Trie* root;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MapSum</span>() &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string key, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        Trie* node = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : key)&#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;children[ch-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">NULL</span>)&#123;<br>                node-&gt;children[ch-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            node = node-&gt;children[ch-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        node-&gt;val = val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        Trie* node = root;<br>        <span class="hljs-comment">// 先找到前缀处</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : prefix)&#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;children[ch-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            node = node-&gt;children[ch-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-comment">// 从前缀处除法计算各条路线的和</span><br>        <span class="hljs-built_in">dfs</span>(node, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Trie* pre, <span class="hljs-type">int</span>&amp; res)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Trie* node = pre;<br>        res += node-&gt;val;<br>        <span class="hljs-keyword">for</span>(Trie* child : node-&gt;children)&#123;<br>            <span class="hljs-built_in">dfs</span>(child, res);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MapSum object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MapSum* obj = new MapSum();</span><br><span class="hljs-comment"> * obj-&gt;insert(key,val);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;sum(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><img src="/2024/05/22/posts/LCR062/image-5.png" alt="LCR066结果"></p><h2 id="LCR067-数组中两个数的最大异或值"><a href="#LCR067-数组中两个数的最大异或值" class="headerlink" title="LCR067.数组中两个数的最大异或值"></a><a href="https://leetcode.cn/problems/ms70jA/description/">LCR067.数组中两个数的最大异或值</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>可以利用前缀树，相同前缀越长的其异或值越小。然后遍历每个数字，找到对于它来说异或值最大的。因为每个数字都是32位的，因此无需标记isEnd。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;Trie*&gt; children;<br><br>    <span class="hljs-built_in">Trie</span>(): <span class="hljs-built_in">children</span>(<span class="hljs-number">2</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>        Trie* node  = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-comment">// 通过右移来遍历数字的每一位</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">31</span>; i &gt;=<span class="hljs-number">0</span> ; i--)&#123;<br>            <span class="hljs-type">int</span> bit = (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(node-&gt;children[bit] == <span class="hljs-literal">NULL</span>)&#123;<br>                node-&gt;children[bit] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            node = node-&gt;children[bit];<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaximumXOR</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 建立前缀树</span><br>        Trie* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            root-&gt;<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-comment">// 对每个数字遍历</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>            Trie* node = root;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>                <span class="hljs-type">int</span> bit = (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 1-bit是为了找到和当前位相反的数字位，如果不为空，则顺着它遍历</span><br>                <span class="hljs-keyword">if</span>(node-&gt;children[<span class="hljs-number">1</span>- bit])&#123;<br>                    cur = (cur &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>                    node = node-&gt;children[<span class="hljs-number">1</span> - bit];<br>                &#125;<br>                <span class="hljs-comment">// 如果没有相反的，只能顺着相同的找</span><br>                <span class="hljs-keyword">else</span>&#123;<br>                    cur = cur &lt;&lt; <span class="hljs-number">1</span>;<br>                    node = node-&gt;children[bit];<br>                &#125;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：建立前缀树和findMaximumXOR都有两层循环。第1层循环逐个扫描数组中的每个整数，而第2层循环的执行次数是32次，是一个常数。如果数组nums的长度为n，那么这种算法的时间复杂度是O（n）。</li><li>空间复杂度：O(n)。</li></ul><p><img src="/2024/05/22/posts/LCR062/image-6.png" alt="LCR067结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了前缀树这种数据结构。前缀树通常用来保存字符串，它的节点和字符串的字符对应，而路径和字符串对应。如果只考虑英文小写字母，那么前缀树的每个节点有26个子节点。为了标注某些节点和字符串的最后一个字符对应，前缀树节点中通常需要一个布尔类型的字段。</p><p>前缀树经常用来解决与字符串查找相关的问题。和哈希表相比，在前缀树中查找更灵活。既可以从哈希表中找出所有以某个前缀开头的所有单词，也可以找出修改了一个（或多个）字符的字符串。</p><p>使用前缀树解决问题通常需要两步：第1步是创建前缀树，第2步是在前缀树中查找。虽然相关的面试题千变万化，但这两步及其代码却大同小异。如果应聘者能够熟练地编写出创建前缀树和在前缀树中查找的正确代码，那么就能得心应手地解决与前缀树相关的面试题。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>前缀树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR059-LCR061堆的应用</title>
    <link href="/2024/05/19/posts/LCR059/"/>
    <url>/2024/05/19/posts/LCR059/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）9-2-堆的应用"><a href="#剑指offer（专项突破版）9-2-堆的应用" class="headerlink" title="剑指offer（专项突破版）9.2 堆的应用"></a>剑指offer（专项突破版）9.2 堆的应用</h1><h2 id="LCR059-数据流中的第K大元素"><a href="#LCR059-数据流中的第K大元素" class="headerlink" title="LCR059.数据流中的第K大元素"></a><a href="https://leetcode.cn/problems/jBjn9C/description/">LCR059.数据流中的第K大元素</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果能够找出k个最大的数字，那么第k大的数字就是这k个最大数字中最小的一个。由于每次都需要找出k个数字中的最小值，因此可以把这k个数字保存到最小堆中。每当从数据流中读出一个数字，就先判断这个新的数字是不是有必要添加到最小堆中。如果最小堆中元素的数目还小于k，那么直接将它添加到最小堆中。如果最小堆中已经有k个元素，那么将其和位于堆顶的最小值进行比较。如果新读出的数字小于或等于堆中的最小值，那么堆中的k个数字都比它大，因此它不可能是k个最大的数字中的一个。由于只需要保存最大的k个数字，因此新读出的数字可以忽略。如果新的数字大于堆顶的数字，那么堆顶的数字就是第k+1大的数字，可以将它从堆中删除，并将新的数字添加到堆中，这样堆中保存的仍然是到目前为止从数据流中读出的最大的k个数字，此时第k大的数字正好位于最小堆的堆顶。</p><p>使用STL自带的priority_queue：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">KthLargest</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; heap;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-built_in">KthLargest</span>(<span class="hljs-type">int</span> k, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        size = k;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-built_in">add</span>(nums[i]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果堆大小小于k，直接插入</span><br>        <span class="hljs-keyword">if</span>(heap.<span class="hljs-built_in">size</span>() &lt; size)&#123;<br>            heap.<span class="hljs-built_in">push</span>(val);<br>        &#125;<br>        <span class="hljs-comment">// 否则如果大于堆顶，就把堆顶删除</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val &gt; heap.<span class="hljs-built_in">top</span>())&#123;<br>            heap.<span class="hljs-built_in">pop</span>();<br>            heap.<span class="hljs-built_in">push</span>(val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> heap.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your KthLargest object will be instantiated and called as such:</span><br><span class="hljs-comment"> * KthLargest* obj = new KthLargest(k, nums);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;add(val);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logk)</li><li>空间复杂度：O(k)</li></ul><p><img src="/2024/05/19/posts/LCR059/image.png" alt="LCR059结果"></p><h2 id="LCR060-前K个高频元素"><a href="#LCR060-前K个高频元素" class="headerlink" title="LCR060.前K个高频元素"></a><a href="https://leetcode.cn/problems/g5c51o/description/">LCR060.前K个高频元素</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>首先使用哈希表存储元素及其出现的次数，然后遍历每一个频次，建立最小堆。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span>&#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 存储至哈希表</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            hash[nums[i]]++;<br>        &#125;<br>        <span class="hljs-comment">// 根据哈希表建立大小为k的最小堆</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, cmp&gt; minHeap;<br>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">auto</span> it = hash.<span class="hljs-built_in">begin</span>(); it != hash.<span class="hljs-built_in">end</span>(); it++)&#123;<br>            <span class="hljs-keyword">if</span>(minHeap.<span class="hljs-built_in">size</span>() &lt; k)&#123;<br>                minHeap.<span class="hljs-built_in">push</span>(*it);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(it-&gt;second &gt; minHeap.<span class="hljs-built_in">top</span>().second)&#123;<br>                minHeap.<span class="hljs-built_in">pop</span>();<br>                minHeap.<span class="hljs-built_in">push</span>(*it);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            <span class="hljs-type">int</span> cur = minHeap.<span class="hljs-built_in">top</span>().first;<br>            res.<span class="hljs-built_in">push_back</span>(cur);<br>            minHeap.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：假设输入数组的长度为n。在大小为k的堆中进行添加或删除操作的时间复杂度是O（logk），因此上述代码的时间复杂度是O（nlogk）。</li><li>空间复杂度：上述代码需要一个大小为O（n）的哈希表，以及一个大小为O（k）的最小堆，因此总的空间复杂度是O（n）。</li></ul><p><img src="/2024/05/19/posts/LCR059/image-1.png" alt="LCR060结果"></p><h2 id="LCR061-查找和最小的k对数字"><a href="#LCR061-查找和最小的k对数字" class="headerlink" title="LCR061.查找和最小的k对数字"></a><a href="https://leetcode.cn/problems/qn8gGX/description/">LCR061.查找和最小的k对数字</a></h2><h3 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h3><p>这个题目要求找出和最小的k个数对。可以用最大堆来存储这k个和最小的数对。逐一将m×n个数对添加到最大堆中。当堆中的数对的数目小于k时，直接将数对添加到堆中。如果堆中已经有k个数对，那么先要比较待添加的数对之和及堆顶的数对之和（也是堆中最大的数对之和）。如果待添加的数对之和大于或等于堆顶的数对之和，那么堆中的k个数对之和都小于或等于待添加的数对之和，因此待添加的数对可以忽略。如果待添加的数对之和小于堆顶的数对之和，那么删除堆顶的数对，并将待添加的数对添加到堆中，这样可以确保堆中存储的是和最小的k个数对。每次都是将待添加的数对与堆中和最大的数对进行比较，而这也是用最大堆的原因。</p><p>接下来考虑如何优化。题目给出的条件是输入的两个数组都是递增排序的，这个特性我们还没有用到。如果从第1个数组中选出第k+1个数字和第2个数组中的某个数字组成数对p，那么该数对之和一定不是和最小的k个数对中的一个，这是因为第1个数组中的前k个数字和第2个数组中的同一个数字组成的k个数对之和都要小于数对p之和。因此，不管输入的数组nums1有多长，最多只需要考虑前k个数字。同理，不管输入的数组nums2有多长，最多也只需要考虑前k个数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span>&#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>)(a.first + a.second) &lt; (<span class="hljs-type">long</span>)(b.first + b.second);<br>        &#125;<br>    &#125;;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">kSmallestPairs</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> k) &#123;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;, cmp&gt; heap;  <span class="hljs-comment">// 最大堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k &amp;&amp; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k &amp;&amp; j &lt; nums2.<span class="hljs-built_in">size</span>(); j++)&#123;<br>                <span class="hljs-keyword">if</span>(heap.<span class="hljs-built_in">size</span>() &lt; k)&#123;<br>                    heap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(nums1[i],nums2[j]));<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums1[i] + nums2[j] &lt; heap.<span class="hljs-built_in">top</span>().first + heap.<span class="hljs-built_in">top</span>().second)&#123;<br>                    heap.<span class="hljs-built_in">pop</span>();<br>                    heap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(nums1[i],nums2[j]));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 输出结果</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">while</span>(!heap.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">auto</span> it = heap.<span class="hljs-built_in">top</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; cur;<br>            cur.<span class="hljs-built_in">push_back</span>(it.first);<br>            cur.<span class="hljs-built_in">push_back</span>(it.second);<br>            res.<span class="hljs-built_in">push_back</span>(cur);<br>            heap.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：上述代码有两个相互嵌套的for循环，每个循环最多执行k次。在循环体内可能在最大堆中进行添加或删除操作，由于最大堆中最多包含k个元素，因此添加、删除操作的时间复杂都是$O(logk)$。这两个for循环的时间复杂度是$O(k^2logk)$。另外，上述代码还有一个while循环，它逐一从最大堆中删除元素并将对应的数对添加到链表中，这个while循环的时间复杂度是O(klogk)。因此，上述代码总的时间复杂度是$O(k^2logk)$。</li><li>空间复杂度：$O(k)$</li></ul><p><img src="/2024/05/19/posts/LCR059/image-2.png" alt="LCR061最大堆结果"></p><h3 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h3><p>首先将nums1中的前k个元素与nums2的第一个元素组成的数对依次加入到堆中。这样做是为了初始化堆，确保堆中包含了每个nums1元素与nums2第一个元素组成的数对。然后进行循环处理，每次取出堆顶元素（当前和最小的数对），将其加入结果数组中，并将堆顶元素的索引往后移动一位，如果不超过nums2的范围，则将其加入堆中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 找到两个已排序数组中的 k 个最小对</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">kSmallestPairs</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">// 处理特殊情况：数组为空或 k 非正数</span><br>        <span class="hljs-keyword">if</span> (nums1.<span class="hljs-built_in">empty</span>() || nums2.<span class="hljs-built_in">empty</span>() || k &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br><br>        <span class="hljs-comment">// Lambda 函数，根据对的和进行比较</span><br>        <span class="hljs-keyword">auto</span> compare = [&amp;](<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; b) &#123;<br>            <span class="hljs-built_in">return</span> (nums1[a.first] + nums2[a.second]) &gt; (nums1[b.first] + nums2[b.second]);<br>        &#125;;<br><br>        <span class="hljs-comment">// 优先队列用于维护 k 个最小对，使用自定义比较函数进行初始化</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-keyword">decltype</span>(compare)&gt; <span class="hljs-built_in">heap</span>(compare);<br><br>        <span class="hljs-comment">// 初始化优先队列，将 nums1 和 nums2 的开始元素组成的对加入队列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>() &amp;&amp; i &lt; k; i++)&#123;<br>            heap.<span class="hljs-built_in">push</span>(&#123;i, <span class="hljs-number">0</span>&#125;);<br>        &#125;<br><br>        <span class="hljs-comment">// 从队列中提取对，直到找到 k 个最小对为止</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">while</span>(!heap.<span class="hljs-built_in">empty</span>() &amp;&amp; res.<span class="hljs-built_in">size</span>() &lt; k)&#123;<br>            <span class="hljs-keyword">auto</span> ids = heap.<span class="hljs-built_in">top</span>();<br>            heap.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">push_back</span>(&#123;nums1[ids.first], nums2[ids.second]&#125;);<br><br>            <span class="hljs-comment">// 如果仍有 nums2 中的下一个元素，将下一个对加入优先队列</span><br>            <span class="hljs-keyword">if</span>(ids.second &lt; nums2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)&#123;<br>                heap.<span class="hljs-built_in">push</span>(&#123;ids.first, ids.second + <span class="hljs-number">1</span>&#125;);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>decltype 是一个 C++ 关键字，用于获取某个表达式的类型。在这里，decltype(compare) 取得的类型就是 compare 这个 lambda 函数的类型。所以 decltype(compare)&gt; 实际上是告诉编译器我们要使用 compare 这个类型的比较函数来对优先队列中的元素进行比较。</p><ul><li>时间复杂度：上述代码先用一个for循环构建一个大小为k的最小堆，该循环的时间复杂度是O（klogk）。接下来是一个执行k次的while循环，每次对大小为k的最小堆进行添加或删除操作，因此这个while循环的时间复杂度也是O（klogk）。上述代码总的时间复杂度为O（klogk）。</li><li>空间复杂度：O(k)</li></ul><p><img src="/2024/05/19/posts/LCR059/image-3.png" alt="LCR061最小堆结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了堆这种数据结构。堆又可以分成最大堆和最小堆。在最大堆中最大值总是位于堆顶，在最小堆中最小值总是位于堆顶。因此，在堆中只需要O（1）的时间就能得到堆中的最大值或最小值。</p><p>堆经常用来解决在数据集合中找出k个最大值或最小值相关的问题。通常用最大堆找出数据集合中的k个最小值，用最小堆找出数据集合中的k个最大值。</p><blockquote><p>[!WARNING]</p><p>题目都是用priority_queue来做的，以后要补一下最大堆最小堆的具体实现。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>堆</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR057-LCR058TreeSet和TreeMap的应用</title>
    <link href="/2024/05/17/posts/LCR057/"/>
    <url>/2024/05/17/posts/LCR057/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）8-4-TreeSet和TreeMap的应用"><a href="#剑指offer（专项突破版）8-4-TreeSet和TreeMap的应用" class="headerlink" title="剑指offer（专项突破版）8.4 TreeSet和TreeMap的应用"></a>剑指offer（专项突破版）8.4 TreeSet和TreeMap的应用</h1><h2 id="LCR057-存在重复元素"><a href="#LCR057-存在重复元素" class="headerlink" title="LCR057.存在重复元素"></a><a href="https://leetcode.cn/problems/7WqeDu/description/">LCR057.存在重复元素</a></h2><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>可以逐一扫描数组中的每个数字。对于每个数字nums[i]，需要逐一检查在它前面的k个数字是否存在从nums[i]-t到nums[i]+t的范围内的数字。如果存在，则返回true。这种思路很容易用两个嵌套的循环实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 暴力解法，双重循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> j = i-k &gt;= <span class="hljs-number">0</span> ? i-k : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(; j &lt; i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>((<span class="hljs-type">long</span>)nums[i] - (<span class="hljs-type">long</span>)nums[j]) &lt;= t)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的代码在计算<code>abs((long)nums[i] - (long)nums[j]</code>时要把<code>int</code>转为<code>long</code>，在输入为<code>[-2147483648,2147483647]</code>时会发生溢出。</p><ul><li>时间复杂度：由于数组中的每个数字都要和k个数字进行比较，如果数组的长度为n，那么这种解法的时间复杂度是O（nk）。这种解法会超出时间限制。</li><li>空间复杂度：O(1)</li></ul><h3 id="set解法"><a href="#set解法" class="headerlink" title="set解法"></a>set解法</h3><p>在暴力解法中其实一直在寻找是否存在落在 [nums[i] - t, nyms[i] + t] 的数，这个过程可以用平衡的二叉搜索树来加速，平衡的二叉树的搜索时间复杂度为 O(logk)。在 C+++ STL 中 set 和 map 属于关联容器，其内部由红黑树实现，红黑树是平衡二叉树的一种优化实现，其搜索时间复杂度也为 O(logk)。逐次扫码数组，对于每个数字 nums[i]，当前的 set 应该由其前 k 个数字组成，可以 lower_bound 函数可以从 set 中找到符合大于等于 nums[i] - t 的最小的数，若该数存在且小于等于 nums[i] + t，则找到了符合要求的一对数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>        set&lt;<span class="hljs-type">int</span>&gt; treeSet;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-comment">// 防止溢出</span><br>            <span class="hljs-type">int</span> lowerLimit = <span class="hljs-built_in">max</span>(nums[i], INT_MIN + t) - t;<br>            <span class="hljs-type">int</span> upperLimit = <span class="hljs-built_in">min</span>(nums[i], INT_MAX - t) + t;<br>            <span class="hljs-comment">// 找到其中大于等于nums[i]-t的最小的数</span><br>            <span class="hljs-keyword">auto</span> it = treeSet.<span class="hljs-built_in">lower_bound</span>(lowerLimit);<br>            <span class="hljs-keyword">if</span>(it != treeSet.<span class="hljs-built_in">end</span>() &amp;&amp; *it &lt;= upperLimit)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 否则把当前元素放入set中</span><br>            treeSet.<span class="hljs-built_in">insert</span>(nums[i]);<br>            <span class="hljs-comment">// 删除索引差大于k的元素</span><br>            <span class="hljs-keyword">if</span>(i &gt;= k)&#123;<br>                treeSet.<span class="hljs-built_in">erase</span>(nums[i-k]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：做查找、添加和删除操作的时间复杂度都是O（logk），因此对于一个长度为n的数组而言，它的时间复杂度是O（nlogk）。</li><li>空间复杂度：treeSet，它的大小是k，因此空间复杂度是O（k）。</li></ul><p><img src="/2024/05/17/posts/LCR057/image.png" alt="LCR057set解法结果"></p><h3 id="桶解法"><a href="#桶解法" class="headerlink" title="桶解法"></a>桶解法</h3><p>换一种思路考虑该问题，因为题目只关心的是差的绝对值小于等于 t 的数字，这时候容易联想到桶，可以把数字放进若干个大小为 t + 1 的桶内，这样的好处是一个桶内的数字绝对值差肯定小于等于 t。对于桶的标号进行说明，例如 [0, t] 放进编号为 0 的桶内，[t + 1, 2t + 1] 放进编号为 1 的桶内，对于负数，则 [-t - 1, -1] 放进编号为 -1 的桶内，[-2t - 2, -t - 2] 编号为 -2 的桶内，可以发现桶</p><p>n &gt;&#x3D; 0 : ID &#x3D; n &#x2F; (t + 1);<br>n &lt; 0 : ID &#x3D; (n + 1) &#x2F; (t + 1) - 1;<br>另外需要一个哈希表保存扫描到数字的前 k 个数字的桶的编号，key → val 为 ID → num。在算法中依次扫描数组，扫描到 nums[i]，首先得到 nums[i] 的桶ID，先查询前 k 个数字中是否也有在 ID 桶内的数字，如果存在则该数字与 nums[i] 的差的绝对值肯定小于等于 t。另外若不存在，则需要查询 ID - 1 和 ID + 1 内的桶，因为也有可能存在与 nums[i] 的差绝对值差小于等于 t 的数字，但是这两个桶内的数字若存在还需要验证是否与 nums[i] 的差的绝对值小于等于 t。只要依次检查这三个桶即可，因为其他桶内的数字肯定不符合要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>        <span class="hljs-comment">// 哈希表记录桶的编号和数字值</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-comment">// 初始化桶大小为t+1</span><br>        <span class="hljs-type">long</span> bucketSize = (<span class="hljs-type">long</span>)t + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 遍历每一个数字</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-comment">// 计算桶序号</span><br>            <span class="hljs-type">int</span> ID = <span class="hljs-built_in">getBucketID</span>(nums[i], bucketSize);<br>            <span class="hljs-comment">// 在当前桶、相邻桶中查找是否有元素，有就直接返回true</span><br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">count</span>(ID) <br>            || (hash.<span class="hljs-built_in">count</span>(ID<span class="hljs-number">-1</span>) &amp;&amp; <span class="hljs-built_in">min</span>(INT_MAX-t, hash[ID<span class="hljs-number">-1</span>])+t &gt;= nums[i]) <br>            || (hash.<span class="hljs-built_in">count</span>(ID+<span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">max</span>(INT_MIN+t, hash[ID+<span class="hljs-number">1</span>])-t &lt;= nums[i]))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 否则把数字放到桶中</span><br>            hash[ID] = nums[i];<br>            <span class="hljs-comment">// 如果当前索引大于k需要删除索引差大于k的桶</span><br>            <span class="hljs-keyword">if</span>(i &gt;= k)&#123;<br>                hash.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">getBucketID</span>(nums[i-k], bucketSize));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取桶编号</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getBucketID</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">long</span> size)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (num &gt;=<span class="hljs-number">0</span> ) ? num / size : (num+<span class="hljs-number">1</span>) / size - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：哈希表中的查找、添加和删除操作的时间复杂度都是O（1），因此，对于一个长度为n的数组而言，它的时间复杂度是O（n）。</li><li>空间复杂度：哈希表的大小是k，因此，空间复杂度是O（k）。</li></ul><p><img src="/2024/05/17/posts/LCR057/image-1.png" alt="LCR057桶解法结果"></p><h2 id="LCR058-日程表"><a href="#LCR058-日程表" class="headerlink" title="LCR058.日程表"></a><a href="https://leetcode.cn/problems/fi9suh/description/">LCR058.日程表</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果需要添加的时间区间是<code>[m, n)</code>，就需要找出开始时间小于 m 的所有事项中开始最晚的一个（即图中时间段 2），以及开始时间大于 m 的所有事项中开始最早的一个（即图中的时间段 3）。如果待添加的时间段与这两个时间段无冲突，则可以添加入日程表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalendar</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; table;<br>    <span class="hljs-built_in">MyCalendar</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">book</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-comment">// 找到第一个不小于 start 的元素</span><br>        <span class="hljs-keyword">auto</span> low = table.<span class="hljs-built_in">lower_bound</span>(start);<br>        <br>        <span class="hljs-comment">// 检查与上一个事件是否重叠</span><br>        <span class="hljs-keyword">if</span> (low != table.<span class="hljs-built_in">begin</span>() &amp;&amp; (--low)-&gt;second &gt; start) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 检查与下一个事件是否重叠</span><br>        low = table.<span class="hljs-built_in">lower_bound</span>(start);<br>        <span class="hljs-keyword">if</span> (low != table.<span class="hljs-built_in">end</span>() &amp;&amp; low-&gt;first &lt; end) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果不重叠，则添加到日历</span><br>        table[start] = end;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyCalendar object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyCalendar* obj = new MyCalendar();</span><br><span class="hljs-comment"> * bool param_1 = obj-&gt;book(start,end);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(n)</li></ul><p><img src="/2024/05/17/posts/LCR057/image-2.png" alt="LCR058结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了树这种数据结构，尤其着重介绍了二叉树。与二叉树相关的面试题大多与遍历相关，本章通过大量的面试题全面介绍了二叉树的中序遍历、前序遍历和后序遍历这3种深度优先搜索算法。笔者强烈建议读者对这3种遍历的循环和递归代码烂熟于心，这样在解决与二叉树相关的面试题时才能得心应手。</p><p>二叉搜索树是一种特殊的二叉树，在二叉搜索树中进行搜索、添加和删除操作的平均时间复杂度都是O（logn）。如果按照中序遍历的顺序遍历一棵二叉搜索树，那么按照从小到大的顺序依次遍历每个节点。由于这个特性，与二叉搜索树相关的很多面试题都适合使用中序遍历解决。</p><p>Java中提供的TreeSet和TreeMap（C++中为<code>set</code>和<code>map</code>）这两种数据结构实现了平衡二叉搜索树。如果需要动态地在一个排序的数据集合中添加元素，或者需要根据数据的大小查找，那么可以使用TreeSet或TreeMap解决。</p><blockquote><p>[!WARNING]<br>题目都是用STL自带的数据结构实现的，对于二叉搜索树、二叉平衡树、红黑树等等还不熟悉，待日后补充。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR052-LCR056二叉搜索树</title>
    <link href="/2024/05/14/posts/LCR052/"/>
    <url>/2024/05/14/posts/LCR052/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）8-3-二叉搜索树"><a href="#剑指offer（专项突破版）8-3-二叉搜索树" class="headerlink" title="剑指offer（专项突破版）8.3 二叉搜索树"></a>剑指offer（专项突破版）8.3 二叉搜索树</h1><h2 id="LCR052-展平二叉搜索树"><a href="#LCR052-展平二叉搜索树" class="headerlink" title="LCR052.展平二叉搜索树"></a><a href="https://leetcode.cn/problems/NYBBNL/description/">LCR052.展平二叉搜索树</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>可以通过中序遍历，把一个一个的结点链接到上一个结点的右子树上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">increasingBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        TreeNode* newRoot = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>        TreeNode* cur = root;<br>        newRoot-&gt;right = cur;<br>        TreeNode* prev = newRoot;<br>        <span class="hljs-comment">// 中序遍历</span><br>        stack&lt;TreeNode*&gt; stack;<br>        <span class="hljs-keyword">while</span>(cur || !stack.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-comment">// 不断向下直到最左边</span><br>            <span class="hljs-keyword">while</span>(cur)&#123;<br>                stack.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125;<br>            cur = stack.<span class="hljs-built_in">top</span>();<br>            stack.<span class="hljs-built_in">pop</span>();<br>            prev-&gt;right = cur;<br>            prev = cur;<br>            cur-&gt;left = <span class="hljs-literal">NULL</span>;<br>            cur = cur-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newRoot-&gt;right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/2024/05/14/posts/LCR052/image.png" alt="LCR052结果"></p><h2 id="LCR053-二叉搜索树中的中序后继"><a href="#LCR053-二叉搜索树中的中序后继" class="headerlink" title="LCR053.二叉搜索树中的中序后继"></a><a href="https://leetcode.cn/problems/P5rCT8/description/">LCR053.二叉搜索树中的中序后继</a></h2><h3 id="时间复杂度为O-n-的解法"><a href="#时间复杂度为O-n-的解法" class="headerlink" title="时间复杂度为O(n)的解法"></a>时间复杂度为O(n)的解法</h3><p>最直观的思路就是采用二叉树的中序遍历。可以用一个布尔变量found来记录已经遍历到节点p。该变量初始化为false，遍历到节点p就将它设为true。在这个变量变成true之后遍历到的第1个节点就是要找的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">inorderSuccessor</span><span class="hljs-params">(TreeNode* root, TreeNode* p)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; stack;<br>        TreeNode* cur = root;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(cur || !stack.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(cur)&#123;<br>                stack.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125;<br>            cur = stack.<span class="hljs-built_in">top</span>();<br>            stack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                <span class="hljs-keyword">return</span> cur;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur == p)&#123;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>            cur = cur-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：由于中序遍历会逐一遍历二叉树的每个节点，如果二叉树有n个节点，那么这种思路的时间复杂度就是O（n）。</li><li>空间复杂度：需要用一个栈保存顺着指向左子节点的指针的路径上的所有节点，因此空间复杂度为O（h），其中h为二叉树的深度。</li></ul><p><img src="/2024/05/14/posts/LCR052/image-1.png" alt="LCR053方法一结果"></p><h3 id="时间复杂度为O-h-的解法"><a href="#时间复杂度为O-h-的解法" class="headerlink" title="时间复杂度为O(h)的解法"></a>时间复杂度为O(h)的解法</h3><p>下一个节点的值一定不会小于节点p的值，而且还是大于或等于节点p的值的所有节点中值最小的一个。从根节点开始，每到达一个节点就比较根节点的值和节点p的值。如果当前节点的值小于或等于节点p的值，那么节点p的下一个节点应该在它的右子树。如果当前节点的值大于节点p的值，那么当前节点有可能是它的下一个节点。此时当前节点的值比节点p的值大，但节点p的下一个节点是所有比它大的节点中值最小的一个，因此接下来前往当前节点的左子树，确定是否能找到值更小但仍然大于节点p的值的节点。重复这样的比较，直至找到最后一个大于节点p的值的节点，就是节点p的下一个节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">inorderSuccessor</span><span class="hljs-params">(TreeNode* root, TreeNode* p)</span> </span>&#123;<br>        TreeNode* cur = root;<br>        TreeNode* res = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;val &gt; p-&gt;val)&#123;<br>                res = cur;<br>                cur = cur-&gt;left;    <span class="hljs-comment">// 在其左子树上继续查找</span><br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cur = cur-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：由于while循环每运行一次都会顺着指向左子节点或右子节点的指针前往下一层节点，因此while循环执行的次数等于二叉搜索树的深度。如果把二叉树的深度记为h，那么该算法的时间复杂度为O（h）。</li><li>空间复杂度：上述代码除几个变量外没有其他内存开销，因此空间复杂度是O（1）。</li></ul><p><img src="/2024/05/14/posts/LCR052/image-2.png" alt="LCR053方法二结果"></p><h2 id="LCR054-把二叉搜索树转换为累加树"><a href="#LCR054-把二叉搜索树转换为累加树" class="headerlink" title="LCR054.把二叉搜索树转换为累加树"></a><a href="https://leetcode.cn/problems/w6cpku/description/">LCR054.把二叉搜索树转换为累加树</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>其实就是计算每个节点+其右子树的和。如果能够按照节点值从大到小按顺序遍历二叉搜索树，那么只需要遍历一次就够了，因为遍历到一个节点之前值大于该节点的值的所有节点已经遍历过。通常的中序遍历是先遍历左子树，再遍历根节点，最后遍历右子树，由于左子树节点的值较小，右子树节点的值较大，因此总体上就是按照节点的值从小到大遍历的。如果要按照节点的值从大到小遍历，那么只需要改变中序遍历的顺序，先遍历右子树，再遍历根节点，最后遍历左子树，这样遍历的顺序就颠倒过来了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; stack;<br>        TreeNode* cur = root;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 按照右根左的顺序遍历</span><br>        <span class="hljs-keyword">while</span>(cur || !stack.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(cur)&#123;<br>                stack.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;right;<br>            &#125;<br>            cur = stack.<span class="hljs-built_in">top</span>();<br>            stack.<span class="hljs-built_in">pop</span>();<br>            cur-&gt;val += sum;<br>            sum = cur-&gt;val;<br>            cur = cur-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/2024/05/14/posts/LCR052/image-3.png" alt="LCR054结果"></p><h2 id="LCR055-二叉搜索树迭代器"><a href="#LCR055-二叉搜索树迭代器" class="headerlink" title="LCR055.二叉搜索树迭代器"></a><a href="https://leetcode.cn/problems/kTOapQ/description/">LCR055.二叉搜索树迭代器</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>中序遍历的迭代代码中有一个while循环，循环的条件为true时循环体每执行一次就遍历二叉树的一个节点。当while循环的条件为false时，二叉树中的所有节点都已遍历完。因此，中序遍历的迭代代码中的while循环可以看成迭代器hasNext的判断条件，而while循环体内执行的操作就是函数next执行的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* cur;<br>    stack&lt;TreeNode*&gt; stack;<br>    <span class="hljs-built_in">BSTIterator</span>(TreeNode* root) &#123;<br>        cur = root;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            stack.<span class="hljs-built_in">push</span>(cur);<br>            cur = cur-&gt;left;<br>        &#125;<br>        cur = stack.<span class="hljs-built_in">top</span>();<br>        stack.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> res = cur-&gt;val;<br>        cur = cur-&gt;right;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cur != <span class="hljs-literal">NULL</span> || !stack.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your BSTIterator object will be instantiated and called as such:</span><br><span class="hljs-comment"> * BSTIterator* obj = new BSTIterator(root);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;next();</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;hasNext();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：函数hasNext的时间复杂度显然是O（1）。如果二叉搜索树有n个节点，调用n次函数next才能遍历完所有的节点，因此函数next的平均时间复杂度是O（1）。</li><li>空间复杂度：栈stack的大小为O（h）。由于这个栈一直存在，因此函数hasNext和next的空间复杂度是O（h）。</li></ul><p><img src="/2024/05/14/posts/LCR052/image-4.png" alt="LCR055结果"></p><h2 id="LCR056-二叉搜索树中两个节点的值之和"><a href="#LCR056-二叉搜索树中两个节点的值之和" class="headerlink" title="LCR056.二叉搜索树中两个节点的值之和"></a><a href="https://leetcode.cn/problems/opLdQZ/">LCR056.二叉搜索树中两个节点的值之和</a></h2><h3 id="利用哈希表，空间复杂度为O（n）的解法"><a href="#利用哈希表，空间复杂度为O（n）的解法" class="headerlink" title="利用哈希表，空间复杂度为O（n）的解法"></a>利用哈希表，空间复杂度为O（n）的解法</h3><p>先进行中序遍历，并把遍历到的值存到哈希表中，然后遍历哈希表，判断是否存在这样的两个数相加等于k。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; stack;<br>        TreeNode* cur = root;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-comment">// 中序遍历</span><br>        <span class="hljs-keyword">while</span>(cur || !stack.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(cur)&#123;<br>                stack.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125;<br>            cur = stack.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">count</span>(k-cur-&gt;val))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            stack.<span class="hljs-built_in">pop</span>();<br>            hash[cur-&gt;val]++;<br>            cur = cur-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：假设二叉搜索树中节点的数目是n，树的深度为h。上述代码由于需要遍历二叉搜索树，因此时间复杂度是O（n）。</li><li>空间复杂度：该算法除了需要一个大小为O（h）的栈保存朝着指向左子节点的指针经过的所有节点，还需要一个大小为O（n）的哈希表保存节点的值，因此总的空间复杂度是O（n）。</li></ul><p><img src="/2024/05/14/posts/LCR052/image-6.png" alt="LCR056方法一结果"></p><h3 id="应用双指针，空间复杂度为O（h）的解法"><a href="#应用双指针，空间复杂度为O（h）的解法" class="headerlink" title="应用双指针，空间复杂度为O（h）的解法"></a>应用双指针，空间复杂度为O（h）的解法</h3><p>应用上一题的思路，再反向建立一个迭代器。感觉意义不大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于中序遍历按照节点值递增的顺序遍历二叉搜索树的每个节点，因此中序遍历是解决二叉搜索树相关面试题最常用的思路。</p><p>在普通的二叉树中根据节点值查找对应的节点需要遍历这棵二叉树，因此需要O（n）的时间。但如果是二叉搜索树就可以根据其特性进行优化。如果当前节点的值小于要查找的值，则前往它的右子节点继续查找；如果当前节点的值大于要查找的值，则前往它的左子节点继续查找，这样重复下去直到找到对应的节点为止。如果二叉搜索树的高度为h，那么在二叉搜索树中根据节点值查找对应节点的时间复杂度是O（h）。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR047-LCR051二叉树的深度优先搜索</title>
    <link href="/2024/05/09/posts/LCR047/"/>
    <url>/2024/05/09/posts/LCR047/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）8-2-二叉树的深度优先搜索"><a href="#剑指offer（专项突破版）8-2-二叉树的深度优先搜索" class="headerlink" title="剑指offer（专项突破版）8.2 二叉树的深度优先搜索"></a>剑指offer（专项突破版）8.2 二叉树的深度优先搜索</h1><h2 id="三种遍历方式"><a href="#三种遍历方式" class="headerlink" title="三种遍历方式"></a>三种遍历方式</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">前序遍历</a></h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">preorder</span>(root-&gt;left);<br>        <span class="hljs-built_in">preorder</span>(root-&gt;right);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">preorder</span>(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; stack;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span>(cur || !stack.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(cur)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                stack.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125;<br>            cur = stack.<span class="hljs-built_in">top</span>();<br>            stack.<span class="hljs-built_in">pop</span>();<br>            cur = cur-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">中序遍历</a></h3><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left, res);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inorder</span>(root-&gt;right, res);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">inorder</span>(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; stack;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span>(cur || !stack.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(cur)&#123;<br>                stack.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125;<br>            cur = stack.<span class="hljs-built_in">top</span>();<br>            stack.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            cur = cur-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">后序遍历</a></h3><h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">postorder</span>(root-&gt;left, res);<br>        <span class="hljs-built_in">postorder</span>(root-&gt;right, res);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">postorder</span>(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; stack;<br>        TreeNode* cur = root;<br>        TreeNode* prev = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur || !stack.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(cur)&#123;<br>                stack.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125;<br>            <span class="hljs-comment">// 如果当前结点有右子树且没遍历过，则遍历右子树</span><br>            cur = stack.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(cur-&gt;right &amp;&amp; cur-&gt;right != prev)&#123;<br>                cur = cur-&gt;right;<br>            &#125;<br>            <span class="hljs-comment">// 否则将当前结点弹出</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                stack.<span class="hljs-built_in">pop</span>();<br>                res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                prev = cur;<br>                cur = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LCR047-二叉树剪枝"><a href="#LCR047-二叉树剪枝" class="headerlink" title="LCR047.二叉树剪枝"></a><a href="https://leetcode.cn/problems/pOCWxh/description/">LCR047.二叉树剪枝</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果用后序遍历的顺序遍历到某个节点，那么它的左右子树的节点一定已经遍历过了。每遍历到一个节点，就要确定它是否有左右子树，如果左右子树都是空的，并且节点的值是0，那么也就可以删除这个节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">pruneTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果root为空</span><br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">// 查看左右子树</span><br>        root-&gt;left = <span class="hljs-built_in">pruneTree</span>(root-&gt;left);<br>        root-&gt;right = <span class="hljs-built_in">pruneTree</span>(root-&gt;right);<br>        <span class="hljs-comment">// 如果左右子树都为空且当前结点为0</span><br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：递归函数<code>pruneTree</code>会遍历整棵树的每个节点，因此时间复杂度为O(n)。</li><li>空间复杂度：递归调用<code>pruneTree</code>函数会消耗栈空间，其最大递归深度等于树的高度O(h)。</li></ul><p><img src="/2024/05/09/posts/LCR047/image.png" alt="LCR047结果"></p><h2 id="LCR048-序列化和反序列化"><a href="#LCR048-序列化和反序列化" class="headerlink" title="LCR048.序列化和反序列化"></a><a href="https://leetcode.cn/problems/h54YBf/submissions/530668419/">LCR048.序列化和反序列化</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>先考虑如何将二叉树序列化为一个字符串。需要逐个遍历二叉树的每个节点，每遍历到一个节点就将节点的值序列化到字符串中。以前序遍历的顺序遍历二叉树最适合序列化。如果采用前序遍历的顺序，那么二叉树的根节点最先序列化到字符串中，然后是左子树，最后是右子树。这样做的好处是在反序列化时最方便，从字符串中读出的第1个数值一定是根节点的值。</p><p>实际上，只把节点的值序列化到字符串中是不够的。首先，要用一个分隔符（如逗号）把不同的节点分隔开。其次，还要考虑如何才能在反序列化的时候构建不同结构的二叉树。如果节点是null则返回特殊字符串”＃”；否则生成一个字符串。</p><p>反序列化：由于把二叉树序列化成一个以逗号作为分隔符的字符串，因此可以根据分隔符把字符串分隔成若干子字符串，每个子字符串对应二叉树的一个节点。如果一个节点为null，那么它和”＃”对应；否则这个节点将和一个表示它的值的子字符串对应。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span>;<br>        &#125;<br>        string left = <span class="hljs-built_in">serialize</span>(root-&gt;left);<br>        string right = <span class="hljs-built_in">serialize</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(root-&gt;val) + <span class="hljs-string">&quot;,&quot;</span> + left + <span class="hljs-string">&quot;,&quot;</span> + right;<br>    &#125;<br>    <span class="hljs-comment">// 辅助函数</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(stringstream&amp; ss)</span></span>&#123;<br>        string str;<br>        <span class="hljs-built_in">getline</span>(ss, str, <span class="hljs-string">&#x27;,&#x27;</span>);  <span class="hljs-comment">// 从ss中读取一行，以&#x27;,&#x27;作为分隔符</span><br>        <span class="hljs-comment">// 如果读取到&quot;#&quot;，表示空节点，返回nullptr</span><br>        <span class="hljs-keyword">if</span>(str == <span class="hljs-string">&quot;#&quot;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">// 创建当前节点</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(str));<br>        <span class="hljs-comment">// 递归调用左右子树</span><br>        root-&gt;left = <span class="hljs-built_in">dfs</span>(ss);<br>        root-&gt;right = <span class="hljs-built_in">dfs</span>(ss);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用stringstream处理字符串</span><br>        <span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(data)</span></span>;<br>        <span class="hljs-comment">// 递归调用辅助函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(ss);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec ser, deser;</span><br><span class="hljs-comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：对于序列化部分，每个节点都被表示为一个字符串，并且对于每个节点，都递归地调用了左子树和右子树的序列化函数。因此，序列化函数的时间复杂度取决于二叉树的节点数，为 O(n)，其中 n 是二叉树中的节点数。对于反序列化部分，算法使用了递归，每次读取一个节点，然后递归地读取其左右子树。因此，反序列化函数的时间复杂度也是 O(n)，其中 n 是二叉树中的节点数。<br>总体来说，这个算法的时间复杂度是 O(n)，其中 n 是二叉树中的节点数。</li><li>空间复杂度：在序列化和反序列化函数中，我们递归会使用栈空间，故渐进空间复杂度为 O(n)。</li></ul><p><img src="/2024/05/09/posts/LCR047/image-1.png" alt="LCR048结果"></p><h2 id="LCR049-求根节点到叶节点数字之和"><a href="#LCR049-求根节点到叶节点数字之和" class="headerlink" title="LCR049.求根节点到叶节点数字之和"></a><a href="https://leetcode.cn/problems/3Etpl5/">LCR049.求根节点到叶节点数字之和</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>每当遍历到一个节点时都计算从根节点到当前节点的路径表示的数字。如果这个节点还有子节点，就把这个值传下去继续遍历它的子节点。先计算到当前节点为止的路径表示的数字，再计算到它的子节点的路径表示的数字，这实质上就是典型的二叉树前序遍历。</p><p>路径的定义是从根节点开始到叶节点结束，因此只有遇到叶节点才返回路径表示的数字（代码中的变量path）。如果在遇到叶节点之前就结束的路径，由于不符合题目要求，因此应该返回0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> pathSum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 更新当前路径的数字之和</span><br>        pathSum = pathSum * <span class="hljs-number">10</span> + root-&gt;val;<br>        <span class="hljs-comment">// 如果是叶子节点，则将当前路径的数字之和累加到总和中</span><br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;<br>            <span class="hljs-keyword">return</span> pathSum;<br>        &#125;<br>        <span class="hljs-comment">// 继续遍历左右子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;left, pathSum) + <span class="hljs-built_in">dfs</span>(root-&gt;right, pathSum);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pathSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, pathSum);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，其中n是二叉树的节点个数。对每个节点访问一次。</li><li>空间复杂度：O(n)，其中n是二叉树的节点个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，空间复杂度为O(n)。</li></ul><p><img src="/2024/05/09/posts/LCR047/image-2.png" alt="LCR049结果"></p><h2 id="LCR050-路径总和"><a href="#LCR050-路径总和" class="headerlink" title="LCR050.路径总和"></a><a href="https://leetcode.cn/problems/6eUYwP/description/">LCR050.路径总和</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>如果在路径上移动时把所有累加的节点值之和都保存下来，就容易知道是否存在从任意节点出发的值为给定sum的路径。当遍历到一个节点时，先累加从根节点开始的路径上的节点值之和，再计算到它的左右子节点的路径的节点值之和。这就是典型的前序遍历的顺序。</p><p>使用哈希表保存之前累加到的和，哈希表的键是累加的节点值之和，哈希表的值是每个节点值之和出现的次数。当遍历到一个节点时，就把当前的节点值累加到参数path。如果这个和之前出现过，则将出现的次数加1；如果这个和之前没有出现过，那么这是它第1次出现。然后更新哈希表map保存累加节点值之和path及出现的次数。程序回到节点的父节点时，也就是说，在函数结束之前需要将当前节点从路径中删除，从根节点到当前节点累加的节点值之和也要从哈希表map中删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum, <span class="hljs-type">long</span> path, unordered_map&lt;<span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt;&amp; hash)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 更新当前路径和</span><br>        path += root-&gt;val;<br>        <span class="hljs-comment">// 查找</span><br>        <span class="hljs-type">int</span> count = (hash.<span class="hljs-built_in">count</span>(path - targetSum)) ? hash[path-targetSum] : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">count</span>(path))&#123;<br>            hash[path]++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            hash[path] = <span class="hljs-number">1</span>;<br>        &#125;<br>        count += <span class="hljs-built_in">dfs</span>(root-&gt;left, targetSum, path, hash);<br>        count += <span class="hljs-built_in">dfs</span>(root-&gt;right, targetSum, path, hash);<br>        hash[path]--;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; hash;   <span class="hljs-comment">// 定义哈希表，存储路径和及其出现的次数</span><br>        hash[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;                    <span class="hljs-comment">// 没有节点时，和为0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, targetSum, <span class="hljs-number">0</span>, hash);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意给定输入的范围可能会产生溢出，所以和的部分用long来表示。</p><p><img src="/2024/05/09/posts/LCR047/image-3.png" alt="LCR050结果"></p><h2 id="LCR051-二叉树中的最大路径和"><a href="#LCR051-二叉树中的最大路径和" class="headerlink" title="LCR051.二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/jC7MId/description/">LCR051.二叉树中的最大路径和</a></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>由于路径可能只经过左子树或右子树而不经过根节点，为了求得二叉树的路径上节点值之和的最大值，需要先求出左右子树中路径节点值之和的最大值（左右子树中的路径不经过当前节点），再求出经过根节点的路径节点值之和的最大值，最后对三者进行比较得到最大值。由于需要先求出左右子树的路径节点值之和的最大值，再求根节点，这看起来就是后序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span>&amp; maxSum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 递归计算左右子树的最大路径和，如果子树的最大路径和为负数，则置为0</span><br>        <span class="hljs-type">int</span> leftSum = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dfs</span>(root-&gt;left, maxSum));<br>        <span class="hljs-type">int</span> rightSum = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dfs</span>(root-&gt;right, maxSum));<br>        <span class="hljs-comment">// 计算以当前节点为根的最大路径和（包含左右子树）</span><br>        <span class="hljs-type">int</span> curMax = root-&gt;val + leftSum + rightSum;<br>        <span class="hljs-comment">// 更新全局最大路径和</span><br>        maxSum = <span class="hljs-built_in">max</span>(maxSum, curMax);<br>        <span class="hljs-comment">// 返回以当前节点为根的子树中的最大路径和（只能选择左子树或右子树）</span><br>        <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">max</span>(leftSum, rightSum);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxSum = INT_MIN;<br>        <span class="hljs-built_in">dfs</span>(root, maxSum);<br>        <span class="hljs-keyword">return</span> maxSum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/2024/05/09/posts/LCR047/image-4.png" alt="LCR051结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>[!WARNING]<br>对二叉树深度优先搜索的题目掌握得并不好，以后需要再练。</p></blockquote><p>下面比较中序遍历、前序遍历和后序遍历这3种不同遍历算法的代码。它们的递归代码都很简单，只需要调整代码的顺序就能写出对应算法的代码。</p><p>它们的迭代代码也很类似，如它们都需要用到一个栈，而且代码的基本结构很相像，都有两个while循环并且它们的条件都一样。需要留意遍历当前节点的时机。前序遍历一边顺着指向左子节点的指针移动一边遍历当前的节点，而中序遍历和后序遍历则顺着指向左子节点的指针移动时只将节点放入栈中，并不遍历遇到的节点。只有当到达最左子节点之后再从栈中取出节点遍历。后序遍历最复杂，还需要保存前一个遍历的节点，并根据前一个遍历的节点是否为当前节点的右子节点来决定此时是否可以遍历当前的节点。</p><p>不管是哪种深度优先搜索算法，也不管是递归代码还是迭代代码，如果二叉树有n个节点，那么它们的时间复杂都是O（n）。如果二叉树的深度为h，那么它们的空间复杂度都是O（h）。在二叉树中，二叉树的深度h的最小值是log2（n+1），最大值为n。例如，包含7个节点的二叉树，最少只有3层（二叉树的第1层有1个节点，第2层有2个节点，第3层有4个节点），但最多可能有7层（二叉树中除了叶节点，其他每个节点只有1个子节点）。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR043-LCR046二叉树的广度优先搜索</title>
    <link href="/2024/05/05/posts/LCR043/"/>
    <url>/2024/05/05/posts/LCR043/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）7-3-二叉树的广度优先搜索"><a href="#剑指offer（专项突破版）7-3-二叉树的广度优先搜索" class="headerlink" title="剑指offer（专项突破版）7.3 二叉树的广度优先搜索"></a>剑指offer（专项突破版）7.3 二叉树的广度优先搜索</h1><h2 id="LCR043-完全二叉树插入器"><a href="#LCR043-完全二叉树插入器" class="headerlink" title="LCR043.完全二叉树插入器"></a><a href="https://leetcode.cn/problems/NaqhDT/description/">LCR043.完全二叉树插入器</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>初始化：一个treenode指向根节点，一个队列，保存当前广度优先搜索到的位置。</li><li>插入：取出队列头结点，插入它的左边或右边，如果插的是右边，还需要将队头（也就是现在的父节点）弹出，将左右子结点放到队列中，因为此时队头结点需要更新。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CBTInserter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* tree;<br>    queue&lt;TreeNode*&gt; que;<br>    <span class="hljs-built_in">CBTInserter</span>(TreeNode* root) &#123;<br>        tree = root;<br>        <span class="hljs-comment">// 不断更新队列至可插入结点</span><br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(que.<span class="hljs-built_in">front</span>()-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; que.<span class="hljs-built_in">front</span>()-&gt;right != <span class="hljs-literal">NULL</span>)&#123;<br>            que.<span class="hljs-built_in">push</span>(que.<span class="hljs-built_in">front</span>()-&gt;left);<br>            que.<span class="hljs-built_in">push</span>(que.<span class="hljs-built_in">front</span>()-&gt;right);<br>            que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br>        TreeNode* parent = que.<span class="hljs-built_in">front</span>();<br>        TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(v);<br>        <span class="hljs-comment">// 插到左子树</span><br>        <span class="hljs-keyword">if</span>(!parent-&gt;left)&#123;<br>            parent-&gt;left = node;<br>        &#125;<br>        <span class="hljs-comment">// 插到右子树</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            parent-&gt;right = node;<br>            que.<span class="hljs-built_in">pop</span>();<br>            que.<span class="hljs-built_in">push</span>(parent-&gt;left);<br>            que.<span class="hljs-built_in">push</span>(parent-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">get_root</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> tree;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CBTInserter object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CBTInserter* obj = new CBTInserter(root);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;insert(v);</span><br><span class="hljs-comment"> * TreeNode* param_2 = obj-&gt;get_root();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：类型CBTInserter的构造函数从本质上来说是按照广度优先搜索的顺序找出二叉树中所有既有左子节点又有右子节点的节点，因此时间复杂度是O（n）。调用函数insert在完全二叉树中每添加一个节点最多只需要在队列中删除一个节点并添加两个节点。通常，队列的插入、删除操作的时间复杂度都是O（1），因此函数insert的时间复杂度是O（1）。显然，函数get_root的时间复杂度是O（1）。</li><li>空间复杂度：类型CBTInserter需要一个队列来实现广度优先搜索算法保存缺少左子节点或右子节点的节点，空间复杂度是O（n）。</li></ul><p><img src="/2024/05/05/posts/LCR043/image.png" alt="LCR043结果"></p><h2 id="LCR044-在每个树行中找最大值"><a href="#LCR044-在每个树行中找最大值" class="headerlink" title="LCR044.在每个树行中找最大值"></a><a href="https://leetcode.cn/problems/hPov7L/description/">LCR044.在每个树行中找最大值</a></h2><h3 id="用一个队列实现二叉树的广度优先搜索"><a href="#用一个队列实现二叉树的广度优先搜索" class="headerlink" title="用一个队列实现二叉树的广度优先搜索"></a>用一个队列实现二叉树的广度优先搜索</h3><p>最简单的，层次遍历找最大值。用current和next两个变量标记当前层和下一层的结点数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res; <br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> current = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 当前层结点数</span><br>        <span class="hljs-type">int</span> next = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 下一层结点数</span><br>        <span class="hljs-type">int</span> maxVal = INT_MIN;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* parent = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            current--;<br>            maxVal = <span class="hljs-built_in">max</span>(maxVal, parent-&gt;val);<br>            <span class="hljs-keyword">if</span>(parent-&gt;left)&#123;<br>                que.<span class="hljs-built_in">push</span>(parent-&gt;left);<br>                next++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(parent-&gt;right)&#123;<br>                que.<span class="hljs-built_in">push</span>(parent-&gt;right);<br>                next++;<br>            &#125;<br>            <span class="hljs-comment">// 当前层遍历完</span><br>            <span class="hljs-keyword">if</span>(current == <span class="hljs-number">0</span>)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(maxVal);<br>                maxVal = INT_MIN;<br>                current = next;<br>                next = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p><img src="/2024/05/05/posts/LCR043/image-1.png" alt="LCR044方法一结果"></p><h3 id="用两个队列实现二叉树的广度优先搜索"><a href="#用两个队列实现二叉树的广度优先搜索" class="headerlink" title="用两个队列实现二叉树的广度优先搜索"></a>用两个队列实现二叉树的广度优先搜索</h3><p>把不同层的节点放入不同的队列中。需要注意的是，当遍历某一层时，会将位于下一层的子节点也插入队列中，也就是说，队列中会有位于两层的节点。可以用两个不同的队列queue1和queue2分别存放两层的节点，队列queue1中只放当前遍历层的节点，而队列queue2中只放下一层的节点。</p><p>最开始时把二叉树的根节点放入队列queue1中。接下来每次从队列中取出一个节点遍历。由于队列queue1用来存放当前遍历层的节点，因此总是从队列queue1中取出节点用来遍历。如果当前遍历的节点有子节点，并且子节点位于下一层，则把子节点都放入队列queue2中。</p><p>当队列queue1被清空时，当前层的所有节点都已经被遍历完。通过比较这一层所有节点的值，就能找出这一层所有节点的最大值。在开始遍历下一层之前，把队列queue1指向队列queue2，并将队列queue2重新初始化为空的队列。重复这个过程，直到所有节点都遍历完为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(queue&lt;TreeNode*&gt;&amp; q)</span> </span>&#123;<br>        queue&lt;TreeNode*&gt; empty;<br>        <span class="hljs-built_in">swap</span>(empty, q);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 添加返回语句</span><br>        &#125;<br>        <span class="hljs-comment">// 定义两个队列</span><br>        queue&lt;TreeNode*&gt; que1;<br>        <span class="hljs-comment">// 将root放到队列1中</span><br>        que1.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> maxVal = INT_MIN;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            queue&lt;TreeNode*&gt; que2; <span class="hljs-comment">// 新建一个空队列</span><br>            <span class="hljs-keyword">while</span>(!que1.<span class="hljs-built_in">empty</span>())&#123;<br>                TreeNode* parent = que1.<span class="hljs-built_in">front</span>();<br>                que1.<span class="hljs-built_in">pop</span>();<br>                maxVal = <span class="hljs-built_in">max</span>(maxVal, parent-&gt;val);<br>                <span class="hljs-keyword">if</span>(parent-&gt;left)&#123;<br>                    que2.<span class="hljs-built_in">push</span>(parent-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(parent-&gt;right)&#123;<br>                    que2.<span class="hljs-built_in">push</span>(parent-&gt;right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 队列1为空了</span><br>            res.<span class="hljs-built_in">push_back</span>(maxVal);<br>            maxVal = INT_MIN;<br>            <span class="hljs-keyword">if</span>(que2.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            que1 = que2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p><img src="/2024/05/05/posts/LCR043/image-2.png" alt="LCR044方法二结果"></p><h2 id="LCR045-找树左下角的值"><a href="#LCR045-找树左下角的值" class="headerlink" title="LCR045.找树左下角的值"></a><a href="https://leetcode.cn/problems/LwUNpT/description/">LCR045.找树左下角的值</a></h2><p>可以用一个变量bottomLeft来保存每一层最左边的节点的值。在遍历二叉树时，每当遇到新的一层时就将变量bottomLeft的值更新为该层第1个节点的值。当整棵二叉树都被遍历完之后，变量bottomLeft的值就是最后一次更新的值，也就是最后一层的第1个节点的值。</p><p>由于用广度优先的顺序遍历二叉树时需要区分不同的层，因此可以用两个队列分别存放不同层的节点，一个队列存放当前遍历层的节点，另一个队列存放下一层的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearQueue</span><span class="hljs-params">(queue&lt;TreeNode*&gt;&amp; que)</span></span>&#123;<br>        queue&lt;TreeNode*&gt; empty;<br>        <span class="hljs-built_in">swap</span>(empty, que);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义两个队列</span><br>        queue&lt;TreeNode*&gt; que1;<br>        queue&lt;TreeNode*&gt; que2;<br>        que1.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> bottomLeft = root-&gt;val;<br>        <span class="hljs-keyword">while</span>(!que1.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* parent = que1.<span class="hljs-built_in">front</span>();<br>            que1.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(parent-&gt;left)&#123;<br>                que2.<span class="hljs-built_in">push</span>(parent-&gt;left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(parent-&gt;right)&#123;<br>                que2.<span class="hljs-built_in">push</span>(parent-&gt;right);<br>            &#125;<br>            <span class="hljs-comment">// 当前层遍历完</span><br>            <span class="hljs-keyword">if</span>(que1.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-keyword">if</span>(!que2.<span class="hljs-built_in">empty</span>())&#123;<br>                    bottomLeft = que2.<span class="hljs-built_in">front</span>()-&gt;val;<br>                &#125;<br>                que1 = que2;<br>                <span class="hljs-built_in">clearQueue</span>(que2);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bottomLeft;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p><img src="/2024/05/05/posts/LCR043/image-3.png" alt="LCR045结果"></p><h2 id="LCR046-二叉树的右视图"><a href="#LCR046-二叉树的右视图" class="headerlink" title="LCR046.二叉树的右视图"></a><a href="https://leetcode.cn/problems/WNC0Lk/">LCR046.二叉树的右视图</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>其实就是找每一层中最右边的结点。可以参照上一题的思路，只不过要记录的是每一层的最后一个结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearQue</span><span class="hljs-params">(queue&lt;TreeNode*&gt; &amp;que)</span></span>&#123;<br>        queue&lt;TreeNode*&gt; empty;<br>        <span class="hljs-built_in">swap</span>(que, empty);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; rights;<br>        <span class="hljs-comment">// 边界条件处理</span><br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> rights;<br>        &#125;<br>        <span class="hljs-comment">// 定义两个队列</span><br>        queue&lt;TreeNode*&gt; que1;<br>        queue&lt;TreeNode*&gt; que2;<br>        que1.<span class="hljs-built_in">push</span>(root);<br>        <br>        <span class="hljs-keyword">while</span>(!que1.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* parent = que1.<span class="hljs-built_in">front</span>();<br>            que1.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(parent-&gt;left)&#123;<br>                que2.<span class="hljs-built_in">push</span>(parent-&gt;left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(parent-&gt;right)&#123;<br>                que2.<span class="hljs-built_in">push</span>(parent-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(que1.<span class="hljs-built_in">empty</span>())&#123;<br>                rights.<span class="hljs-built_in">push_back</span>(parent-&gt;val);<br>                que1 = que2;<br>                <span class="hljs-built_in">clearQue</span>(que2);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rights;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p><img src="/2024/05/05/posts/LCR043/image-4.png" alt="LCR046结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果一个数据集合的添加、删除操作满足“先入先出”的特点，即最先添加的数据最先被删除，那么可以用队列来实现这个数据集合。</p><p>队列经常被用来实现二叉树的广度优先搜索。首先将二叉树的根节点插入队列。然后每次从队列中取出一个节点遍历。如果该节点有子节点，则将子节点插入队列。重复这个过程，直到队列被清空，此时二叉树所有的节点都已经遍历完。</p><p>如果需要区分二叉树不同的层，那么至少有两种方法可以实现。第一种方法是用两个变量来表示当前层和下一层节点的数目。如果当前遍历的层的节点数目变成0，那么这一层所有的节点都已经遍历完，可以开始遍历下一层的节点。第二种方法是用两个队列分别存放当前层和下一层的节点。如果当前层对应的队列被清空，那么该层所有的节点就已经被遍历完，可以开始遍历下一层。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR041-LCR042队列的应用</title>
    <link href="/2024/05/04/posts/LCR041/"/>
    <url>/2024/05/04/posts/LCR041/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）7-2-队列的应用"><a href="#剑指offer（专项突破版）7-2-队列的应用" class="headerlink" title="剑指offer（专项突破版）7.2 队列的应用"></a>剑指offer（专项突破版）7.2 队列的应用</h1><h2 id="LCR041-滑动窗口的平均值"><a href="#LCR041-滑动窗口的平均值" class="headerlink" title="LCR041.滑动窗口的平均值"></a><a href="https://leetcode.cn/problems/qIsx9U/submissions/529128259/">LCR041.滑动窗口的平均值</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题目给出的例子中的删除规则是把最早添加进来的数字删除，因此这是一种“先入先出”的顺序，由此想到应该采用队列这种数据结构来表示滑动窗口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MovingAverage</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-type">int</span> capacity = <span class="hljs-number">0</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    <span class="hljs-type">double</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">MovingAverage</span>(<span class="hljs-type">int</span> size) &#123;<br>        capacity = size;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        que.<span class="hljs-built_in">push</span>(val);<br>        sum += val;<br>        <span class="hljs-keyword">if</span>(que.<span class="hljs-built_in">size</span>() &gt; capacity)&#123;<br>            sum -= que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum / que.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MovingAverage object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MovingAverage* obj = new MovingAverage(size);</span><br><span class="hljs-comment"> * double param_1 = obj-&gt;next(val);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：对于每次插入元素操作都只需要常数时间，O(1)。</li><li>空间复杂度：O(n)。</li></ul><p><img src="/2024/05/04/posts/LCR041/image.png" alt="LCR041结果"></p><h2 id="LCR042-最近的请求次数"><a href="#LCR042-最近的请求次数" class="headerlink" title="LCR042.最近的请求次数"></a><a href="https://leetcode.cn/problems/H8086Q/description/">LCR042.最近的请求次数</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>每次调用ping，先检查t-3000是否小于等于队头，如果大于队头则说明已不在3000秒内，就不断把队头移出，直到小于等于队头，入队，并返回队列的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RecentCounter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    <span class="hljs-built_in">RecentCounter</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ping</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>() &amp;&amp; t<span class="hljs-number">-3000</span> &gt; que.<span class="hljs-built_in">front</span>())&#123;<br>            que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        que.<span class="hljs-built_in">push</span>(t);<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your RecentCounter object will be instantiated and called as such:</span><br><span class="hljs-comment"> * RecentCounter* obj = new RecentCounter();</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;ping(t);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>假设计数器时间窗口的大小是w毫秒，其中记录的时间是递增的，那么时间窗口中记录的时间的数目是O（w），因此空间复杂度是O（w）。每当收到一个新的请求ping时，由于可能需要删除O（w）个已经滑出时间窗口的请求，因此时间复杂度也是O（w）。但是由于这个题目中时间窗口的大小为3000毫秒，w是一个常数，因此也可以认为时间复杂度和空间复杂度都是O（1）。</p><p><img src="/2024/05/04/posts/LCR041/image-1.png" alt="LCR042结果"></p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KuiperInfer (自制深度学习推理框架)学习记录</title>
    <link href="/2024/04/30/posts/InferenceFramework/"/>
    <url>/2024/04/30/posts/InferenceFramework/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="KuiperInfer-自制深度学习推理框架-学习记录"><a href="#KuiperInfer-自制深度学习推理框架-学习记录" class="headerlink" title="KuiperInfer (自制深度学习推理框架)学习记录"></a>KuiperInfer (自制深度学习推理框架)学习记录</h1><blockquote><p>本系列文章是对<a href="https://github.com/zjhellofss/KuiperInfer">KuiperInfer (自制深度学习推理框架)</a>项目学习的记录。</p></blockquote><h2 id="第一节课"><a href="#第一节课" class="headerlink" title="第一节课"></a>第一节课</h2><p>启动docker：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl enable docker<br>sudo <span class="hljs-params">system</span>ctl start docker<br>sudo chmod <span class="hljs-number">777</span> /<span class="hljs-keyword">var</span>/run/docker.sock<br>sudo <span class="hljs-params">system</span>ctl restart docker<br></code></pre></td></tr></table></figure><h2 id="第二节课-张量-Tensor-的设计与实现"><a href="#第二节课-张量-Tensor-的设计与实现" class="headerlink" title="第二节课-张量(Tensor)的设计与实现"></a>第二节课-张量(Tensor)的设计与实现</h2><blockquote><p>[!TIP] 思考题</p><p>请你在此暂停阅读，写出你自己对张量类设计的思考，需要有那些数据成员和方法（比如一个张量需要被创建，且能够支持形状的获取），并在课程结束后对比自己的设计和本文的设计，看看区别在哪。</p></blockquote><p>答：数据类型、数据维度、数据排布格式。张量类中定义了多个类方法，如返回张量的宽度、高度、填充数据和张量变形 (reshape)等操作。</p><blockquote><p>[!TIP] 思考题</p><p>请你运行<code>test_create_tensor.cpp</code>中对应的所有单元测试，观察张量创建的情况和不同方法获取的结果。（如果有不认识的方法不用担心，接下来马上会介绍。） 我们强烈建议你调试课件中提及的所有单元测试，并仔细观察数据的逐步变化，更欢迎你自己编写单元测试对其他方法进行熟悉。</p></blockquote><blockquote><p>[!TIP] .vscode配置</p></blockquote><p> 在 VS Code 中使用 Ctrl+Shift+P打开命令面板，输入Preferences: Open User Settings或Preferences: Open Workspace Settings。</p><h2 id="第二节课"><a href="#第二节课" class="headerlink" title="第二节课"></a>第二节课</h2><p>代码模板有个问题，在tensor.cpp中，Reshape函数中的<code>const uint32_t current_size = std::accumulate(shapes.begin(), shapes.end(), 1, std::multiplies()); </code>会出现<code>argument list for class template &quot;std::multiplies&quot; is missing</code>的错误。这是因为，<strong>在 C++17 及更高版本中，std::multiplies 的默认模板参数被删除了，因此你需要显式地提供模板参数。</strong> 将其修改为：&#96;const uint32_t current_size &#x3D; std::accumulate(shapes.begin(), shapes.end(), 1, std::multiplies<uint32_t>());</uint32_t></p><p>作业1补充代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> Tensor&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">Flatten</span>(<span class="hljs-type">bool</span> row_major) &#123;<br>  <span class="hljs-built_in">CHECK</span>(!<span class="hljs-keyword">this</span>-&gt;data_.<span class="hljs-built_in">empty</span>());<br>  <span class="hljs-comment">// 请补充代码</span><br>  std::vector&lt;<span class="hljs-type">uint32_t</span>&gt; new_shapes = std::vector&lt;<span class="hljs-type">uint32_t</span>&gt;&#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">size</span>() &#125;;<br>  <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Reshape</span>(new_shapes, row_major);<br>&#125;<br></code></pre></td></tr></table></figure><p>Reshape函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> Tensor&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">Reshape</span>(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">uint32_t</span>&gt;&amp; shapes,<br>                            <span class="hljs-type">bool</span> row_major) &#123;<br>  <span class="hljs-built_in">CHECK</span>(!<span class="hljs-keyword">this</span>-&gt;data_.<span class="hljs-built_in">empty</span>());<br>  <span class="hljs-built_in">CHECK</span>(!shapes.<span class="hljs-built_in">empty</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> origin_size = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">size</span>();<br>  <span class="hljs-comment">// const uint32_t current_size =</span><br>  <span class="hljs-comment">//    std::accumulate(shapes.begin(), shapes.end(), 1, std::multiplies());</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> current_size = std::<span class="hljs-built_in">accumulate</span>(shapes.<span class="hljs-built_in">begin</span>(), shapes.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>, std::<span class="hljs-built_in">multiplies</span>&lt;<span class="hljs-type">uint32_t</span>&gt;());<br><br>  <span class="hljs-built_in">CHECK</span>(shapes.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">3</span>);<br>  <span class="hljs-built_in">CHECK</span>(current_size == origin_size);<br><br>  std::vector&lt;<span class="hljs-type">float</span>&gt; values;<br>  <span class="hljs-keyword">if</span> (row_major) &#123;<br>    values = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">values</span>(<span class="hljs-literal">true</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (shapes.<span class="hljs-built_in">size</span>() == <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;data_.<span class="hljs-built_in">reshape</span>(shapes.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>), shapes.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>), shapes.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">this</span>-&gt;raw_shapes_ = &#123;shapes.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>), shapes.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>), shapes.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>)&#125;;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shapes.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;data_.<span class="hljs-built_in">reshape</span>(shapes.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>), shapes.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>), <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">this</span>-&gt;raw_shapes_ = &#123;shapes.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>), shapes.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>)&#125;;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">this</span>-&gt;data_.<span class="hljs-built_in">reshape</span>(<span class="hljs-number">1</span>, shapes.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>), <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">this</span>-&gt;raw_shapes_ = &#123;shapes.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>)&#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (row_major) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Fill</span>(values, <span class="hljs-literal">true</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Fill函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> Tensor&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">Fill</span>(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">float</span>&gt;&amp; values, <span class="hljs-type">bool</span> row_major) &#123;<br>  <span class="hljs-built_in">CHECK</span>(!<span class="hljs-keyword">this</span>-&gt;data_.<span class="hljs-built_in">empty</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> total_elems = <span class="hljs-keyword">this</span>-&gt;data_.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-built_in">CHECK_EQ</span>(values.<span class="hljs-built_in">size</span>(), total_elems);<br>  <span class="hljs-keyword">if</span> (row_major) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> rows = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">rows</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> cols = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">cols</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> planes = rows * cols;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> channels = <span class="hljs-keyword">this</span>-&gt;data_.n_slices;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; channels; ++i) &#123;<br>      <span class="hljs-keyword">auto</span>&amp; channel_data = <span class="hljs-keyword">this</span>-&gt;data_.<span class="hljs-built_in">slice</span>(i);<br>      <span class="hljs-type">const</span> arma::fmat&amp; <span class="hljs-type">channel_data_t</span> =<br>          arma::<span class="hljs-built_in">fmat</span>(values.<span class="hljs-built_in">data</span>() + i * planes, <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">cols</span>(), <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">rows</span>());<br>      channel_data = <span class="hljs-type">channel_data_t</span>.<span class="hljs-built_in">t</span>();<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    std::<span class="hljs-built_in">copy</span>(values.<span class="hljs-built_in">begin</span>(), values.<span class="hljs-built_in">end</span>(), <span class="hljs-keyword">this</span>-&gt;data_.<span class="hljs-built_in">memptr</span>());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：armadillo库默认矩阵是按列优先存储的，所以如果要按照行优先填充，应该针对每个channel，将原矩阵每个channel的转置赋值给它，即<code>channel_data = channel_data_t.t();</code>。如果是列优先，直接复制即可，即<code>std::copy(values.begin(), values.end(), this-&gt;data_.memptr());</code>。</p><h2 id="第三节课"><a href="#第三节课" class="headerlink" title="第三节课"></a>第三节课</h2><h3 id="胶水算子"><a href="#胶水算子" class="headerlink" title="胶水算子"></a>胶水算子</h3><blockquote><p>[!NOTE]胶水算子是什么？<br>胶水算子（Glue Operator）是深度学习领域的一个概念，主要用于将不同的神经网络模块连接在一起。在模型构建过程中，尤其是在涉及多分支结构或需要整合不同特征的网络中，胶水算子扮演着非常重要的角色。</p><p><strong>胶水算子的作用</strong></p><p>胶水算子通常用于以下几种场景：</p><ol><li>连接不同维度的张量：在神经网络中，不同的分支可能会产生不同维度的张量。为了将这些张量合并或进行进一步操作，胶水算子可以对这些张量进行拼接（concatenate）或其他操作，使得它们可以正确地被后续的层处理。</li><li>融合多种特征：在处理多模态数据或多种特征时，胶水算子可以将这些不同来源的特征进行融合。常见的融合操作包括加法、拼接、平均、乘法等。</li><li>调整数据格式或形状：在某些情况下，数据的形状或格式可能不匹配，这时候胶水算子可以通过变换或重新排列数据的形状，使得数据能够被后续层顺利处理。</li></ol><p>常见的胶水算子</p><p>以下是一些在深度学习中常见的胶水算子：</p><ol><li>拼接（Concatenation）：将多个张量沿着某一维度进行拼接，例如在特征维度上拼接来自不同卷积核的特征图。</li><li>加法（Addition）：将多个张量逐元素相加，这种方式通常用于残差网络（ResNet）中的跳跃连接。</li><li>乘法（Multiplication）：逐元素相乘，用于特征增强或门控机制。</li><li>平均（Averaging）：对多个张量进行逐元素平均，用于融合多种特征。</li><li>堆叠（Stacking）：类似于拼接，但一般是在新增维度上堆叠多个张量，形成一个新的高维张量。</li></ol><p>胶水算子的应用场景</p><ol><li>多分支神经网络：在像Inception模块或ResNet等结构中，胶水算子被广泛使用，用于整合来自不同分支的特征。</li><li>特征融合：在处理图像、文本、音频等多模态数据时，胶水算子可以帮助融合这些不同模态的特征，构建更强大的模型。</li><li>注意力机制：在一些注意力机制（如自注意力机制）中，胶水算子可以用于整合来自不同位置或不同头部的注意力结果。</li></ol><p><strong>总结</strong></p><p>胶水算子在神经网络中扮演着连接和融合的角色，帮助不同的网络模块协同工作，从而实现更复杂的特征提取和处理。它的使用可以大大增强模型的灵活性和表现力。</p></blockquote><h3 id="LayerNorm"><a href="#LayerNorm" class="headerlink" title="LayerNorm"></a><a href="https://blog.csdn.net/Little_White_9/article/details/123345062">LayerNorm</a></h3><p>BatchNorm是把不同样本的同一通道做标准化，它保留了不同样本之间同一通道的差异，但抹去了同一样本不同通道的差距，适用于CV。</p><p><img src="/2024/04/30/posts/InferenceFramework/image-1.png" alt="batchnorm公式"></p><p>LayerNorm是把同一样本的不同通道做标准化，它保留了同一样本内不同通道的差异，抹去了不同样本之间差异，适用于NLP。</p><p><img src="/2024/04/30/posts/InferenceFramework/image.png" alt="layernorm公式"></p><p>视觉的特征是客观存在的特征，而语义特征更多是由上下文语义决定的一种统计特征，因此他们的标准化方法也会有所不同。</p><p><a href="https://github.com/Tencent/ncnn">ncnn</a>是腾讯优图推出的在手机端极致优化的高性能神经网络前向计架框架，适用于手机端的CPU计算且无需依赖第三方计算库，ncnn只用作推理而非边训练边推理。</p><h3 id="算子融合"><a href="#算子融合" class="headerlink" title="算子融合"></a>算子融合</h3><p>在不进行算子融合的情况下，卷积层和批归一化层是依次执行的两个独立操作，这意味着需要分别计算卷积的输出，再将输出传递给批归一化层进行标准化，这样会涉及中间结果的存储和额外的计算。</p><p>算子融合的基本思路是将批归一化的计算直接嵌入到卷积计算中，从而减少中间计算和数据传输。</p><h2 id="第五节课"><a href="#第五节课" class="headerlink" title="第五节课"></a>第五节课</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><a href="https://blog.csdn.net/ddllrrbb/article/details/78215277">单例模式</a></h3><p>单例大约有两种实现方法：懒汉与饿汉。</p><ul><li>懒汉：看名字就知道，不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化，所以上边的经典方法被归为懒汉实现；</li><li>饿汉：饿了肯定要饥不择食。所以在单例类定义的时候就进行实例化。</li></ul><p>　<br>特点与选择：</p><ul><li>由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。</li><li>在访问量较小时，采用懒汉实现。这是以时间换空间。</li></ul><p>“Magic Static” 是 C++11 标准中引入的一个特性，它指的是在函数内部定义的静态变量（包括局部静态变量）。这种变量只会在第一次执行该函数时被初始化，而且这种初始化是线程安全的。即使多个线程同时第一次调用该函数，静态变量也只会被初始化一次，并且在初始化完成前，其他线程会被阻塞，等待初始化完成后再访问该变量。</p><p>这个特性常用于实现单例模式（Singleton Pattern）或类似需要懒初始化的场景。相比于传统的双重检查锁定，使用“Magic Static”可以简化代码，同时确保线程安全。例如，实现一个单例类时，可以在一个静态成员函数中定义一个静态局部变量，这个变量就是单例实例，当多个线程同时尝试获取该实例时，C++11 标准保证了只有一个线程会进行初始化，其他线程会等待，直到实例被初始化完成。</p>]]></content>
    
    
    <categories>
      
      <category>AISystem</category>
      
      <category>自制深度学习推理框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自制深度学习推理框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR036-LCR040栈的应用</title>
    <link href="/2024/04/29/posts/LCR036/"/>
    <url>/2024/04/29/posts/LCR036/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）6-2-栈的应用"><a href="#剑指offer（专项突破版）6-2-栈的应用" class="headerlink" title="剑指offer（专项突破版）6.2 栈的应用"></a>剑指offer（专项突破版）6.2 栈的应用</h1><h2 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/8Zf90G/description/">逆波兰表达式求值</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果是数字就入栈，如果是符号就出栈两个数字来做运算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string op, <span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;+&quot;</span>)<br>            <span class="hljs-keyword">return</span> num2 + num1;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;-&quot;</span>)<br>            <span class="hljs-keyword">return</span> num2 - num1;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;*&quot;</span>)<br>            <span class="hljs-keyword">return</span> num2 * num1;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;/&quot;</span>)<br>            <span class="hljs-keyword">return</span> num2 / num1;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stack;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tokens.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            string token = tokens[i];<br>            <span class="hljs-keyword">if</span>(token == <span class="hljs-string">&quot;+&quot;</span> || token == <span class="hljs-string">&quot;-&quot;</span> || token == <span class="hljs-string">&quot;*&quot;</span> || token == <span class="hljs-string">&quot;/&quot;</span>)&#123;<br>                <span class="hljs-type">int</span> num1 = stack.<span class="hljs-built_in">top</span>();<br>                stack.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> num2 = stack.<span class="hljs-built_in">top</span>();<br>                stack.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> res = <span class="hljs-built_in">calculate</span>(token, num1, num2);<br>                stack.<span class="hljs-built_in">push</span>(res);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                stack.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(token));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：如果输入数组的长度是n，那么对其中的每个字符串都有一次push操作；如果是操作符，那么还需要进行数学计算和两次push操作。由于每个push操作、pop操作和数学计算都是O（1），因此总体时间复杂度是O（n）。</li><li>空间复杂度：由于栈中可能有O（n）个操作数，因此这种解法的空间复杂度也是O（n）。</li></ul><p><img src="/2024/04/29/posts/LCR036/image.png" alt="LCR036结果"></p><h2 id="行星碰撞"><a href="#行星碰撞" class="headerlink" title="行星碰撞"></a><a href="https://leetcode.cn/problems/XagZNi/description/">行星碰撞</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>如果一颗小行星向右飞行，那么可以将它入栈。如果一颗小行星是向左飞行的，而位于栈顶的小行星向右飞行，那么它将与位于栈顶的小行星相撞。如果位于栈顶的小行星较小，那么它将爆炸消失，也就是说它将出栈。然后判断它是否将与下一颗位于栈顶的小行星相撞。如果小行星与栈中所有小行星相撞之后仍然没有爆炸消失，那么将它入栈。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">asteroidCollision</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; asteroids)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stack;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; asteroids.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-comment">// 如果是向右飞行，则入栈</span><br>            <span class="hljs-keyword">if</span>(asteroids[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                stack.<span class="hljs-built_in">push</span>(asteroids[i]);<br>            &#125;<br>            <span class="hljs-comment">// 如果向左飞行</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 如果栈顶向右飞行且小于该行星</span><br>                <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>() &amp;&amp; stack.<span class="hljs-built_in">top</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; stack.<span class="hljs-built_in">top</span>() &lt; <span class="hljs-built_in">abs</span>(asteroids[i]))&#123;<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <span class="hljs-comment">// 如果等于</span><br>                <span class="hljs-keyword">if</span>(!stack.<span class="hljs-built_in">empty</span>() &amp;&amp; stack.<span class="hljs-built_in">top</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; stack.<span class="hljs-built_in">top</span>() == <span class="hljs-built_in">abs</span>(asteroids[i]))&#123;<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">empty</span>() || stack.<span class="hljs-built_in">top</span>() &lt; <span class="hljs-number">0</span>)&#123;<br>                    stack.<span class="hljs-built_in">push</span>(asteroids[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 写入vector</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(stack.<span class="hljs-built_in">top</span>());<br>            stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：假设有n颗小行星。上述代码中有一个嵌套的二重循环，它的时间复杂度是不是O（n2）？由于每颗小行星只可能入栈、出栈一次，因此时间复杂度是O（n）。</li><li>空间复杂度：O（n）。</li></ul><p><img src="/2024/04/29/posts/LCR036/image-1.png" alt="LCR037结果"></p><h2 id="LCR038-每日温度"><a href="#LCR038-每日温度" class="headerlink" title="LCR038.每日温度"></a><a href="https://leetcode.cn/problems/iIQa4I/description/">LCR038.每日温度</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ul><li>入栈：当栈为空，或者当前值小于栈顶；</li><li>出栈：当前值大于栈顶，可以计算出差值，弹出，再检查下一个栈顶。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stack;<br>        <span class="hljs-type">int</span> n = temperatures.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-comment">// 出栈</span><br>            <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[stack.<span class="hljs-built_in">top</span>()])&#123;<br>                res[stack.<span class="hljs-built_in">top</span>()] = i - stack.<span class="hljs-built_in">top</span>();<br>                stack.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-comment">// 入栈</span><br>            stack.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：假设输入数组的长度为n。虽然上述代码中有一个嵌套的二重循环，但它的时间复杂度是O（n），这是因为数组中每个温度入栈、出栈各1次。</li><li>空间复杂度：O(n)</li></ul><p><img src="/2024/04/29/posts/LCR036/image-2.png" alt="LCR038结果"></p><h2 id="LCR039-柱状图中最大的矩形"><a href="#LCR039-柱状图中最大的矩形" class="headerlink" title="LCR039.柱状图中最大的矩形"></a><a href="https://leetcode.cn/problems/0ynMMM/description/">LCR039.柱状图中最大的矩形</a></h2><h3 id="蛮力法"><a href="#蛮力法" class="headerlink" title="蛮力法"></a>蛮力法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = heights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> minH = heights[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; n; j++)&#123;<br>                <span class="hljs-type">int</span> w = j - i + <span class="hljs-number">1</span>;<br>                minH = <span class="hljs-built_in">min</span>(minH, heights[j]);<br>                <span class="hljs-type">int</span> area = w * minH;<br>                res = <span class="hljs-built_in">max</span>(res, area);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n^2)</li><li>空间复杂度：O(1)</li></ul><p>蛮力法无法通过所有测试点。</p><p><img src="/2024/04/29/posts/LCR036/image-3.png" alt="LCR039蛮力法"></p><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>直方图中最矮的柱子在数组中的下标是5，它的高度是1。这个直方图的最大矩形有3种可能。第1种是矩形通过这根最矮的柱子。通过最矮的柱子的最大矩形的高为1，宽是7。第2种是矩形的起始柱子和终止柱子都在最矮的柱子的左侧，也就是从下标为0的柱子到下标为4的柱子的直方图的最大矩形。第3种是矩形的起始柱子和终止柱子都在最矮的柱子的右侧，也就是从下标为6的柱子到下标为7的柱子的直方图的最大矩形。第2种和第3种从本质上来说和求整个直方图的最大矩形面积是同一个问题，可以调用递归函数解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归结束条件</span><br>        <span class="hljs-keyword">if</span>(low == high)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(low+<span class="hljs-number">1</span> == high)&#123;<br>            <span class="hljs-keyword">return</span> heights[low];<br>        &#125;<br>        <span class="hljs-comment">// 找到区间内最小的值</span><br>        <span class="hljs-type">int</span> minIndex = low;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = low; i &lt; high; i++)&#123;<br>            <span class="hljs-keyword">if</span>(heights[i] &lt; heights[minIndex])&#123;<br>                minIndex = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 计算面积</span><br>        <span class="hljs-type">int</span> area = (high - low) * heights[minIndex];<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">largestArea</span>(heights, low, minIndex);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">largestArea</span>(heights,minIndex+<span class="hljs-number">1</span>,high);<br><br>        <span class="hljs-comment">// 返回最大值</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">max</span>(area, left);<br>        res = <span class="hljs-built_in">max</span>(res, right);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">largestArea</span>(heights, <span class="hljs-number">0</span>, heights.<span class="hljs-built_in">size</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：假设输入数组的长度为n。如果每次都能将n根柱子分成两根柱子数量为n&#x2F;2的子直方图，那么递归调用的深度为O（logn），整个分治法的时间复杂度是O（nlogn）。但如果直方图中柱子的高度是排序的（递增排序或递减排序），那么每次最矮的柱子都位于直方图的一侧，递归调用的深度就是O（n），此时分治法的时间复杂度也变成$O（n^2）$。</li><li>空间复杂度：基于递归的分治法需要消耗内存来保存递归调用栈，空间复杂度取决于调用栈的深度，因此这种分治法的平均空间复杂度是O（logn），最坏情况下的空间复杂度是O（n）。</li></ul><p>这种方法也无法通过所有的测试点。</p><p><img src="/2024/04/29/posts/LCR036/image-4.png" alt="LCR039分治法"></p><h3 id="单调栈法"><a href="#单调栈法" class="headerlink" title="单调栈法"></a>单调栈法</h3><p>如果当前扫描到的数字比栈顶大，则入栈；反之则将栈顶出栈，并计算以它为顶的矩形面积。找到每个柱子左边第一个比自己矮的，和右边第一个比自己矮的，这两个矮的之间的距离都比这个柱子高或者相等，就能算出以这个柱子为高最大的面积。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stack;<br>        stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> maxArea = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-comment">// 出栈，计算以栈顶为顶的最大面积</span><br>            <span class="hljs-keyword">while</span>(stack.<span class="hljs-built_in">top</span>()!=<span class="hljs-number">-1</span> &amp;&amp; heights[stack.<span class="hljs-built_in">top</span>()] &gt;= heights[i])&#123;<br>                <span class="hljs-type">int</span> h = heights[stack.<span class="hljs-built_in">top</span>()];<br>                stack.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> w = i - stack.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;<br>                maxArea = <span class="hljs-built_in">max</span>(maxArea, h*w);<br>            &#125;<br>            stack.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-comment">// 栈中剩余元素</span><br>        <span class="hljs-keyword">while</span>(stack.<span class="hljs-built_in">top</span>()!=<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-type">int</span> h = heights[stack.<span class="hljs-built_in">top</span>()];<br>            stack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> w = heights.<span class="hljs-built_in">size</span>() - stack.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;<br>            maxArea = <span class="hljs-built_in">max</span>(maxArea, h*w);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：假设输入数组的长度为n。直方图的每根柱子都入栈、出栈一次，并且在每根柱子的下标出栈时计算以它为顶的最大矩形面积，这些操作对每根柱子而言时间复杂度是O（1），因此这种单调栈法的时间复杂度是O（n）。</li><li>空间复杂度：这种解法需要一个辅助栈，栈中可能有O（n）根柱子在数组中的下标，因此空间复杂度是O（n）。</li></ul><p><img src="/2024/04/29/posts/LCR036/image-5.png" alt="LCR039单调栈法结果"></p><h2 id="LCR040-最大矩形"><a href="#LCR040-最大矩形" class="headerlink" title="LCR040.最大矩形"></a><a href="https://leetcode.cn/problems/PLYXKQ/description/">LCR040.最大矩形</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>先把矩阵转换为直方图，再利用上一题中单调栈方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; heights)</span></span>&#123;<br>        <span class="hljs-type">int</span> maxArea = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stack;<br>        stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">while</span>(stack.<span class="hljs-built_in">top</span>()!=<span class="hljs-number">-1</span> &amp;&amp; heights[stack.<span class="hljs-built_in">top</span>()] &gt;= heights[i])&#123;<br>                <span class="hljs-type">int</span> h = heights[stack.<span class="hljs-built_in">top</span>()];<br>                stack.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> w = i - stack.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;<br>                maxArea = <span class="hljs-built_in">max</span>(maxArea, h*w);<br>            &#125;<br>            stack.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-comment">// 栈中剩余元素</span><br>        <span class="hljs-keyword">while</span>(stack.<span class="hljs-built_in">top</span>() != <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-type">int</span> h = heights[stack.<span class="hljs-built_in">top</span>()];<br>            stack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> w = heights.<span class="hljs-built_in">size</span>() - stack.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;<br>            maxArea = <span class="hljs-built_in">max</span>(maxArea, h*w);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(vector&lt;string&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(row == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">heights</span><span class="hljs-params">(matrix[<span class="hljs-number">0</span>].size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> maxArea = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                    heights[j] = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    heights[j] += <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 对每一个直方图求最大面积</span><br>            maxArea = <span class="hljs-built_in">max</span>(maxArea, <span class="hljs-built_in">largestArea</span>(heights));<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：假设输入的矩阵的大小为m×n。该矩阵可以转换成m个直方图。如果采用单调栈法，那么求每个直方图的最大矩形面积需要O（n）的时间，因此这种解法的时间复杂度是O（mn）。</li><li>空间复杂度：用单调栈法计算直方图中最大矩阵的面积需要O（n）的空间，同时还需要一个长度为n的数组heights，用于记录直方图中柱子的高度，因此这种解法的空间复杂度是O（n）。</li></ul><p><img src="/2024/04/29/posts/LCR036/image-6.png" alt="LCR040结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了栈这种常见的数据结构。栈的插入、删除操作都发生在栈的顶部。在栈中插入、删除数据的顺序为“后入先出”，即最后添加的数据最先被删除。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR032-LCR035哈希表的应用</title>
    <link href="/2024/04/26/posts/LCR032/"/>
    <url>/2024/04/26/posts/LCR032/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）5-3-哈希表的应用"><a href="#剑指offer（专项突破版）5-3-哈希表的应用" class="headerlink" title="剑指offer（专项突破版）5.3 哈希表的应用"></a>剑指offer（专项突破版）5.3 哈希表的应用</h1><h2 id="LCR032-有效的字母异位词"><a href="#LCR032-有效的字母异位词" class="headerlink" title="LCR032.有效的字母异位词"></a><a href="https://leetcode.cn/problems/dKk3P7/description/">LCR032.有效的字母异位词</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>遍历第一个字符串，使用数组作为哈希表，字母出现则+1；然后遍历第二个字符串，字母出现则-1；最后判断数组中的值是否全为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-comment">// 两个字符串长度不相等直接返回false</span><br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> n = t.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span>(m != n || s == t)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 哈希表存储</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-comment">// 遍历第一个字符串</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            hash[s[i]<span class="hljs-number">-97</span>]++;<br>        &#125;<br>        <span class="hljs-comment">// 遍历第二个字符串</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            hash[t[i]<span class="hljs-number">-97</span>]--;<br>        &#125;<br>        <span class="hljs-comment">// 检查</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(hash[i])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(1)</li></ul><p><img src="/2024/04/26/posts/LCR032/image.png" alt="LCR032结果"></p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>如果输入字符串包含unicode字符怎么办？</p><p>一个ASCII码字符的长度为8位，所以ASCII码字符集只能包含256个不同的字符，中文及很多语言的字符集都远远超过这个数字。为了包含更多的字符，需要其他编码的字符集，目前使用最多的是Unicode编码。一个Unicode的字符的长度为16位，这样就能表示65536个字符。</p><p>使用真正的哈希表unordered_map&lt;char,int&gt;记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-comment">// 两个字符串长度不相等直接返回false</span><br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> n = t.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span>(m != n || s == t)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 哈希表存储</span><br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-comment">// 遍历第一个字符串</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            hash[s[i]]++;<br>        &#125;<br>        <span class="hljs-comment">// 遍历第二个字符串</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            hash[t[i]]--;<br>        &#125;<br>        <span class="hljs-comment">// 检查</span><br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;::iterator iter;<br>        <span class="hljs-keyword">for</span>(iter = hash.<span class="hljs-built_in">begin</span>(); iter != hash.<span class="hljs-built_in">end</span>(); iter++)&#123;<br>            <span class="hljs-keyword">if</span>(iter-&gt;second)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LCR033-字母异位词分组"><a href="#LCR033-字母异位词分组" class="headerlink" title="LCR033.字母异位词分组"></a><a href="https://leetcode.cn/problems/sfvd7V/description/">LCR033.字母异位词分组</a></h2><h3 id="方法1：将单词的字母排序"><a href="#方法1：将单词的字母排序" class="headerlink" title="方法1：将单词的字母排序"></a>方法1：将单词的字母排序</h3><p>把一组变位词映射到同一个单词。由于互为变位词的单词的字母出现的次数分别相同，因此如果把单词中的字母排序就会得到相同的字符串。例如，把”eat”、”tea”和”ate”的字母按照字母表顺序排序都得到字符串”aet”。</p><p>因此，可以定义一个哈希表，哈希表的键是把单词字母排序得到的字符串，而值为一组变位词。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        <span class="hljs-comment">// 定义结果</span><br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        <span class="hljs-comment">// 哈希表存储排序后的字符串和字符串列表</span><br>        unordered_map&lt;string, vector&lt;string&gt;&gt; hash;<br>        <span class="hljs-comment">// 遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            string key = strs[i];<br>            <span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(), key.<span class="hljs-built_in">end</span>());<br>            hash[key].<span class="hljs-built_in">push_back</span>(strs[i]);<br>        &#125;<br>        <span class="hljs-comment">// 最终结果</span><br>        unordered_map&lt;string, vector&lt;string&gt;&gt;::iterator iter;<br>        <span class="hljs-keyword">for</span>(iter = hash.<span class="hljs-built_in">begin</span>(); iter != hash.<span class="hljs-built_in">end</span>(); iter++)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(iter-&gt;second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>如果每个单词平均有m个字母，排序一个单词需要O（mlogm）的时间。假设总共有n个单词，该算法总的时间复杂度是O（nmlogm）。</li><li>使用了一个哈希表来存储排序后的字符串和对应的字符串列表，哈希表的空间复杂度为 O(n)。最终返回的结果 res 也需要 O(n) 的空间来存储结果。因此，总的空间复杂度为 O(n)。</li></ul><p><img src="/2024/04/26/posts/LCR032/image-1.png" alt="LCR033排序方法结果"></p><h3 id="方法2：计数"><a href="#方法2：计数" class="headerlink" title="方法2：计数"></a>方法2：计数</h3><p>由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。</p><p>由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 262626 的数组记录每个字母出现的次数。需要注意的是，在使用数组作为哈希表的键时，不同语言的支持程度不同，因此不同语言的实现方式也不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 定义一个长为26的字符串来记录每个字符串每个字母出现的次数</span><br>    <span class="hljs-function">string <span class="hljs-title">getString</span><span class="hljs-params">(string s)</span></span>&#123;<br>        <span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-string">&#x27;0&#x27;</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:s)&#123;<br>            str[c-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        <span class="hljs-comment">// 定义结果</span><br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        <span class="hljs-comment">// 哈希表存储排序后的字符串和字符串列表</span><br>        unordered_map&lt;string, vector&lt;string&gt;&gt; hash;<br>        <span class="hljs-comment">// 遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            string key = <span class="hljs-built_in">getString</span>(strs[i]);<br>            hash[key].<span class="hljs-built_in">push_back</span>(strs[i]);<br>        &#125;<br>        <span class="hljs-comment">// 最终结果</span><br>        unordered_map&lt;string, vector&lt;string&gt;&gt;::iterator iter;<br>        <span class="hljs-keyword">for</span>(iter = hash.<span class="hljs-built_in">begin</span>(); iter != hash.<span class="hljs-built_in">end</span>(); iter++)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(iter-&gt;second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度对于每个字符串，生成字符串表示需要遍历字符串一次，时间复杂度为 O(m)。因此，在遍历输入字符串数组时，对每个字符串执行这样的操作，所以总的时间复杂度是 O(mn)，其中 n 是字符串数组的长度，m是字符串的平均长度。</li><li>空间复杂度：和第一种方法相同，O(n)。</li></ul><p><img src="/2024/04/26/posts/LCR032/image-2.png" alt="LCR033计数方法结果"></p><h2 id="LCR034-验证外星语词典"><a href="#LCR034-验证外星语词典" class="headerlink" title="LCR034.验证外星语词典"></a><a href="https://leetcode.cn/problems/lwyVBB/description/">LCR034.验证外星语词典</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>直接的想法是把字母顺序存到哈希表里，键为字母，值为其顺序。然后检查每一个字符串，是否满足这个顺序。怎么检查，逐个字母判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> hash[<span class="hljs-number">26</span>];   <span class="hljs-comment">// 哈希表</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSorted</span><span class="hljs-params">(string s, string t)</span></span>&#123;<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> n = t.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-built_in">min</span>(m,n) &amp;&amp; s[i] == t[i])&#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i == m)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i == n)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(hash[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>] &lt;= hash[t[i]-<span class="hljs-string">&#x27;a&#x27;</span>])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAlienSorted</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, string order)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理字母顺序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)&#123;<br>            hash[order[i]-<span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        <span class="hljs-comment">// 遍历字符串列表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; words.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i++)&#123;<br>            <span class="hljs-type">bool</span> res = <span class="hljs-built_in">isSorted</span>(words[i], words[i+<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span>(!res)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：需要遍历words中的每一个word，假设有n个，每个word平均长度为m，即O(mn)。</li><li>空间复杂度：O(1)。</li></ul><p><img src="/2024/04/26/posts/LCR032/image-3.png" alt="LCR034结果"></p><h2 id="LCR035-最小时间差"><a href="#LCR035-最小时间差" class="headerlink" title="LCR035.最小时间差"></a><a href="https://leetcode.cn/problems/569nqc/">LCR035.最小时间差</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>一天有24小时，即1440分钟。如果用一个长度为1440的数组表示一天的时间，那么数组下标为0的位置对应时间00：00，下标为1的位置对应时间00：01，以此类推，下标为1439的位置对应23：59。数组中的每个元素是true或false的标识，表示对应的时间是否存在于输入的时间数组中。</p><p>有了这个辅助数组，就只需要从头到尾扫描一遍，相邻的两个为true的值表示对应的两个时间在输入时间数组中是相邻的。例如，输入时间数组[“23：50”，”23：59”，”00：00”]，数组中只有下标为0、1430和1439这3个位置的值为true，其他位置的值都是false。</p><p>由于数组的下标对应的是时间，因此两个时间之间的时间差就是它们在数组中对应的下标之差。23：50和23：59之间相隔9分钟，它们在数组中的下标之差也是9。</p><p>其实，这个数组模拟了一个键为时间、值为true或false的哈希表。可以用数组模拟哈希表的原因是一天的分钟数是已知的，而且数组的长度为1440，也不算太长。有了这个数组，就可以和用哈希表一样，在O（1）的时间知道每个时间是否出现在输入的时间数组中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinutes</span><span class="hljs-params">(string s)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> ((s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (s[<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>)) * <span class="hljs-number">60</span> + (s[<span class="hljs-number">3</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (s[<span class="hljs-number">4</span>] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinDifference</span><span class="hljs-params">(vector&lt;string&gt;&amp; timePoints)</span> </span>&#123;<br>        <span class="hljs-comment">// 辅助数组</span><br>        <span class="hljs-type">bool</span> time[<span class="hljs-number">1440</span>] = &#123;<span class="hljs-literal">false</span>&#125;;<br>        <br>        <span class="hljs-comment">// 记录</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; timePoints.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">int</span> index = <span class="hljs-built_in">getMinutes</span>(timePoints[i]);<br>            <span class="hljs-keyword">if</span>(time[index])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            time[index] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 遍历</span><br>        <span class="hljs-type">int</span> res = INT_MAX; <span class="hljs-comment">// 使用INT_MAX作为初始值</span><br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化前一个时间点</span><br>        <span class="hljs-type">int</span> firstTime = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化第一个为真的时间点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1440</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(time[i])&#123;<br>                <span class="hljs-keyword">if</span>(pre != <span class="hljs-number">-1</span>)&#123;<br>                    res = <span class="hljs-built_in">min</span>(res, i - pre);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(firstTime == <span class="hljs-number">-1</span>) firstTime = i; <span class="hljs-comment">// 记录第一个为真的时间点</span><br>                pre = i;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 处理首尾时间点之间的差值</span><br>        res = <span class="hljs-built_in">min</span>(res, <span class="hljs-number">1440</span> - pre + firstTime); <span class="hljs-comment">// 更新结果</span><br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：在记录时间点的循环中，我们遍历了输入数组 timePoints，其时间复杂度为 O(n)，其中 n 是时间点的数量。在遍历辅助数组 time 来计算最小时间差时，我们遍历了一次长度为 1440 的数组，其时间复杂度为 O(1440) &#x3D; O(1)。因此，总的时间复杂度为 O(n)。</li><li>空间复杂度：使用了一个大小为 1440 的辅助数组 time 来记录时间点的出现情况，因此空间复杂度为 O(1)。</li></ul><p><img src="/2024/04/26/posts/LCR032/image-4.png" alt="LCR035结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了哈希表。哈希表的时间效率很高，添加、删除和查找操作的时间复杂度都是O（1）。</p><p>为了设计一个哈希表，首先需要一个数组，把每个键的哈希值映射到数组的一个位置。为了解决冲突，可以把映射到同一位置的多个键用链表存储。同时，为了避免链表太长，当哈希表中元素的数目与数组的长度的比值超过一定的阈值时，则增加数组的长度并根据新的长度重新映射每个键的位置。</p><p>如果结合哈希表和其他数据结构的特点，则还可以设计出很多更加高级、更加复杂的数据结构，如最近最少使用缓存。</p><p>在解决算法面试题时，哈希表是经常被使用的工具，用来记录字符串中字母出现的次数、字符串中字符出现的位置等信息。</p><p>如果哈希表的键的数目是固定的，并且数目不太大，那么也可以用数组来模拟哈希表，数组的下标对应哈希表的键，而数组的值与哈希表的值对应。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR030-LCR031哈希表的设计</title>
    <link href="/2024/04/25/posts/LCR030/"/>
    <url>/2024/04/25/posts/LCR030/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）5-2-哈希表的设计"><a href="#剑指offer（专项突破版）5-2-哈希表的设计" class="headerlink" title="剑指offer（专项突破版）5.2 哈希表的设计"></a>剑指offer（专项突破版）5.2 哈希表的设计</h1><p>设计哈希表的前提是待存入的元素需要一个能计算自己哈希值的函数。在Java中所有类型都继承了类型Object，每个Object的实例都可以通过定义函数hashCode来计算哈希值。哈希表根据每个元素的哈希值把它存储到合适的位置。</p><p>哈希表最重要的特点就是高效，只需要O（1）的时间就可以把一个元素存入或读出。在常用的基础数据结构中，数组满足这个要求。只要知道数组中的下标，就可以用O（1）的时间存入或读出一个元素。因此，可以考虑基于数组实现哈希表。</p><p>设计哈希表有3个要点。为了快速确定一个元素在哈希表中的位置，可以使用一个数组，元素的位置为它的哈希值除以数组长度的余数。由于多个哈希值不同的元素可能会被存入同一位置，数组的每个位置都对应一个链表，因此存入同一位置的多个元素都被添加到同一链表中。为了确保链表不会太长，就需要计算哈希表中元素的数目与数组长度的比值。当这个比值超过某个阈值时，就对数组进行扩容并把哈希表中的所有元素重新分配位置。</p><h2 id="LCR030-插入、删除和随机访问都是O（1）的容器"><a href="#LCR030-插入、删除和随机访问都是O（1）的容器" class="headerlink" title="LCR030.插入、删除和随机访问都是O（1）的容器"></a><a href="https://leetcode.cn/problems/FortPu/description/">LCR030.插入、删除和随机访问都是O（1）的容器</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li>插入</li></ol><p>每次添加新数值时，先使用哈希表判断该数值是否存在，存在则直接返回false。不存在则进行插入操作，只要将该数值添加到数组尾部即可，并将该数值和其下标的映射存入哈希表。</p><ol start="2"><li><p>删除<br>删除同样需使用哈希表判断是否存在，若不存在则返回false。存在则进行删除操作，在哈希表中删除时间复杂度为 O(1)，但是在数值中删除比较麻烦。若只是直接删除，则为了保证数组内存连续性需将删除数值后面的数值均前移一位，时间复杂度为 O(n)。比较好的处理方式是，用数组的最后一个数值去填充需要删除的数值的内存，其他数值在数组中的位置保持不变，并将这个拿来填充的数值的下标更新即可，最后只要删除数组最后一个数值，同样可以保证时间复杂度为 O(1)。</p></li><li><p>随机返回<br>只要随机生成数组下标范围内一个随机下标值，返回该数组下标内的数值即可。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomizedSet</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; numToLocation;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">RandomizedSet</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 已存在，返回false</span><br>        <span class="hljs-keyword">if</span>(numToLocation.<span class="hljs-built_in">count</span>(val))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        numToLocation[val] = nums.<span class="hljs-built_in">size</span>();<br>        nums.<span class="hljs-built_in">push_back</span>(val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 删除一个不存在的元素，返回false</span><br>        <span class="hljs-keyword">if</span>(!numToLocation.<span class="hljs-built_in">count</span>(val))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 相当于把最后一个元素放到要删除的位置，然后删除最后一个元素</span><br>        <span class="hljs-type">int</span> location = numToLocation[val];  <span class="hljs-comment">// 记录要删除元素的位置</span><br>        numToLocation[nums.<span class="hljs-built_in">back</span>()] = location;  <span class="hljs-comment">// 把最后一个元素的位置标记为要删除元素的位置</span><br>        numToLocation.<span class="hljs-built_in">erase</span>(val);   <span class="hljs-comment">// 删除val</span><br>        nums[location] = nums.<span class="hljs-built_in">back</span>();<br>        nums.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get a random element from the set. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-built_in">rand</span>() % nums.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your RandomizedSet object will be instantiated and called as such:</span><br><span class="hljs-comment"> * RandomizedSet* obj = new RandomizedSet();</span><br><span class="hljs-comment"> * bool param_1 = obj-&gt;insert(val);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;remove(val);</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;getRandom();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><img src="/2024/04/25/posts/LCR030/image.png" alt="LCR030结果"></p><h2 id="LCR031-LRU缓存"><a href="#LCR031-LRU缓存" class="headerlink" title="LCR031.LRU缓存"></a><a href="https://leetcode.cn/problems/OrIXps/description/">LCR031.LRU缓存</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ol><li>定义一个双向链表。</li><li>定义一个哈希表，键是put进的键，值是链表中的结点。</li><li>get：不存在返回-1；存在，返回值，然后将结点移到最后（哈希表获取这个值在链表中的结点）。</li><li>put：不存在，插入，并插到最后；存在判断容量是否已满，满了删除头结点，不满直接插入到最后。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义链表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkNode</span>&#123;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> value;<br>    LinkNode* prev;<br>    LinkNode* next;<br>    <span class="hljs-built_in">LinkNode</span>():<span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">prev</span>(<span class="hljs-literal">NULL</span>),<span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<br>    <span class="hljs-built_in">LinkNode</span>(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _value): <span class="hljs-built_in">key</span>(_key),<span class="hljs-built_in">value</span>(_value),<span class="hljs-built_in">prev</span>(<span class="hljs-literal">NULL</span>),<span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    LinkNode* head;<br>    LinkNode* tail;<br>    unordered_map&lt;<span class="hljs-type">int</span>, LinkNode*&gt; cache;<br>    <span class="hljs-type">int</span> cap;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;<br>        <span class="hljs-comment">// 使用伪头结点和伪尾结点</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkNode</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkNode</span>();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>        <span class="hljs-comment">// 初始化容量大小</span><br>        cap = capacity;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果不存在，返回-1</span><br>        <span class="hljs-keyword">if</span>(!cache.<span class="hljs-built_in">count</span>(key))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 移到链表末尾</span><br>            <span class="hljs-built_in">moveToEnd</span>(cache[key]);<br>            <span class="hljs-comment">// 返回值</span><br>            <span class="hljs-keyword">return</span> cache[key]-&gt;value;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果存在</span><br>        <span class="hljs-keyword">if</span>(cache.<span class="hljs-built_in">count</span>(key))&#123;<br>            <span class="hljs-comment">// 更新值</span><br>            cache[key]-&gt;value = value;<br>            <span class="hljs-comment">// 移到末尾</span><br>            <span class="hljs-built_in">moveToEnd</span>(cache[key]);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 判断是否满，满了就删除头</span><br>            <span class="hljs-keyword">if</span>(cache.<span class="hljs-built_in">size</span>() == cap)&#123;<br>                <span class="hljs-type">int</span> delKey = <span class="hljs-built_in">deleteHead</span>();<br>                cache.<span class="hljs-built_in">erase</span>(delKey);<br>            &#125;<br>            <span class="hljs-comment">// 插到末尾</span><br>            LinkNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkNode</span>(key,value);<br>            cache[key] = node;<br>            <span class="hljs-built_in">moveToEnd</span>(node);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 移到表尾</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveToEnd</span><span class="hljs-params">(LinkNode* node)</span></span>&#123;<br>        tail-&gt;prev-&gt;next = node;<br>        node-&gt;prev = tail-&gt;prev;<br>        node-&gt;next = tail;<br>        tail-&gt;prev = node;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除表头</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">int</span> val = head-&gt;next-&gt;key;<br>        head-&gt;next = head-&gt;next-&gt;next;<br>        head-&gt;next-&gt;prev = head;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>先这样吧，看了好久还是不知道哪里出了问题。以后再看。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR028-LCRO29双向链表和循环链表</title>
    <link href="/2024/04/24/posts/LCR028/"/>
    <url>/2024/04/24/posts/LCR028/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）4-5-双向链表和循环链表"><a href="#剑指offer（专项突破版）4-5-双向链表和循环链表" class="headerlink" title="剑指offer（专项突破版）4.5 双向链表和循环链表"></a>剑指offer（专项突破版）4.5 双向链表和循环链表</h1><h2 id="LCR028-扁平化多级双向链表"><a href="#LCR028-扁平化多级双向链表" class="headerlink" title="LCR028.扁平化多级双向链表"></a><a href="https://leetcode.cn/problems/Qv1Da2/">LCR028.扁平化多级双向链表</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>可以用递归的思想：</p><ol><li>基本情况（递归出口）：对于空节点或者已经是叶子节点（即没有子链表）的节点，不需要进行扁平化处理，直接返回。</li><li>递归处理子链表：对于当前节点，如果存在子链表，我们需要先递归地扁平化子链表。</li><li>连接扁平化后的子链表：将扁平化后的子链表连接到当前节点后面。</li><li>继续处理下一个节点：继续递归处理当前节点的下一个节点。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* prev;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* child;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">getFlattenTail</span><span class="hljs-params">(Node* head)</span></span>&#123;<br>        Node* cur = head;<br>        Node* tail = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 最终要返回的结点，子链表的最后一个结点</span><br>        <span class="hljs-comment">// 递归出口：cur==NULL</span><br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            <span class="hljs-comment">// 保存next结点，以便在处理完子链表后链接到这个结点</span><br>            Node* next = cur-&gt;next;<br>            <span class="hljs-comment">// 判断是否有子链表</span><br>            <span class="hljs-keyword">if</span>(cur-&gt;child)&#123;<br>                Node* child = cur-&gt;child;    <span class="hljs-comment">// 保存子结点</span><br>                cur-&gt;next = child;  <span class="hljs-comment">// 改变cur的next指针</span><br>                child-&gt;prev = cur;  <span class="hljs-comment">// 双向链表</span><br>                cur-&gt;child = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 去掉子链表</span><br>                <span class="hljs-comment">// 下面让子链表的最后一个结点指向next结点</span><br>                <span class="hljs-comment">// 找到子链表的最后一个结点，要先扁平化子链表</span><br>                Node* childTail = <span class="hljs-built_in">getFlattenTail</span>(child);<br>                childTail-&gt;next = next;<br>                <span class="hljs-keyword">if</span>(next)&#123;<br>                    next-&gt;prev = childTail;<br>                &#125;<br>                tail = childTail; <span class="hljs-comment">// 更新tail</span><br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                tail = cur;<br>            &#125;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tail;<br>    &#125;<br>    <span class="hljs-function">Node* <span class="hljs-title">flatten</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-built_in">getFlattenTail</span>(head);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种解法每个节点都会遍历一次，如果链表总共有n个节点，那么时间复杂度是O（n）。函数flattenGetTail的递归调用次数取决于链表嵌套的层数，因此，如果链表的层数为k，那么该节点的空间复杂度是O（k）。</p><p><img src="/2024/04/24/posts/LCR028/image.png" alt="LCR028结果"></p><h2 id="LCR029-循环有序链表的插入"><a href="#LCR029-循环有序链表的插入" class="headerlink" title="LCR029.循环有序链表的插入"></a><a href="https://leetcode.cn/problems/4ueAj6/description/">LCR029.循环有序链表的插入</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>先试图在链表中找到相邻的两个节点，如果这两个节点的前一个节点的值比待插入的值小并且后一个节点的值比待插入的值大，那么就将新节点插入这两个节点之间。如果找不到符合条件的两个节点，即待插入的值大于链表中已有的最大值或小于已有的最小值，那么新的节点将被插入值最大的节点和值最小的节点之间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, Node* _next) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = _next;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">insert</span><span class="hljs-params">(Node* head, <span class="hljs-type">int</span> insertVal)</span> </span>&#123;<br>        Node* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(insertVal);<br>        <span class="hljs-comment">// 处理边界情况</span><br>        <span class="hljs-keyword">if</span>(!head)&#123;<br>            head = node;<br>            head-&gt;next = head;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(head-&gt;next == head)&#123;<br>            head-&gt;next = node;<br>            node-&gt;next = head;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 找到值比insertVal小但next值比它大的结点</span><br>        Node* cur = head;<br>        Node* next = cur-&gt;next;<br>        Node* biggest = head;<br>        <span class="hljs-keyword">while</span>(!(cur-&gt;val &lt;= insertVal &amp;&amp; next-&gt;val &gt;= insertVal) &amp;&amp; next != head)&#123;<br>            cur = next;<br>            next = next-&gt;next;<br>            <span class="hljs-keyword">if</span>(cur-&gt;val &gt;= biggest-&gt;val)&#123;<br>                biggest = cur;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cur-&gt;val &lt;= insertVal &amp;&amp; next-&gt;val &gt;= insertVal)&#123;<br>            cur-&gt;next = node;<br>            node-&gt;next = next;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            next = biggest-&gt;next;<br>            biggest-&gt;next = node;<br>            node-&gt;next = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意<code>if(cur-&gt;val &gt;= biggest-&gt;val)</code>这一判断条件必须是<code>&gt;=</code>，因为需要更新到最后一个biggest。否则对于<code>head=[1,3,3],insertVal=4</code>这一输入，会得到<code>[1,3,4,3]</code>的错误结果。</p><p><img src="/2024/04/24/posts/LCR028/image-1.png" alt="LCR029结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章详细讨论了链表这种基础数据结构。由于节点在内存中的地址不连续，访问某个节点必须从头节点开始逐个遍历节点，因此在链表中找到某个节点的时间复杂度是O（n）。</p><p>如果一个操作可能产生新的头节点，则可以尝试在链表的最前面添加一个哨兵节点来简化代码逻辑，降低代码出现问题的可能性。</p><p>双指针是解决与链表相关的面试题的一种常用技术。前后双指针思路让一个指针提前走若干步，然后将第2个指针指向头节点，两个指针以相同的速度一起走。快慢双指针让快的指针每次走两步而慢的指针每次只走一步。</p><p>大部分与链表相关的面试题都是考查单向链表的操作。单向链表的特点是只能从前往后遍历而不能从后往前遍历。如果不得不从后往前遍历链表，则可以把链表反转之后再遍历。</p><p>如果链表中的节点除了有指向下一个节点的指针，还有指向前一个节点的指针，那么该链表就是双向链表。由于双向链表的操作牵涉到的指针比较多，因此应聘者在解决面试题的时候要格外小心，确保每个指针都指向了正确的位置。</p><p>循环链表是一种特殊形态的链表，它的所有节点都在一个环中。在解决与循环链表相关的面试题时需要特别注意避免死循环，遍历链表时等所有节点都遍历完就要停止，不能一直在里面绕圈子出不来。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR024-LCR027反转链表</title>
    <link href="/2024/04/18/posts/LCR024/"/>
    <url>/2024/04/18/posts/LCR024/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）4-4-反转链表"><a href="#剑指offer（专项突破版）4-4-反转链表" class="headerlink" title="剑指offer（专项突破版）4.4 反转链表"></a>剑指offer（专项突破版）4.4 反转链表</h1><h2 id="LCR024-反转链表"><a href="#LCR024-反转链表" class="headerlink" title="LCR024.反转链表"></a><a href="https://leetcode.cn/problems/UHnkqh/description/">LCR024.反转链表</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对于每一个要转换其next指针的结点，需要保存它的前驱和后继，先让它的next指向前驱，然后再向后移动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode *prev = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 头结点前驱</span><br>        ListNode *cur = head;   <span class="hljs-comment">// 当前要转换的结点</span><br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode *next = cur-&gt;next; <span class="hljs-comment">// 保存当前结点的后继</span><br>            cur-&gt;next = prev;   <span class="hljs-comment">// 转换指向</span><br>            prev = cur; <span class="hljs-comment">// 更新前驱结点</span><br>            cur = next; <span class="hljs-comment">// 更新当前结点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>变量cur指向当前遍历到的节点，变量prev指向当前节点的前一个节点，而变量next指向下一个节点。每遍历一个节点之后，都让变量prev指向该节点。在遍历到尾节点之后，变量prev最后一次被更新，因此，变量prev最终指向原始链表的尾节点，也就是反转链表的头节点。</p><p>显然，上述代码的时间复杂度是O（n），空间复杂度是O（1）。</p><h2 id="LCR025-链表中的两数相加"><a href="#LCR025-链表中的两数相加" class="headerlink" title="LCR025.链表中的两数相加"></a><a href="https://leetcode.cn/problems/lMSNwu/description/">LCR025.链表中的两数相加</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>把两个链表反转，再相加，得到的和链表再反转。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        ListNode *prev = <span class="hljs-literal">NULL</span>;<br>        ListNode *cur = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode *next = cur-&gt;next;<br>            cur-&gt;next = prev;<br>            prev = cur;<br>            cur = next;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode *num1 = <span class="hljs-built_in">reverseList</span>(l1);<br>        ListNode *num2 = <span class="hljs-built_in">reverseList</span>(l2);<br>        ListNode *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode *res = node;<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(num1 &amp;&amp; num2)&#123;<br>            <span class="hljs-type">int</span> sum = num1-&gt;val + num2-&gt;val + carry;<br>            carry = sum / <span class="hljs-number">10</span>;<br>            ListNode *cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            res-&gt;next = cur;<br>            num1 = num1-&gt;next;<br>            num2 = num2-&gt;next;<br>            res = res-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(num1)&#123;<br>            <span class="hljs-type">int</span> sum = num1-&gt;val + carry;<br>            carry = sum / <span class="hljs-number">10</span>;<br>            ListNode *cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            res-&gt;next = cur;<br>            num1 = num1-&gt;next;   <br>            res = res-&gt;next;         <br>        &#125;<br>        <span class="hljs-keyword">while</span>(num2)&#123;<br>            <span class="hljs-type">int</span> sum = num2-&gt;val + carry;<br>            carry = sum / <span class="hljs-number">10</span>;<br>            ListNode *cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            res-&gt;next = cur;<br>            num2 = num2-&gt;next;<br>            res = res-&gt;next;             <br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry)&#123;<br>            ListNode *cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>);<br>            res-&gt;next = cur;<br>        &#125;<br>        node = node-&gt;next;<br>        res = <span class="hljs-built_in">reverseList</span>(node);<br>        <span class="hljs-keyword">return</span> res;       <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(max(m, n))。</li><li>空间复杂度：需要使用额外的空间来存储反转后的两个链表和最终的结果链表，它们的长度分别是 max(m, n)，因此空间复杂度为 O(max(m, n))。</li></ul><p><img src="/2024/04/18/posts/LCR024/image.png" alt="LCR025结果"></p><h2 id="LCR026-重排链表"><a href="#LCR026-重排链表" class="headerlink" title="LCR026.重排链表"></a><a href="https://leetcode.cn/problems/LGjMqU/description/">LCR026.重排链表</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>把链表分成两部分，后半部分逆转，再分别与前半部分的结点连接起来。要找到中间结点，可以使用快慢指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <br> <span class="hljs-comment">// 找到中间结点</span><br> <span class="hljs-function">ListNode* <span class="hljs-title">findMidNode</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>    <span class="hljs-comment">// 快慢指针法</span><br>    ListNode *slow = head-&gt;next;<br>    ListNode *fast = slow-&gt;next;<br>    <span class="hljs-keyword">while</span>(fast-&gt;next)&#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next;<br>        <span class="hljs-keyword">if</span>(fast-&gt;next)&#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br> &#125;<br> <span class="hljs-comment">// 反转链表</span><br> <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>    ListNode *cur = head;<br>    ListNode *prev = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(cur)&#123;<br>        ListNode *next = cur-&gt;next;<br>        cur-&gt;next = prev;<br>        prev = cur;<br>        cur = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br> &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理边界</span><br>        <span class="hljs-keyword">if</span>(!head-&gt;next || !head-&gt;next-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 使用哨兵结点</span><br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br>        <span class="hljs-comment">// 找到中间结点</span><br>        ListNode *mid = <span class="hljs-built_in">findMidNode</span>(head);<br>        <span class="hljs-comment">// 后半部分反转</span><br>        mid = <span class="hljs-built_in">reverseList</span>(mid);<br>        <span class="hljs-comment">// 连接起来</span><br>        ListNode *prev = dummy;<br>        ListNode *first = head;<br>        ListNode *second = mid;<br>        <span class="hljs-keyword">while</span>(first &amp;&amp; second &amp;&amp; first != second)&#123;<br>            <span class="hljs-comment">// 记录下一个</span><br>            ListNode *fnext = first-&gt;next;<br>            ListNode *snext = second-&gt;next;<br>            <span class="hljs-comment">// first连接到prev</span><br>            prev-&gt;next = first;<br>            <span class="hljs-comment">// second连接到first</span><br>            first-&gt;next = second;<br>            <span class="hljs-comment">// 移动prev,first,second</span><br>            prev = second;<br>            first = fnext;<br>            second = snext;<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：<ul><li>找到中间节点：采用快慢指针法，时间复杂度为 O(n)，其中 n 是链表的长度。</li><li>反转后半部分链表：采用迭代方式，时间复杂度为 O(n)，其中 n 是后半部分链表的长度。</li><li>合并两个链表：在合并过程中，每次迭代都会连接一个节点，因此时间复杂度也是 O(n)，其中 n 是链表的长度。</li></ul></li><li>空间复杂度：O(1)</li></ul><p><img src="/2024/04/18/posts/LCR024/image-2.png" alt="LCR026结果"></p><h2 id="LCR027-回文链表"><a href="#LCR027-回文链表" class="headerlink" title="LCR027.回文链表"></a><a href="https://leetcode.cn/problems/aMhZSa/description/">LCR027.回文链表</a></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>和LCR026的思路是一样的，先找到中间结点，再把后半部分进行反转，然后比较是否相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// 找到中间结点</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">findMidNode</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>        ListNode *slow = head;<br>        ListNode *fast = head-&gt;next;<br>        <span class="hljs-keyword">while</span>(fast-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast-&gt;next)&#123;<br>                fast = fast-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>    <span class="hljs-comment">// 反转链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>        ListNode *cur = head;<br>        ListNode *prev = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode *next = cur-&gt;next;<br>            cur-&gt;next = prev;<br>            prev = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 找到中间结点（前半部分的最后一个结点）</span><br>        ListNode *mid = <span class="hljs-built_in">findMidNode</span>(head);<br>        <span class="hljs-comment">// 反转后半部分</span><br>        ListNode *back = <span class="hljs-built_in">reverseList</span>(mid-&gt;next);<br>        <span class="hljs-comment">// 判断两部分是否相等</span><br>        ListNode *fore = head;<br>        <span class="hljs-keyword">while</span>(fore &amp;&amp; back)&#123;<br>            <span class="hljs-keyword">if</span>(fore-&gt;val != back-&gt;val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            fore = fore-&gt;next;<br>            back = back-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/2024/04/18/posts/LCR024/image-1.png" alt="LCR027结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>反转链表操作：在反转链表时，需要使用三个指针来记录当前节点、前驱节点和后继节点，然后依次更新它们的指针，实现链表的反转。这个过程需要注意保存链表的头结点和边界条件的处理。</li><li>利用快慢指针找中间节点：在某些情况下，需要找到链表的中间节点，可以利用快慢指针的方法。快指针每次移动两步，慢指针每次移动一步，当快指针到达链表尾部时，慢指针则指向链表的中间节点。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR021-LCR023双指针</title>
    <link href="/2024/04/15/posts/LCR021/"/>
    <url>/2024/04/15/posts/LCR021/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）4-3-双指针"><a href="#剑指offer（专项突破版）4-3-双指针" class="headerlink" title="剑指offer（专项突破版）4.3 双指针"></a>剑指offer（专项突破版）4.3 双指针</h1><h2 id="LCR021-删除链表的倒数第N个结点"><a href="#LCR021-删除链表的倒数第N个结点" class="headerlink" title="LCR021.删除链表的倒数第N个结点"></a><a href="https://leetcode.cn/problems/SLwz0R/description/">LCR021.删除链表的倒数第N个结点</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>使用双指针，首先第一个指针指向头结点，然后走n步，第二个指针不动；第二个指针初始为哨兵结点，随后两个指针同时向后移动，由于两个指针之间相隔n个结点，即当第一个指针指向最后时，第二个指针为倒数第n+1个结点，删除倒数第n个结点，只需将第二个指针的next指向它的next的next。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义哨兵结点</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br>        <span class="hljs-comment">// 双指针</span><br>        ListNode* front = head;<br>        ListNode* back = dummy;<br>        <span class="hljs-comment">// front指针先向前走n步</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            front = front-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 两个指针同时向前</span><br>        <span class="hljs-keyword">while</span>(front != <span class="hljs-literal">NULL</span>)&#123;<br>            front = front-&gt;next;<br>            back = back-&gt;next;<br>        &#125;<br>        back-&gt;next = back-&gt;next-&gt;next;<br>        <br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(L)，其中L是链表的长度。</p><p>空间复杂度：O(1)。</p><p><img src="/2024/04/15/posts/LCR021/image.png" alt="LCR021结果"></p><h2 id="LCR022-环形链表II"><a href="#LCR022-环形链表II" class="headerlink" title="LCR022.环形链表II"></a><a href="https://leetcode.cn/problems/c32eOV/">LCR022.环形链表II</a></h2><h3 id="需要知道环中节点数目的解法"><a href="#需要知道环中节点数目的解法" class="headerlink" title="需要知道环中节点数目的解法"></a>需要知道环中节点数目的解法</h3><p>定义两个指针并同时从链表的头节点出发，一个指针一次走一步，另一个指针一次走两步。如果链表中不包含环，走得快的指针直到抵达链表的尾节点都不会和走得慢的指针相遇。如果链表中包含环，走得快的指针在环里绕了一圈之后将会追上走得慢的指针。</p><p>如何找到环的入口节点，可以用两个指针来解决。先定义两个指针P1和P2，指向链表的头节点。如果链表中的环有n个节点，第1个指针P1先在链表中向前移动n步，然后两个指针以相同的速度向前移动。当第2个指针P2指向环的入口节点时，指针P1已经围绕环走了一圈又回到了入口节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 找到环中的结点，即快慢指针相遇时的结点</span><br>    <span class="hljs-function">ListNode *<span class="hljs-title">getInLoop</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>        <span class="hljs-comment">// 链表为空</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">//定义双指针</span><br>        ListNode *slow = head-&gt;next;<br>        ListNode *fast = slow-&gt;next;<br>        <span class="hljs-keyword">while</span>(slow != <span class="hljs-literal">NULL</span> &amp;&amp; fast != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(slow == fast)&#123;<br>                <span class="hljs-keyword">return</span> slow;<br>            &#125;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast)&#123;<br>                fast = fast-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-comment">// 先判断有没有环</span><br>        ListNode *inLoop = <span class="hljs-built_in">getInLoop</span>(head);<br>        <span class="hljs-keyword">if</span>(inLoop == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">// 再寻找相遇点</span><br>        <span class="hljs-comment">// 1. 计算环的长度n</span><br>        <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(ListNode *temp = inLoop-&gt;next;temp != inLoop;temp=temp-&gt;next)&#123;<br>            len++;<br>        &#125;<br>        <span class="hljs-comment">// 2. 快慢指针，找到倒数第m个</span><br>        ListNode *fast = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        ListNode *slow = head;<br>        <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>时间复杂度分析：</p><ul><li><p>getInLoop() 函数中，快慢指针法用于检测链表中是否存在环。时间复杂度为 O(n)，其中 n 是链表的长度，因为在最坏情况下，慢指针需要遍历整个链表一次才能确定是否有环。</p></li><li><p>detectCycle() 函数中，除了调用 getInLoop() 外，还有两个主要步骤：</p><ul><li>计算环的长度，需要遍历环一次，时间复杂度为 O(n)。</li><li>使用快慢指针找到环的起始节点，时间复杂度为 O(n)。因为在最坏情况下，快指针需要遍历环一次才能与慢指针相遇。</li></ul><p>因此，总的时间复杂度为 O(n)。</p></li></ul></li><li><p>空间复杂度分析：<br>算法中使用了常数个额外指针变量和常数个额外整型变量，所以空间复杂度为 O(1)。</p></li></ul><p><img src="/2024/04/15/posts/LCR021/image-1.png" alt="LCR022需要知道环长度的解法"></p><h3 id="不需要知道环中节点数目的解法"><a href="#不需要知道环中节点数目的解法" class="headerlink" title="不需要知道环中节点数目的解法"></a>不需要知道环中节点数目的解法</h3><p>如果链表中有环，快慢两个指针一定会在环中的某个节点相遇。慢的指针一次走一步，假设在相遇时慢的指针一共走了k步。由于快的指针一次走两步，因此在相遇时快的指针一共走了2k步。因此，到相遇时快的指针比慢的指针多走了k步。另外，两个指针相遇时快的指针比慢的指针在环中多转了若干圈。也就是说，两个指针相遇时快的指针多走的步数k一定是环中节点的数目的整数倍，此时慢的指针走过的步数k也是环中节点数的整数倍。</p><p>此时可以让一个指针指向相遇的节点，该指针的位置是之前慢的指针走了k步到达的位置。接着让另一个指针指向链表的头节点，然后两个指针以相同的速度一起朝着指向下一个节点的指针移动，当后面的指针到达环的入口节点时，前面的指针比它多走了k步，而k是环中节点的数目的整数倍，相当于前面的指针在环中转了k圈后也到达环的入口节点，两个指针正好相遇。也就是说，两个指针相遇的节点正好是环的入口节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 找到环中的结点，即快慢指针相遇时的结点</span><br>    <span class="hljs-function">ListNode *<span class="hljs-title">getInLoop</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>        <span class="hljs-comment">// 链表为空</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">//定义双指针</span><br>        ListNode *slow = head-&gt;next;<br>        ListNode *fast = slow-&gt;next;<br>        <span class="hljs-keyword">while</span>(slow != <span class="hljs-literal">NULL</span> &amp;&amp; fast != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(slow == fast)&#123;<br>                <span class="hljs-keyword">return</span> slow;<br>            &#125;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast)&#123;<br>                fast = fast-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-comment">// 先判断有没有环</span><br>        ListNode *inLoop = <span class="hljs-built_in">getInLoop</span>(head);<br>        <span class="hljs-keyword">if</span>(inLoop == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">// 再寻找相遇点</span><br>        <span class="hljs-comment">// 一个指针指向当前结点，另一个指向头，同时移动，直到相遇</span><br>        ListNode *fast = inLoop;<br>        ListNode *slow = head;<br>        <span class="hljs-keyword">while</span>(fast != slow)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>时间复杂度分析：</p><ul><li><p>getInLoop() 函数的时间复杂度与之前相同，为 O(n)，其中 n 是链表的长度，因为在最坏情况下，慢指针需要遍历整个链表一次才能确定是否有环。</p></li><li><p>detectCycle() 函数中，先调用 getInLoop() 函数，然后直接使用两个指针在链表中移动直到相遇。由于在 getInLoop() 中已经找到了环中的结点，所以这里不再需要计算环的长度，直接从相遇点开始移动一个指针，一个指针从头开始，它们相遇的点就是环的起始节点。</p></li><li><p>因为在最坏情况下，两个指针都需要遍历环一次才能相遇，所以时间复杂度为 O(n)。</p><p>因此，总的时间复杂度为 O(n)。</p></li></ul></li><li><p>空间复杂度分析：</p><ul><li>与之前相同，算法中使用了常数个额外指针变量和常数个额外整型变量，所以空间复杂度为 O(1)。</li></ul></li></ul><p><img src="/2024/04/15/posts/LCR021/image-2.png" alt="LCR022不需要知道环的长度的解法"></p><h2 id="LCR023-相交链表"><a href="#LCR023-相交链表" class="headerlink" title="LCR023.相交链表"></a><a href="https://leetcode.cn/problems/3u1WK4/description/">LCR023.相交链表</a></h2><h3 id="构造带环链表解法"><a href="#构造带环链表解法" class="headerlink" title="构造带环链表解法"></a>构造带环链表解法</h3><p>借鉴上一题的思路，把第二条链表的末尾连到头上，就形成了上一题中的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 找到相遇的环中结点</span><br>    <span class="hljs-function">ListNode *<span class="hljs-title">getInLoopNode</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        ListNode *slow = head-&gt;next;<br>        ListNode *fast = slow-&gt;next;<br>        <span class="hljs-keyword">while</span>(slow &amp;&amp; fast)&#123;<br>            <span class="hljs-keyword">if</span>(slow == fast)&#123;<br>                <span class="hljs-keyword">return</span> slow;<br>            &#125;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast)&#123;<br>                fast = fast-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-comment">// 边界判定</span><br>        <span class="hljs-keyword">if</span>(!headA || !headB)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">// 将B链接到A后面</span><br>        ListNode *node = headA;<br>        <span class="hljs-keyword">while</span>(node-&gt;next)&#123;<br>            node = node-&gt;next;<br>        &#125;<br>        node-&gt;next = headB;<br>        <span class="hljs-comment">// 判断有没有环</span><br>        <span class="hljs-comment">// 先找到相遇的地方</span><br>        ListNode *inLoop = <span class="hljs-built_in">getInLoopNode</span>(headA);<br>        <span class="hljs-keyword">if</span>(!inLoop)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">// 再继续绕环走</span><br>        ListNode *fast = inLoop;<br>        ListNode *slow = headA;<br>        <span class="hljs-keyword">while</span>(fast != slow)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但是这种方法无法通过测试，原因是改变了链表的结构。</p><p><img src="/2024/04/15/posts/LCR021/image-3.png" alt="LCR023构造带环链表方法结果"></p><h3 id="双指针方法"><a href="#双指针方法" class="headerlink" title="双指针方法"></a>双指针方法</h3><p>首先遍历两个链表得到它们的长度，这样就能知道哪个链表比较长，以及长的链表比短的链表多几个节点。在第2次遍历时，第1个指针P1在较长的链表中先移动若干步，再把第2个指针P2初始化到较短的链表的头节点，然后这两个指针按照相同的速度在链表中移动，直到它们相遇。两个指针相遇的节点就是两个链表的第1个公共节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getListLen</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            head = head-&gt;next;<br>            len++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-comment">// 两个链表的长度</span><br>        <span class="hljs-type">int</span> m = <span class="hljs-built_in">getListLen</span>(headA);<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">getListLen</span>(headB);<br>        <span class="hljs-type">int</span> delta = <span class="hljs-built_in">abs</span>(m-n);<br>        ListNode *longer = m &gt; n ? headA : headB;<br>        ListNode *shorter = m &gt; n ? headB : headA;<br>        <span class="hljs-comment">// 长的链表指针先走到和短的一样的位置</span><br>        ListNode *p1 = longer;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; delta; i++)&#123;<br>            p1 = p1-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 两个指针同时后移直到相等</span><br>        ListNode *p2 = shorter;<br>        <span class="hljs-keyword">while</span>(p1 != p2)&#123;<br>            p1 = p1-&gt;next;<br>            p2 = p2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：上述代码将两个链表分别遍历两次，第1次得到两个链表的节点数，第2次找到两个链表的第1个公共节点，这种方法的时间复杂度是O（m+n）</li><li>空间复杂度：由于不需要保存链表的节点，因此这种方法的空间复杂度是O（1）。</li></ul><p><img src="/2024/04/15/posts/LCR021/image-4.png" alt="LCR023双指针方法结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>双指针思路又可以根据两个指针不同的移动方式细分成两种不同的方法。第1种方法是前后双指针，即一个指针在链表中提前朝着指向下一个节点的指针移动若干步，然后移动第2个指针。前后双指针的经典应用是查找链表的倒数第k个节点。先让第1个指针从链表的头节点开始朝着指向下一个节点的指针先移动k-1步，然后让第2个指针指向链表的头节点，再让两个指针以相同的速度一起移动，当第1个指针到达链表的尾节点时第2个指针正好指向倒数第k个节点。</p><p>第2种方法是快慢双指针，即两个指针在链表中移动的速度不一样，通常是快的指针朝着指向下一个节点的指针一次移动两步，慢的指针一次只移动一步。采用这种方法，在一个没有环的链表中，当快的指针到达链表尾节点的时候慢的指针正好指向链表的中间节点。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR018-LCR020回文字符串</title>
    <link href="/2024/04/12/posts/LCR018/"/>
    <url>/2024/04/12/posts/LCR018/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）3-3-回文字符串"><a href="#剑指offer（专项突破版）3-3-回文字符串" class="headerlink" title="剑指offer（专项突破版）3.3 回文字符串"></a>剑指offer（专项突破版）3.3 回文字符串</h1><h2 id="LCR018-验证回文串"><a href="#LCR018-验证回文串" class="headerlink" title="LCR018.验证回文串"></a><a href="https://leetcode.cn/problems/XltzEq/">LCR018.验证回文串</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>使用双指针，起始时左指针指向开始，右指针指向最后一个字符，左指针不断后移，右指针不断前移。注意边界条件的判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 判断是否是字母或数字，数字返回1，大写字母返回2，小写字母返回3，其他返回0</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">checkChar</span><span class="hljs-params">(<span class="hljs-type">char</span> &amp;c)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-number">48</span>&amp;&amp;c&lt;=<span class="hljs-number">57</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-number">65</span>&amp;&amp;c&lt;=<span class="hljs-number">90</span>)&#123;<br>            c += <span class="hljs-number">32</span>;    <span class="hljs-comment">// 转换成小写字母</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-number">97</span>&amp;&amp;c&lt;=<span class="hljs-number">122</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// 双指针分别指向第一个和最后一个字符</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j)&#123;<br>            <span class="hljs-type">int</span> typeI = <span class="hljs-built_in">checkChar</span>(s[i]);<br>            <span class="hljs-type">int</span> typeJ = <span class="hljs-built_in">checkChar</span>(s[j]);<br>            <span class="hljs-keyword">while</span>(i &lt;= j &amp;&amp; typeI == <span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">// 不是数字或字母，跳过</span><br>                i++;<br>                typeI = <span class="hljs-built_in">checkChar</span>(s[i]);<br>            &#125;<br>            <span class="hljs-keyword">while</span>(i &lt;= j &amp;&amp; typeJ == <span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">// 不是数字或字母，跳过</span><br>                j--;<br>                typeJ = <span class="hljs-built_in">checkChar</span>(s[j]);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i&lt;=j &amp;&amp; s[i]==s[j])&#123;         <span class="hljs-comment">// i、j所指字符相等，继续移动指针</span><br>                i++;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&gt;j)&#123;                   <span class="hljs-comment">// i已经移动到j的右边，则要么是跳过了，要么是都相等</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>                            <span class="hljs-comment">// i&lt;=j且所指字符不相等，直接返回false</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>主要的时间消耗在于 while 循环中的字符比较和移动指针操作。假设字符串的长度为 n，则最坏情况下，每个字符都要被比较一次，而且指针移动的次数也是线性的。因此，while 循环的时间复杂度是 O(n)。<br>整体上，算法的时间复杂度为 O(n)。</p><p><img src="/2024/04/12/posts/LCR018/image.png" alt="LCR018结果"></p><h2 id="LCR019-验证回文串II"><a href="#LCR019-验证回文串II" class="headerlink" title="LCR019.验证回文串II"></a><a href="https://leetcode.cn/problems/RQku0D/">LCR019.验证回文串II</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>其实跟第一道题有点像，这道题虽然说可以最多去掉一个字符，但是这道题的字符串只由小写字母组成，可以把不匹配的第一个字符当作上一题中的特殊字符跳过，并且这道题只能跳过一次。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>一种错误的解法：去掉s[i]还是s[j]，是不知道的，不能按照如下代码的方式判断。</p><p><img src="/2024/04/12/posts/LCR018/image-1.png" alt="错误示例"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// 双指针解法</span><br>        <span class="hljs-comment">// i指向第一个字符，j指向最后一个字符</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 没有去掉过字符</span><br>        <span class="hljs-keyword">while</span>(i &lt;= j)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] == s[j])&#123;<br>                i++;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!flag &amp;&amp; i+<span class="hljs-number">1</span> &lt;= j &amp;&amp; s[i+<span class="hljs-number">1</span>] == s[j])&#123;<br>                i += <span class="hljs-number">2</span>;<br>                j--;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!flag &amp;&amp; i &lt;= j<span class="hljs-number">-1</span> &amp;&amp; s[i] == s[j<span class="hljs-number">-1</span>])&#123;<br>                i++;<br>                j -= <span class="hljs-number">2</span>;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>更正代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkPalindrome</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = low,j = high;i &lt; j; i++, j--)&#123;<br>        <span class="hljs-keyword">if</span>(s[i] != s[j])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// 双指针解法</span><br>        <span class="hljs-comment">// low指向第一个字符，high指向最后一个字符</span><br>        <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> high = s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 没有去掉过字符</span><br>        <span class="hljs-keyword">while</span>(low &lt; high)&#123;<br>            <span class="hljs-keyword">if</span>(s[low] == s[high])&#123;<br>                low++;<br>                high--;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">checkPalindrome</span>(s, low, high<span class="hljs-number">-1</span>) || <span class="hljs-built_in">checkPalindrome</span>(s, low+<span class="hljs-number">1</span>,high);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(n)，其中n是字符串的长度。判断整个字符串是否是回文字符串的时间复杂度是O(n)，遇到不同字符时，判断两个子串是否是回文字符串的时间复杂度也都是O(n)。</p><p>空间复杂度：O(1)。只需要维护有限的常量空间。</p><p><img src="/2024/04/12/posts/LCR018/image-2.png" alt="LCR019结果"></p><h2 id="LCR020-回文子串"><a href="#LCR020-回文子串" class="headerlink" title="LCR020.回文子串"></a><a href="https://leetcode.cn/problems/a7VOhD/description/">LCR020.回文子串</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>对每个字符串的每个字符，都作为回文串中心向两侧扩展，回文串长度若为奇数，则只有一个中心；若为偶数，则有两个中心。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 比较是否是回文串并计数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPalindrome</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(start &gt;= <span class="hljs-number">0</span> &amp;&amp; end &lt; s.<span class="hljs-built_in">length</span>() &amp;&amp; s[start] == s[end])&#123;<br>            count++;<br>            start--;<br>            end++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 每个字符都作为回文串中心</span><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            count += <span class="hljs-built_in">countPalindrome</span>(s, i, i);<br>            count += <span class="hljs-built_in">countPalindrome</span>(s, i, i+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度是$O（n^2）$，空间复杂度是$O（1）$。</p><p><img src="/2024/04/12/posts/LCR018/image-3.png" alt="LCR020结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>变位词和回文是很有意思的文字游戏，在与字符串相关的算法面试题中，它们出现的频率很高。如果两个字符串包含的字符及每个字符出现的次数都相同，只是字符出现的顺序不同，那么它们就是一组变位词。通常可以用一个哈希表来统计每个字符出现的次数，有了哈希表就很容易判断两个字符串是不是一组变位词。</p><p>回文是一类特殊的字符串。不管是从前往后还是从后往前读取其每一个字符，得到的内容都是一样的。通常可以用两个指针来判断一个字符串是不是回文，要么两个指针从字符串的两端开始向中间移动，要么两个指针从中间开始向两端移动。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR014-LCR017双指针</title>
    <link href="/2024/04/08/posts/LCR014/"/>
    <url>/2024/04/08/posts/LCR014/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="剑指offer（专项突破版）3-2-双指针"><a href="#剑指offer（专项突破版）3-2-双指针" class="headerlink" title="剑指offer（专项突破版）3.2 双指针"></a>剑指offer（专项突破版）3.2 双指针</h1><h2 id="LCR014-字符串的排列"><a href="#LCR014-字符串的排列" class="headerlink" title="LCR014.字符串的排列"></a><a href="https://leetcode.cn/problems/MPnaiL/description/">LCR014.字符串的排列</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>变位词：组成各个单词的字母及每个字母出现的次数完全相同，只是字母排列的顺序不同。例如，”pots”、”stop”和”tops”就是一组变位词。</li><li>蛮力法：把字符串s1的字母所有排列组合找到，然后看s2中有没有这些子串。所有排列组合是n!，时间复杂度为O(n!)。</li><li>双指针法：用哈希表存储s1字符串字母的次数。然后用双指针，左指针i初始化指向s2开始，右指针j指向n-i+1，即字符串s1的长度。然后不断向右移动左指针和右指针，出现的字母要在哈希表中-1。</li></ul><h3 id="双指针解法代码"><a href="#双指针解法代码" class="headerlink" title="双指针解法代码"></a>双指针解法代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// 判断alphabet是否全0</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkAllZero</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; alphabet)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">26</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(alphabet[i] != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-comment">// 边界检查</span><br>        <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">length</span>() &gt; s2.<span class="hljs-built_in">length</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 哈希表存储26个字母</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">alphabet</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">// 对于s1中存在的字母，哈希表中的值+1</span><br>        <span class="hljs-type">int</span> n = s1.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            alphabet[s1[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-comment">// 对于s2中的子字符串，使用双指针</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i;k &lt;= j;k++)&#123;<br>            alphabet[s2[k]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br><br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">checkAllZero</span>(alphabet))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        j++;<br>        <span class="hljs-comment">// 左右指针不断移动</span><br>        <span class="hljs-keyword">for</span>(;j &lt; s2.<span class="hljs-built_in">length</span>();j++)&#123;<br>            alphabet[s2[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            alphabet[s2[j]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">checkAllZero</span>(alphabet))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>基于双指针和哈希表的算法需要扫描字符串s1和s2各一次。如果它们的长度分别是m和n，那么该算法的时间复杂度是O（m+n）。这种解法用到了一个数组。数组的长度是英文小写字母的个数（即26），是一个常数，也就是说，数组的大小不会随着输入字符串长度的变化而变化，因此空间复杂度是O（1）。</p><p><img src="/2024/04/08/posts/LCR014/image.png" alt="LCR014结果"></p><h1 id="剑指offer（专项突破版）3-2-双指针-1"><a href="#剑指offer（专项突破版）3-2-双指针-1" class="headerlink" title="剑指offer（专项突破版）3.2 双指针"></a>剑指offer（专项突破版）3.2 双指针</h1><h2 id="LCR015-找到字符串中所有字母异位词"><a href="#LCR015-找到字符串中所有字母异位词" class="headerlink" title="LCR015.找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/VabMRr/description/">LCR015.找到字符串中所有字母异位词</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>LCR013题目的变形，一种直接的想法是在上一题的基础上，每次判断alphabet是否全0后不返回<code>true</code> or <code>false</code>，而是记录此时的下标i。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 检查数组是否全0</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkAllZero</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; alphabet)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">26</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(alphabet[i] != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-comment">// 结果vector</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-comment">// 处理边界条件</span><br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> n = p.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span>(m &lt; n)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-comment">// 定义哈希表</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">alphabet</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">// 记录p字符串的情况并更新s字符串的情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            alphabet[p[j]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            alphabet[s[j]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">checkAllZero</span>(alphabet))&#123;<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">// 双指针遍历字符串s</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n; j &lt; m; i++, j++)&#123;<br>            alphabet[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            alphabet[s[j]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">checkAllZero</span>(alphabet))&#123;<br>                res.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>同样，这种解法的时间复杂度也是O（n），空间复杂度是O（1）。</p><p><img src="/2024/04/08/posts/LCR014/image-1.png" alt="LCR015双指针结果"></p><h2 id="LCR016-无重复字符的最长子串"><a href="#LCR016-无重复字符的最长子串" class="headerlink" title="LCR016.无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/wtcaE1/description/">LCR016.无重复字符的最长子串</a></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>直接的想法是：左指针指向开始，右指针不断向后移动，如果右指针此时指向的字符没有出现过。则将它记录在哈希表里，并更新最长子串长度。如果右指针此时指向的字符出现过，就需要将左指针移动，移动到什么位置，移动到和右指针所指字符相同的字符的后面一个位置，这个位置也需要记录。同时将这个字符的下标修改为当前右指针所指位置。使用<code>unordered_map&lt;char,int&gt;</code>来记录某个字符曾经出现的位置，如果没有出现过，即<code> if(dict.count(&#39;某个字符&#39;)==0)</code>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-comment">// 处理边界条件</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 存储字符-下标的哈希表</span><br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-comment">// 最大长度</span><br>        <span class="hljs-type">int</span> maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 双指针解法</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>; j &lt; n;j++)&#123;<br>            <span class="hljs-comment">// j所指字符没有在之前出现过</span><br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">count</span>(s[j]) == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">// 更新哈希表</span><br>                hash[s[j]] = j;<br>                <span class="hljs-comment">// 更新最大子串长度</span><br>                <span class="hljs-type">int</span> curLen = j - i + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(curLen &gt; maxLen)&#123;<br>                    maxLen = curLen;<br>                &#125;<br>                <span class="hljs-comment">// 然后j继续向右移动即可</span><br>            &#125;<br>            <span class="hljs-comment">// j所指字符之前出现过</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 更新i指针位置为先前出现的位置+1</span><br>                <span class="hljs-comment">// i = hash[s[j]] + 1;</span><br>                <span class="hljs-comment">// 上一行更新i的代码有逻辑错误，假如s=&quot;tmmzuxt&quot;，</span><br>                <span class="hljs-comment">// 此时i=2指向第二个m,j=6指向t，虽然t出现过,</span><br>                <span class="hljs-comment">// 但i在第一个t后面的位置，所以不需要更新i,</span><br>                <span class="hljs-comment">// 但是这里还要更新最大长度</span><br>                i = i &gt; hash[s[j]] ? i : hash[s[j]]+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> curLen = j - i + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(curLen &gt; maxLen)&#123;<br>                    maxLen = curLen;<br>                &#125;<br>                <span class="hljs-comment">// 更新哈希表</span><br>                hash[s[j]] = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>使用了双指针来遍历整个字符串，其中一个指针 i 指向当前子串的起始位置，另一个指针 j 则用来遍历字符串，整个遍历过程的时间复杂度为 O(n)，其中 n 是输入字符串的长度。unordered_map 的count 方法时间复杂度为O(1)。整个算法的时间复杂度为 O(n)，其中 n 是输入字符串的长度。哈希表的空间复杂度是 O(n)。</p><p><img src="/2024/04/08/posts/LCR014/image-2.png" alt="LCR016结果"></p><h2 id="LCR017-最小覆盖子串"><a href="#LCR017-最小覆盖子串" class="headerlink" title="LCR017.最小覆盖子串"></a><a href="https://leetcode.cn/problems/M1oyTv/description/">LCR017.最小覆盖子串</a></h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkNum</span><span class="hljs-params">(unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; hash)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt;::iterator iter=hash.<span class="hljs-built_in">begin</span>();iter != hash.<span class="hljs-built_in">end</span>();iter++)&#123;<br>            <span class="hljs-keyword">if</span>(iter-&gt;second &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>     <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-comment">// 哈希表存储字符-出现次数</span><br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-comment">// 结果字符串</span><br>        <span class="hljs-type">int</span> minLen = INT_MAX;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-comment">// 记录字符串t的情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; t.<span class="hljs-built_in">length</span>();i++)&#123;<br>            hash[t[i]]++;<br>        &#125;<br>        <span class="hljs-comment">// 双指针遍历字符串s</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> tLen = t.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">while</span> (right &lt; s.<span class="hljs-built_in">length</span>()) &#123;<br>            <span class="hljs-comment">// 右指针向右移动，更新 hash 表</span><br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">find</span>(s[right]) != hash.<span class="hljs-built_in">end</span>()) &#123;<br>                hash[s[right]]--;<br>            &#125;<br>            right++;<br><br>            <span class="hljs-comment">// 当满足条件时，移动左指针</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">checkNum</span>(hash) &amp;&amp; left &lt; right) &#123;<br>                <span class="hljs-keyword">if</span> (right - left &lt; minLen) &#123;<br>                    minLen = right - left;<br>                    res = s.<span class="hljs-built_in">substr</span>(left, minLen);<br>                &#125;<br>                <span class="hljs-comment">// 移动左指针，并更新 hash 表</span><br>                <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">find</span>(s[left]) != hash.<span class="hljs-built_in">end</span>()) &#123;<br>                    hash[s[left]]++;<br>                &#125;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>同样使用双指针，如果没有完全包含字符串t，就向右移动右指针；如果已经包含，就向右移动左指针。如何判断是否包含，使用哈希表存储字母出现的次数，对于t中存在的字符，需要-1，不存在的字符可以忽略不计。</p><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>这个算法的时间复杂度主要取决于双指针的遍历过程。假设字符串 s 的长度为 n，字符串 t 的长度为 m。</p><p>初始化哈希表的时间复杂度为 O(m)，因为需要遍历字符串 t 并统计每个字符的出现次数。<br>双指针遍历字符串 s 的时间复杂度为 O(n)。在最坏情况下，右指针会移动 n 次，而左指针也会移动 n 次。<br>在双指针的遍历过程中，对哈希表的更新操作是常数时间的，因此不影响总体时间复杂度。</p><p>综上所述，该算法的时间复杂度为 O(n + m)。</p><p><img src="/2024/04/08/posts/LCR014/image-3.png" alt="LCR017结果"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>双指针初始化： 在处理字符串的问题中，通常需要使用两个指针来构建一个窗口或者子串，其中一个指针用于标识子串的起始位置，另一个指针用于标识子串的结束位置。这两个指针的初始化通常在字符串的开头位置。</p><p>哈希表的应用： 为了有效地处理字符出现的次数或者其他相关信息，我们通常会利用哈希表来存储字符及其出现的次数。这样可以在 O(1) 的时间复杂度内快速查询、更新字符出现的次数。</p><p>滑动窗口的移动： 在双指针的框架下，窗口通常会向右滑动。右指针会向右移动，扩大窗口的大小，而左指针则会根据题目要求选择是否移动，以保持窗口的特性。</p><p>条件判断： 在窗口滑动的过程中，需要根据题目的要求不断进行条件判断。这些条件判断通常涉及到对哈希表的查询和更新，以及子串的特性判断等。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR010-LCR013累加数组数字求子数组之和</title>
    <link href="/2024/04/01/posts/LCR010/"/>
    <url>/2024/04/01/posts/LCR010/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="剑指offer（专项突破版）2-3-累加数组数字求子数组之和"><a href="#剑指offer（专项突破版）2-3-累加数组数字求子数组之和" class="headerlink" title="剑指offer（专项突破版）2.3 累加数组数字求子数组之和"></a>剑指offer（专项突破版）2.3 累加数组数字求子数组之和</h2><h3 id="题目链接：LCR010-和为K的子数组"><a href="#题目链接：LCR010-和为K的子数组" class="headerlink" title="题目链接：LCR010-和为K的子数组"></a>题目链接：<a href="https://leetcode.cn/problems/QTMn0o/">LCR010-和为K的子数组</a></h3><p><strong>蛮力法</strong>：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> subarraySum(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> cnt = <span class="hljs-number">0</span>;<br>        for(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> = nums[i];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> == k)<br>                cnt++;<br>            for(<span class="hljs-built_in">int</span> j = i+<span class="hljs-number">1</span>;j &lt; nums.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-built_in">sum</span> += nums[j];<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> == k)&#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong> $O(n^2)$</p><p><strong>结果：</strong></p><p><img src="/2024/04/01/posts/LCR010/image.png" alt="LCR010蛮力法结果"></p><p><strong>前缀和+哈希表：</strong> 在从头到尾逐个扫描数组中的数字时求出前i个数字之和，并且将和保存下来。数组的前i个数字之和记为x。如果存在一个j（j＜i），数组的前j个数字之和为x-k，那么数组中从第i+1个数字开始到第j个数字结束的子数组之和为k。这个题目需要计算和为k的子数组的个数。当扫描到数组的第i个数字并求得前i个数字之和是x时，需要知道在i之前存在多少个j并且前j个数字之和等于x-k。所以，对每个i，不但要保存前i个数字之和，还要保存每个和出现的次数。分析到这里就会知道我们需要一个哈希表，哈希表的键是前i个数字之和，值为每个和出现的次数。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> subarraySum(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 记录和</span><br>        <span class="hljs-built_in">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 记录结果</span><br>        unordered_map&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt; sumCnt;  <span class="hljs-comment">// 记录某个和出现的次数</span><br>        sumCnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.size();i++)&#123;<br>            <span class="hljs-keyword">sum</span> += nums[i];<br>            cnt += sumCnt[<span class="hljs-keyword">sum</span>-k];<br>            sumCnt[<span class="hljs-keyword">sum</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>易错点：</strong></p><ol><li>遗漏<code>sumCnt[0] = 1</code>：当k就等于当前计算的sum时，如果没有初始化<code>sumCnt[0] = 1</code>，则当前子数组不会被计数上，因为<code>sumCnt[0] = 0</code>。</li><li><code>cnt += sumCnt[sum-k];</code>与<code>sumCnt[sum]++;</code>代码顺序颠倒：如果先进行<code>sumCnt[sum]++;</code>当$k&#x3D;0$时，计数会出现错误。</li></ol><p><strong>时间复杂度分析：</strong> O(n)</p><p><strong>结果：</strong></p><p><img src="/2024/04/01/posts/LCR010/image-1.png" alt="LCR010前缀和方法结果"></p><h3 id="题目链接：LCR011-连续数组"><a href="#题目链接：LCR011-连续数组" class="headerlink" title="题目链接：LCR011-连续数组"></a>题目链接：<a href="https://leetcode.cn/problems/A1NYOS/description/">LCR011-连续数组</a></h3><p><strong>蛮力法：</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> findMaxLength(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">// 根据题意，找到子数组和为数组长度/2的子数组</span><br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 蛮力法</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.size();i++)&#123;<br>            <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = nums[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = i+<span class="hljs-number">1</span>;j &lt; nums.size();j++)&#123;<br>                <span class="hljs-keyword">sum</span> += nums[j];<br>                <span class="hljs-keyword">if</span>(((j-i) % <span class="hljs-number">2</span>) &amp;&amp; (<span class="hljs-keyword">sum</span> == (j-i+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>) &amp;&amp; (j-i+<span class="hljs-number">1</span>) &gt; res)&#123;  <span class="hljs-comment">//只有子数组长度为偶数时，0和1的个数才可能相等</span><br>                    res = j - i + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong> $O(n^2)$</p><p><strong>结果：</strong></p><p>执行超时</p><p><img src="/2024/04/01/posts/LCR010/image-2.png" alt="LCR011蛮力法超时"></p><p><strong>前缀和+哈希表：</strong></p><p>把数组当中的0变成-1，当扫描到下标为j的数字时，和为m,假设前i个数字的和也是m，则从i+1到j的子数组和为0。用一个哈希表存储前i个数字的和及其下标。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> findMaxLength(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">// 前缀和+哈希表</span><br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        unordered_map &lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt; hash;   <span class="hljs-comment">// 键为前i个数字和，值为i</span><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;    <span class="hljs-comment">//记录前缀和</span><br>        hash[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.size();i++)&#123;<br>            <span class="hljs-keyword">sum</span> += nums[i] == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 如果存在这样的下标</span><br>            <span class="hljs-keyword">if</span>(hash.find(<span class="hljs-keyword">sum</span>) != hash.end())&#123;<br>                <span class="hljs-built_in">int</span> len = i-hash[<span class="hljs-keyword">sum</span>];       <br>                <span class="hljs-keyword">if</span>(len &gt; res)<br>                    res = len;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                hash[<span class="hljs-keyword">sum</span>] = i;<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong> O(n)</p><p><strong>结果：</strong></p><p><img src="/2024/04/01/posts/LCR010/image-3.png" alt="LCR011前缀和结果"></p><h3 id="题目链接：LCR012-寻找数组的中心下标"><a href="#题目链接：LCR012-寻找数组的中心下标" class="headerlink" title="题目链接：LCR012-寻找数组的中心下标"></a>题目链接：<a href="https://leetcode.cn/problems/tvdfij/description/">LCR012-寻找数组的中心下标</a></h3><p><strong>分析：</strong> 假设i为要寻找的下标，则前i-1个数字的和就等于所有数字的和-前i个数字的和。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> pivotIndex(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">// 两个循环</span><br>        <span class="hljs-comment">// 求出所有数字的和</span><br>        <span class="hljs-built_in">int</span> total = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.size();i++)&#123;<br>            total += nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 寻找中间下标</span><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.size();i++)&#123;<br>            <span class="hljs-keyword">sum</span> += nums[i];<br>            <span class="hljs-keyword">if</span>((<span class="hljs-keyword">sum</span>-nums[i]) == (total-<span class="hljs-keyword">sum</span>))&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong> 上述代码有两个时间复杂度为O（n）的循环，因此总的时间复杂度为O（n）。函数pivotIndex中只用到了若干临时变量，并没有使用数组、哈希表之类的辅助数据容器，因此空间复杂度是O（1）。</p><p><strong>结果：</strong></p><p><img src="/2024/04/01/posts/LCR010/image-4.png" alt="LCR012结果"></p><h3 id="题目链接：LCR013-二维区域和检索-矩阵不可变"><a href="#题目链接：LCR013-二维区域和检索-矩阵不可变" class="headerlink" title="题目链接：LCR013-二维区域和检索 - 矩阵不可变"></a>题目链接：<a href="https://leetcode.cn/problems/O4NDxx/">LCR013-二维区域和检索 - 矩阵不可变</a></h3><p><strong>分析：</strong> </p><ul><li>假设sums[i][j]表示左上角为（0,0）到右下角（i,j）的子矩阵和，那么从左上角（row1,col1）到右下角（row2,col2）的和为：<code>res = sums[rol2][col2] - sums[row1-1][col2] - sums[rol2][col1-1] + sums[row1-1][col1-1]</code>。</li><li>如何求sums[i][j]？可以拆分成两部分，即matrix[i][j]上面的元素<code>sums[i-1][j]</code>以及左边的元素+它本身（每一行按列求和即可）<code>rowSum = matrix[i][0] + ... + matrix[i][j]</code>。</li><li>如果输入矩阵的行数和列数分别是m和n，那么辅助数组sums的行数和列数分别为m+1和n+1，这样只是为了简化代码逻辑。如果用公式sums[r2][c2]+sums[r1-1][c2]-sums[r2][c1-1]+sums[r1-1][c1-1]求解左上角坐标为（r1，c1）、右下角坐标为（r2，c2）的子矩阵的数字之和，由于坐标值r1或c1有可能等于0，因此r1-1或c1-1可能是负数，不再是有效的数组下标。如果在矩阵的最上面增加一行，最左面增加一列，这样就不必担心出现数组下标为-1的情形。</li></ul><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mel">class NumMatrix &#123;<br>public:<br>    <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; sums;   <span class="hljs-comment">// 记录前缀和的数组</span><br><br>    NumMatrix(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; <span class="hljs-keyword">matrix</span>) &#123;<br>        <span class="hljs-keyword">int</span> m = <span class="hljs-keyword">matrix</span>.<span class="hljs-keyword">size</span>();  <span class="hljs-comment">// m为矩阵行数</span><br>        <span class="hljs-keyword">if</span>(m &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">int</span> n = <span class="hljs-keyword">matrix</span>[<span class="hljs-number">0</span>].<span class="hljs-keyword">size</span>();   <span class="hljs-comment">// n为矩阵列数</span><br>            sums.resize(m+<span class="hljs-number">1</span>,<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>                <span class="hljs-keyword">int</span> rowSum = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)&#123;<br>                    rowSum += <span class="hljs-keyword">matrix</span>[i][j];<br>                    sums[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = sums[i][j+<span class="hljs-number">1</span>] + rowSum;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> sumRegion(<span class="hljs-keyword">int</span> row1, <span class="hljs-keyword">int</span> col1, <span class="hljs-keyword">int</span> row2, <span class="hljs-keyword">int</span> col2) &#123;<br>        <span class="hljs-keyword">return</span> sums[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>] - sums[row1][col2+<span class="hljs-number">1</span>] - sums[row2+<span class="hljs-number">1</span>][col1] + sums[row1][col1];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix* obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong> 函数sumRegion用来求子矩阵的数字之和，该函数只是从数组sums中读取几个数字做加法和减法，因此每次调用的时间复杂度都是O（1）。类型NumMatrix的构造函数用来做预处理，根据输入矩阵生成辅助矩阵sums。该构造函数使用两个嵌套的循环计算辅助函数sums中的每个数字，因此时间复杂度是O（mn）。同时，数组sums需要的辅助空间为O（mn）。</p><p><strong>结果：</strong></p><p><img src="/2024/04/01/posts/LCR010/image-5.png" alt="LCR013结果"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>计算前缀和：首先，需要计算数组中每个位置的前缀和，即从数组开头到当前位置的累加和。这可以通过一个循环来完成，将当前位置的值加上前一个位置的前缀和即可得到当前位置的前缀和。</li><li>利用前缀和求解子数组之和：在需要求解子数组之和的问题中，利用前缀和可以在常数时间内求得任意子数组的和。通过记录每个前缀和出现的次数，可以在O(1)的时间复杂度内得到某个子数组的和，从而解决了以往使用蛮力法会导致高时间复杂度的问题。</li><li>利用哈希表存储前缀和出现的次数：在求解子数组之和的问题中，为了方便查找某个前缀和出现的次数，可以使用哈希表来存储前缀和及其出现的次数。这样，在遍历数组的过程中，可以实时更新哈希表，以便在O(1)时间内获取所需的前缀和信息。</li><li>注意边界条件和特殊情况：在使用前缀和方法解题时，需要注意处理边界条件和特殊情况，例如数组为空、特定值等情况，以避免出现错误的结果。</li><li>时间复杂度分析：使用前缀和方法解题通常能够将时间复杂度降低至O(n)级别，相比蛮力法的O(n^2)更高效。因此，在面对求解子数组之和、子矩阵之和等问题时，前缀和方法是一种常用且高效的解决方案。</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR006-LCR009双指针问题</title>
    <link href="/2024/03/09/posts/LCR006/"/>
    <url>/2024/03/09/posts/LCR006/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="剑指offer（专项突破版）2-2-双指针"><a href="#剑指offer（专项突破版）2-2-双指针" class="headerlink" title="剑指offer（专项突破版）2.2 双指针"></a>剑指offer（专项突破版）2.2 双指针</h2><h3 id="题目链接：LCR006-排序数组中的两个数字之和"><a href="#题目链接：LCR006-排序数组中的两个数字之和" class="headerlink" title="题目链接：LCR006-排序数组中的两个数字之和"></a>题目链接：<a href="https://leetcode.cn/problems/kLl5u1/description/">LCR006-排序数组中的两个数字之和</a></h3><blockquote><p>分析：用两个指针P1和P2分别指向数组中的两个数字。指针P1初始化指向数组的第1个（下标为0）数字，指针P2初始化指向数组的最后一个数字。如果指针P1和P2指向的两个数字之和等于输入的k，那么就找到了符合条件的两个数字。如果指针P1和P2指向的两个数字之和小于k，那么我们希望两个数字的和再大一点。由于数组已经排好序，因此可以考虑把指针P1向右移动。因为在排序数组中右边的数字要大一些，所以两个数字的和也要大一些，这样就有可能等于输入的数字k。同样，当两个数字的和大于输入的数字k时，可以把指针P2向左移动，因为在排序数组中左边的数字要小一些。</p></blockquote><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; twoSum(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> <span class="hljs-built_in">target</span>) &#123;<br>        <span class="hljs-comment">// 定义两个指针，一个从前往后开始扫描，一个从后往前开始扫描</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = numbers[i] + numbers[j];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> == <span class="hljs-built_in">target</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span> &lt; <span class="hljs-built_in">target</span>)&#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; res;<br>        res.push_back(i);<br>        res.push_back(j);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong> 时间复杂度是O（n）、空间复杂度是O（1）。</p><p><strong>结果：</strong></p><p><img src="/2024/03/09/posts/LCR006/image.png" alt="两数之和结果"></p><h3 id="题目链接：LCR007-三数之和"><a href="#题目链接：LCR007-三数之和" class="headerlink" title="题目链接：LCR007-三数之和"></a>题目链接：<a href="https://leetcode.cn/problems/1fGaJU/description/">LCR007-三数之和</a></h3><p>分析：先对数组进行排序。在固定用变量i指向的数字之后，找出所有下标大于i并且和为-nums[i]的两个数字（下标分别为j和k）。如果nums[i]、nums[j]、nums[k]的和大于0，那么下标k向左移动；如果nums[i]、nums[j]、nums[k]的和小于0，那么下标j向右移动。如果3个数字之和正好等于0，那么向右移动下标j，以便找到其他和为-nums[i]的两个数字。由于要避免重复的三元组，因此使用while循环让下标i、j、k跳过重复的数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 结果</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-comment">//固定一个元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n<span class="hljs-number">-2</span>;i++)&#123;<br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> k = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(j &lt; k)&#123;<br>                <span class="hljs-type">int</span> sum = nums[i] + nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span>(sum == <span class="hljs-number">0</span>)&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(&#123;nums[i],nums[j],nums[k]&#125;);<br>                    <span class="hljs-comment">//去掉重复元素</span><br>                    <span class="hljs-keyword">while</span>(j&lt;k &amp;&amp; nums[j]==nums[j+<span class="hljs-number">1</span>]) j++;<br>                    <span class="hljs-keyword">while</span>(j&lt;k &amp;&amp; nums[k]==nums[k<span class="hljs-number">-1</span>]) k--;<br>                    j++;<br>                    k--;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>)&#123;<br>                    j++;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    k--;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//跳过重复元素</span><br>            <span class="hljs-keyword">while</span>(i&lt;n<span class="hljs-number">-2</span> &amp;&amp; nums[i]==nums[i+<span class="hljs-number">1</span>]) i++;         <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong> 用O（n）时间在排序数组中找出和为给定值的两个数字的方法，由于需要固定数组中的每个数字，因此查找三元组的时间复杂度是O（n2）。排序算法的时间复杂度通常是O（nlogn），因此这种解法的总的时间复杂度是O（nlogn）+O（n2），仍然是O（n2）。</p><p><strong>结果：</strong></p><p><img src="/2024/03/09/posts/LCR006/image-1.png" alt="三数之和结果"></p><h3 id="题目链接：LCR008-长度最小的子数组"><a href="#题目链接：LCR008-长度最小的子数组" class="headerlink" title="题目链接：LCR008-长度最小的子数组"></a>题目链接：<a href="https://leetcode.cn/problems/2VG8Kg/">LCR008-长度最小的子数组</a></h3><p>分析：初始时两个指针p1、p2同时指向首个元素，两个指针之间的元素和小于target，p2向右移动一位；和大于等于target，p1向右移动一位，同时更新最短数组长度。</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">int</span> minSubArrayLen(<span class="hljs-type">int</span> <span class="hljs-built_in">target</span>, <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> res = INT_MAX;<br>        <span class="hljs-comment">// 定义双指针</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历</span><br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(; j &lt; nums.<span class="hljs-built_in">size</span>();j++)&#123;<br>            <span class="hljs-built_in">sum</span> += nums[j];<br>            <span class="hljs-keyword">while</span>(i &lt;= j &amp;&amp; <span class="hljs-built_in">sum</span> &gt;= <span class="hljs-built_in">target</span>)&#123;<br>                res = <span class="hljs-built_in">min</span>(res,j-i+<span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">sum</span> -= nums[i];<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(res == INT_MAX)&#123;<br>            res = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong> 假设数组的长度为n，尽管上述代码中有两个嵌套的循环，该解法的时间复杂度仍然是O（n）。这是因为在这两个循环中，变量left和right都是只增加不减少，变量right从0增加到n-1，变量left从0最多增加到n-1，因此总的执行次数是O（n）。</p><p><strong>结果：</strong></p><p><img src="/2024/03/09/posts/LCR006/image-2.png" alt="长度最小的子数组"></p><h3 id="题目链接：LCR00-乘积小于k的子数组"><a href="#题目链接：LCR00-乘积小于k的子数组" class="headerlink" title="题目链接：LCR00-乘积小于k的子数组"></a>题目链接：<a href="https://leetcode.cn/problems/ZVAVXX/description/">LCR00-乘积小于k的子数组</a></h3><p>分析：<br>用指针P1和P2指向数组中的两个数字，两个指针之间的数字组成一个子数组。指针P1永远不会走到指针P2的右边。两个指针初始化都指向数组的第1个数字（下标为0的数字）。</p><p>如果两个指针之间的子数组中数字的乘积小于k，则向右移动指针P2。向右移动指针P2相当于在子数组中添加一个新的数字，由于数组中的数字都是正整数，因此子数组中数字的乘积就会变大。</p><p>如果两个指针之间的子数组中数字的乘积大于或等于k，则向右移动指针P1。向右移动指针P1相当于从子数组中删除最左边的数字，由于数组中的数字都是正整数，因此子数组中数字的乘积就会变小。</p><p>由于我们的目标是求出所有数字乘积小于k的子数组的个数，一旦向右移动指针P1到某个位置时子数组的乘积小于k，就不需要再向右移动指针P1。这是因为只要保持指针P2不动，向右移动指针P1形成的所有子数组的数字乘积就一定小于k。此时两个指针之间有多少个数字，就找到了多少个数字乘积小于k的子数组。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> numSubarrayProductLessThanK(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">product</span> = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;<br>        // 双指针<br>        <span class="hljs-built_in">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        for(;j &lt; len;j++)&#123;<br>            <span class="hljs-built_in">product</span> *= nums[j];<br>            <span class="hljs-keyword">while</span>(i &lt;= j &amp;&amp; <span class="hljs-built_in">product</span> &gt;= k)&#123;<br>                <span class="hljs-built_in">product</span> /= nums[i++];<br>            &#125;<br>            res += j&gt;=i ? j-i+<span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong> 和第八题一样，假设数组的长度为n，尽管上述代码中有两个嵌套的循环，该解法的时间复杂度仍然是O（n）。这是因为在这两个循环中，变量i和j都是只增加不减少，变量j从0增加到n-1，变量i从0最多增加到n-1，因此总的执行次数是O（n）。</p><p><strong>结果：</strong></p><p><img src="/2024/03/09/posts/LCR006/image-3.png" alt="乘积小于k的子数组"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>全局遍历： 当需要对整个数组进行遍历操作时，例如计算数组中元素的总和、查找特定元素等，可以将两个指针同时指向数组起始位置，并依次向后移动，直到遍历完整个数组。</p><p>寻找目标： 在一些需要从头开始寻找某个目标的情况下，可以将一个指针指向数组的起始位置，另一个指针指向数组的末尾位置，然后根据目标的条件逐步缩小指针所代表的区间，最终找到目标或者达到特定的结束条件。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR005.最大单词长度乘积</title>
    <link href="/2024/03/07/posts/LCR005-%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/"/>
    <url>/2024/03/07/posts/LCR005-%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="剑指offer（专项突破版）1-2-二进制"><a href="#剑指offer（专项突破版）1-2-二进制" class="headerlink" title="剑指offer（专项突破版）1.2 二进制"></a>剑指offer（专项突破版）1.2 二进制</h2><h3 id="题目链接：LCR005-最大单词长度乘积"><a href="#题目链接：LCR005-最大单词长度乘积" class="headerlink" title="题目链接：LCR005-最大单词长度乘积"></a>题目链接：<a href="https://leetcode.cn/problems/aseY1I/description/">LCR005-最大单词长度乘积</a></h3><h3 id="方法1：用哈希表记录字符串中出现的字符"><a href="#方法1：用哈希表记录字符串中出现的字符" class="headerlink" title="方法1：用哈希表记录字符串中出现的字符"></a>方法1：用哈希表记录字符串中出现的字符</h3><p>分析：蛮力。对每一个字符串，存储一个记录每个字符的哈希表；对每个字符串对，比较其哈希表。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> maxProduct(vector&lt;<span class="hljs-built_in">string</span>&gt;&amp; words) &#123;<br>        <span class="hljs-comment">// 定义哈希表</span><br>        <span class="hljs-built_in">bool</span> table[<span class="hljs-number">1000</span>][<span class="hljs-number">26</span>] = &#123;<span class="hljs-literal">false</span>&#125;;<br>        <span class="hljs-comment">// 记录每个字符串包含字符的情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; words.size();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;j &lt; words[i].length();j++)&#123;<br>                <span class="hljs-built_in">string</span> word = words[i];<br>                <span class="hljs-built_in">int</span> index = word[j] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                table[i][index] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//记录最大值</span><br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 每一对字符串的情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; words.size()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = i+<span class="hljs-number">1</span>;j &lt; words.size();j++)&#123;<br>                <span class="hljs-built_in">int</span> k;<br>                <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>;k &lt; <span class="hljs-number">26</span>;k++)&#123;<br>                    <span class="hljs-keyword">if</span>(table[i][k] &amp;&amp; table[j][k])&#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 找到不包含相同字符的两个字符串</span><br>                <span class="hljs-keyword">if</span>(k == <span class="hljs-number">26</span>)&#123;<br>                    <span class="hljs-built_in">int</span> temp = words[i].length()*words[j].length();<br>                    <span class="hljs-keyword">if</span>(temp &gt; res)&#123;<br>                        res = temp;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong> 第1步，初始化每个字符串对应的哈希表。如果数组words的长度为n，平均每个字符串的长度为k，那么初始化哈希表的时间复杂度是O（n<sub>k</sub>）。第2步，根据哈希表判断每对字符串是否包含相同的字符。总共有O（n<sub>2</sub>）对字符串，判断每对字符串是否包含相同的字符需要的时间为O（1），因此这一步的时间复杂度是O（n<sub>2</sub>）。于是这种解法的总体时间复杂度是O（n<sub>k</sub>+n<sub>2</sub>）。</p><p><strong>结果：</strong> </p><p><img src="/2024/03/07/posts/LCR005-%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/image.png" alt="方法1结果"></p><h3 id="方法2：用整数的二进制数位记录字符串中出现的字符"><a href="#方法2：用整数的二进制数位记录字符串中出现的字符" class="headerlink" title="方法2：用整数的二进制数位记录字符串中出现的字符"></a>方法2：用整数的二进制数位记录字符串中出现的字符</h3><blockquote><p>分析：可以用一个int型整数记录某个字符串中出现的字符。如果字符串中包含’a’，那么整数最右边的数位为1；如果字符串中包含’b’，那么整数的倒数第2位为1，其余以此类推。这样做的好处是能更快地判断两个字符串是否包含相同的字符。如果两个字符串中包含相同的字符，那么它们对应的整数相同的某个数位都为1，两个整数的与运算将不会等于0。如果两个字符串没有相同的字符，那么它们对应的整数的与运算的结果等于0。</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> maxProduct(vector&lt;<span class="hljs-built_in">string</span>&gt;&amp; words) &#123;<br>        <span class="hljs-comment">// 定义哈希表</span><br>        <span class="hljs-built_in">int</span> table[<span class="hljs-number">1000</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-comment">// 记录每个字符串包含字符的情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; words.size();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;j &lt; words[i].length();j++)&#123;<br>                <span class="hljs-built_in">string</span> word = words[i];<br>                <span class="hljs-built_in">int</span> index = word[j] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                table[i] |= <span class="hljs-number">1</span> &lt;&lt; index;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//记录最大值</span><br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 每一对字符串的情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; words.size()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = i+<span class="hljs-number">1</span>;j &lt; words.size();j++)&#123;<br>                <span class="hljs-comment">// 位运算判断两个字符串是否包含相同字符</span><br>                <span class="hljs-keyword">if</span>((table[i] &amp; table[j]) == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-built_in">int</span> temp = words[i].length()*words[j].length();<br>                    <span class="hljs-keyword">if</span>(temp &gt; res)&#123;<br>                        res = temp;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong> 如果数组words的长度为n，平均每个字符串的长度为k，那么这种解法的时间复杂度是O（nk+n2），空间复杂度是O（n）。虽然两种解法的时间复杂度和空间复杂度是同一个量级的，但前面的解法在判断两个字符串是否包含相同的字符时，可能需要26次布尔运算，而新的解法只需要1次位运算，因此新的解法的时间效率更高。</p><p><strong>结果：</strong> </p><p><img src="/2024/03/07/posts/LCR005-%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/image-1.png" alt="方法2结果"></p><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><ol><li>C++数组静态大小的数组不能使用变量来初始化，因为数组的大小必须在编译时就确定。即，这道题定义table时，如果写成<code>bool table[1words.size()][26] = &#123;false&#125;;</code>会报错。</li><li>“|&#x3D;”运算符：“a |&#x3D; b”表示“a等于a与b的或”。</li><li>在C++中，位运算符的优先级高于相等运算符。在<code>if((table[i] &amp; table[j]) == 0)</code>中如果去掉<code>(table[i] &amp; table[j])</code>的括号，会先进行<code>table[j]) == 0</code>的运算，导致结果错误。</li><li>定义变量长度数组可以用vector。<ul><li><a href="https://blog.csdn.net/yjunyu/article/details/77728410">vector的几种初始化及赋值方式</a></li><li><a href="https://blog.csdn.net/sinat_36053757/article/details/71053706">C++——二维vector初始化大小方法</a></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>整数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR004.只出现一次的数字</title>
    <link href="/2024/03/05/posts/LCR004-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2024/03/05/posts/LCR004-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="剑指offer（专项突破版）1-2-二进制"><a href="#剑指offer（专项突破版）1-2-二进制" class="headerlink" title="剑指offer（专项突破版）1.2 二进制"></a>剑指offer（专项突破版）1.2 二进制</h2><h3 id="题目链接：LCR004-只出现一次的数字"><a href="#题目链接：LCR004-只出现一次的数字" class="headerlink" title="题目链接：LCR004-只出现一次的数字"></a>题目链接：<a href="https://leetcode.cn/problems/WGki4K/description/">LCR004-只出现一次的数字</a></h3><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>分析：直接的想法是定义一个map，统计其次数。这里使用unordered_map。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//定义一个unordered_map，记录出现的数字及其次数</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; dict;<br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            dict[nums[i]]++;<br>        &#125;<br>        <span class="hljs-comment">//结果</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator iter;<br>        <span class="hljs-keyword">for</span>(iter=dict.<span class="hljs-built_in">begin</span>();iter!=dict.<span class="hljs-built_in">end</span>();iter++)&#123;<br>            <span class="hljs-keyword">if</span>(iter-&gt;second == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> iter-&gt;first;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong> 首先，遍历整个输入数组nums并在unordered_map中记录每个数字及其出现的次数。这个过程的时间复杂度为O(n)，其中n是数组nums的大小。接下来，遍历unordered_map以找到出现次数为1的数字。由于unordered_map中最多包含n个不同的数字，因此这个遍历过程的时间复杂度为O(n)。<br>综上所述，这个算法的总时间复杂度是O(n)。</p><p><strong>结果：</strong></p><p><img src="/2024/03/05/posts/LCR004-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/image.png" alt="方法1结果"></p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><blockquote><p>这个题目有一个简化版的类似的题目“输入数组中除一个数字只出现一次之外其他数字都出现两次，请找出只出现一次的数字”。任何一个数字异或它自己的结果都是0。如果将数组中所有数字进行异或运算，那么最终的结果就是那个只出现一次的数字。</p><p>在这个题目中只有一个数字出现了一次，其他数字出现了3次。相同的3个数字异或的结果是数字本身，但是将数组中所有数字进行异或运算并不能消除出现3次的数字。因此，需要想其他办法。</p><p>一个整数是由32个0或1组成的。我们可以将数组中所有数字的同一位置的数位相加。如果将出现3次的数字单独拿出来，那么这些出现了3次的数字的任意第i个数位之和都能被3整除。因此，如果数组中所有数字的第i个数位相加之和能被3整除，那么只出现一次的数字的第i个数位一定是0；如果数组中所有数字的第i个数位相加之和被3除余1，那么只出现一次的数字的第i个数位一定是1。这样只出现一次的任意第i个数位可以由数组中所有数字的第i个数位之和推算出来。当我们知道一个整数任意一位是0还是1之后，就可以知道它的数值。</p></blockquote><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> singleNumber(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//记录每位和的数组，题目规定在int范围内</span><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span>[<span class="hljs-number">32</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-comment">//累加</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.size();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">32</span>;j++)&#123;<br>                <span class="hljs-keyword">sum</span>[j] += (nums[i] &gt;&gt; (<span class="hljs-number">31</span>-j)) &amp; <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//结果</span><br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">32</span>;i++)&#123;<br>            res = (res &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-keyword">sum</span>[i] % <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="/2024/03/05/posts/LCR004-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/image-1.png" alt="方法2结果"></p><h3 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h3><blockquote><p>题目：输入一个整数数组，数组中只有一个数字出现m次，其他数字都出现n次。请找出那个唯一出现m次的数字。假设m不能被n整除。</p><p>分析：解决面试题4的方法可以用来解决同类型的问题。如果数组中所有数字的第i个数位相加之和能被n整除，那么出现m次的数字的第i个数位一定是0；否则出现m次的数字的第i个数位一定是1。</p></blockquote><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><p><a href="https://blog.csdn.net/jingyi130705008/article/details/82633778">map与unordered_map</a></p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>整数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR003.比特位计数</title>
    <link href="/2024/03/04/posts/LCR003-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
    <url>/2024/03/04/posts/LCR003-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="剑指offer（专项突破版）1-2-二进制"><a href="#剑指offer（专项突破版）1-2-二进制" class="headerlink" title="剑指offer（专项突破版）1.2 二进制"></a>剑指offer（专项突破版）1.2 二进制</h2><h3 id="题目链接：LCR003-比特位计数"><a href="#题目链接：LCR003-比特位计数" class="headerlink" title="题目链接：LCR003-比特位计数"></a>题目链接：<a href="https://leetcode.cn/problems/w3tCBm/description/">LCR003-比特位计数</a></h3><h3 id="方法1：借鉴两数相除题目的思想"><a href="#方法1：借鉴两数相除题目的思想" class="headerlink" title="方法1：借鉴两数相除题目的思想"></a>方法1：借鉴两数相除题目的思想</h3><p>分析：一种直接的想法是先将0-n之间的每个数的二进制表示求出来，再数其中1的个数，但这样循环次数过多，应该会超时。于是想到可以借鉴LCR001-两数相除这道题的思想。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//自己第一次写的代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">//对于每个数字i</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++)&#123;<br>            <span class="hljs-type">int</span> num = i;<br>            <span class="hljs-keyword">while</span>(num &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> j;<br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j &lt;= num;)&#123;<br>                    j += j;<br>                &#125;<br>                num -= j/<span class="hljs-number">2</span>;<br>                vec[i]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vec;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong></p><ul><li>外层循环for(int i &#x3D; 0;i &lt;&#x3D; n;i++)遍历了从0到n的所有数字，因此时间复杂度为O(n)。</li><li>内层循环使用了一个while循环和一个for循环：<ul><li><p>while循环中，每次将num除以2，直到num变为0。最坏情况下，这个过程需要O(logn)次操作。</p></li><li><p>for循环中，每次将j乘以2，直到j超过num。因此，这个循环的时间复杂度也是O(logn)。</p><p>因此，内层循环的时间复杂度可以视为O(logn)。</p></li></ul></li></ul><p>整体来看，外层循环的时间复杂度是O(n)，内层循环的时间复杂度是O(logn)。由于内层循环是在外层循环内部执行的，所以内层循环的总时间复杂度是O(nlogn)。</p><p><strong>结果：</strong></p><img src="/2024/03/04/posts/LCR003-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/03/04/posts/LCR003-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/2024-03-04-19-53-29.png" class title="方法1结果"><h3 id="方法2：简单计算每个整数的二进制形式中1的个数"><a href="#方法2：简单计算每个整数的二进制形式中1的个数" class="headerlink" title="方法2：简单计算每个整数的二进制形式中1的个数"></a>方法2：简单计算每个整数的二进制形式中1的个数</h3><blockquote><p>计算整数i的二进制形式中1的个数有多种不同的方法，其中一种比较高效的方法是每次用“i&amp;（i-1）”将整数i的最右边的1变成0。整数i减去1，那么它最右边的1变成0。如果它的右边还有0，则右边所有的0都变成1，而其左边所有位都保持不变。下面对i和i-1进行位与运算，相当于将其最右边的1变成0。</p></blockquote><p><strong>时间复杂度分析：</strong> 每次将最右边的1变成0，直到这个数变为0。如果一个整数共有k位，那么它的二进制形式中可能有O（k）个1。在上述代码中，while循环中的代码对每个整数将执行O（k）次，因此，上述代码的时间复杂度是O（nk）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">//对于每个数字i</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++)&#123;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-keyword">while</span>(j != <span class="hljs-number">0</span>)&#123;<br>                vec[i]++;<br>                j = j &amp; (j<span class="hljs-number">-1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vec;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>结果：</strong></p><img src="/2024/03/04/posts/LCR003-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/03/04/posts/LCR003-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/2024-03-04-20-07-37.png" class title="方法2结果"><h3 id="方法3：根据“i-（i-1）”计算i的二进制形式中1的个数"><a href="#方法3：根据“i-（i-1）”计算i的二进制形式中1的个数" class="headerlink" title="方法3：根据“i&amp;（i-1）”计算i的二进制形式中1的个数"></a>方法3：根据“i&amp;（i-1）”计算i的二进制形式中1的个数</h3><blockquote><p>根据前面的分析可知，“i&amp;（i-1）”将i的二进制形式中最右边的1变成0，也就是说，整数i的二进制形式中1的个数比“i&amp;（i-1）”的二进制形式中1的个数多1。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">//对于每个数字i</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>            vec[i] = vec[i &amp; (i<span class="hljs-number">-1</span>)] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vec;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong> 不管整数i的二进制形式中有多少个1，上述代码只根据O（1）的时间就能得出整数i的二进制形式中1的数目，因此时间复杂度是O（n）。</p><p><strong>结果：</strong></p><img src="/2024/03/04/posts/LCR003-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/03/04/posts/LCR003-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/2024-03-04-20-18-46.png" class title="方法3结果"><h3 id="方法4：根据“i-2”计算i的二进制形式中1的个数"><a href="#方法4：根据“i-2”计算i的二进制形式中1的个数" class="headerlink" title="方法4：根据“i&#x2F;2”计算i的二进制形式中1的个数"></a>方法4：根据“i&#x2F;2”计算i的二进制形式中1的个数</h3><blockquote><p>如果正整数i是一个偶数，那么i相当于将“i&#x2F;2”左移一位的结果，因此偶数i和“i&#x2F;2”的二进制形式中1的个数是相同的。如果i是奇数，那么i相当于将“i&#x2F;2”左移一位之后再将最右边一位设为1的结果，因此奇数i的二进制形式中1的个数比“i&#x2F;2”的1的个数多1。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">//对于每个数字i</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                vec[i] = vec[i/<span class="hljs-number">2</span>];<br>            &#125;   <span class="hljs-comment">//i是偶数  </span><br>            <span class="hljs-keyword">else</span>&#123;<br>                vec[i] = vec[i/<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br>            &#125;   <span class="hljs-comment">//i是奇数</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> vec;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong> O（n）。</p><p><strong>结果：</strong></p><img src="/2024/03/04/posts/LCR003-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/03/04/posts/LCR003-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/2024-03-04-20-25-42.png" class title="方法4结果1"><p>书上的代码使用“i&gt;&gt;1”计算“i&#x2F;2”，用“i&amp;1”计算“i%2”，因为位运算比除法运算和求余运算更高效。这个题目是关于位运算的，因此应该尽量运用位运算优化代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">//对于每个数字i</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>            vec[i] = vec[i &gt;&gt; <span class="hljs-number">1</span>] + (i &amp; <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> vec;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>结果：</strong></p><img src="/2024/03/04/posts/LCR003-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/03/04/posts/LCR003-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/2024-03-04-20-28-56.png" class title="方法4结果2"><p>可以看出使用“i&gt;&gt;1”计算“i&#x2F;2”，用“i&amp;1”计算“i%2”确实快了很多。</p><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><p><a href="https://blog.csdn.net/yjunyu/article/details/77728410">vector的几种初始化及赋值方式</a></p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>整数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR002.二进制求和</title>
    <link href="/2024/03/01/posts/LCR002-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/"/>
    <url>/2024/03/01/posts/LCR002-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="剑指offer（专项突破版）1-2-二进制"><a href="#剑指offer（专项突破版）1-2-二进制" class="headerlink" title="剑指offer（专项突破版）1.2 二进制"></a>剑指offer（专项突破版）1.2 二进制</h2><h3 id="题目链接：LCR002-二进制求和"><a href="#题目链接：LCR002-二进制求和" class="headerlink" title="题目链接：LCR002-二进制求和"></a>题目链接：<a href="https://leetcode.cn/problems/JFETK5/description/">LCR002-二进制求和</a></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//自己第一遍写的代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">addBinary</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> a, <span class="hljs-built_in">string</span> b</span>)</span> &#123;<br>        <span class="hljs-comment">//两个字符串长度不同，补零</span><br>        <span class="hljs-keyword">if</span>(a.length() &lt; b.length())&#123;<br>            swap(a,b);<br>        &#125;<br>        <span class="hljs-built_in">int</span> diff = a.length()-b.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; diff;i++)&#123;<br>            b = <span class="hljs-string">&quot;0&quot;</span> + b;<br>        &#125;<br>        <br>        <span class="hljs-built_in">string</span> res = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-comment">//结果字符串</span><br>        <span class="hljs-built_in">int</span> carry = <span class="hljs-number">0</span>;    <span class="hljs-comment">//进位</span><br><br>        <span class="hljs-comment">//逐位相加</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = a.length()<span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-built_in">int</span> sum = (a[i]-<span class="hljs-string">&#x27;0&#x27;</span>) + (b[i]-<span class="hljs-string">&#x27;0&#x27;</span>) + carry;<br>            <span class="hljs-built_in">int</span> cur = sum % <span class="hljs-number">2</span>;<br>            carry = sum / <span class="hljs-number">2</span>;<br>            res = to_string(cur) + res;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>)&#123;<br>            res = <span class="hljs-string">&quot;1&quot;</span> + res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>书中的思路：i、j分别指向两个字符串的第i、j个位置，不在一开始将两个字符串长度补齐，而是在相加过程中判断。按照书中的思路重新写一遍代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">addBinary</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> a, <span class="hljs-built_in">string</span> b</span>)</span> &#123;<br>        <span class="hljs-built_in">string</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">int</span> carry = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// i、j分别指向字符串a、b的最后一个字符</span><br>        <span class="hljs-built_in">int</span> i = a.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> j = b.length() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//逐位相加</span><br>        <span class="hljs-keyword">while</span>(i &gt;=<span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">int</span> digitA = i&gt;=<span class="hljs-number">0</span> ? a[i--]-<span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">int</span> digitB = j&gt;=<span class="hljs-number">0</span> ? b[j--]-<span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">int</span> sum = digitA + digitB + carry;<br>            carry = sum / <span class="hljs-number">2</span>;<br>            res = to_string(sum % <span class="hljs-number">2</span>) + res;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>)&#123;<br>            res = <span class="hljs-string">&quot;1&quot;</span> + res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="结果对比："><a href="#结果对比：" class="headerlink" title="结果对比："></a>结果对比：</h3><p>方法1：</p><img src="/2024/03/01/posts/LCR002-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/03/01/posts/LCR002-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/2024-03-04-19-00-48.png" class title="方法1"><p>方法2：</p><img src="/2024/03/01/posts/LCR002-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/03/01/posts/LCR002-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/2024-03-04-19-04-55.png" class title="方法2"><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><h4 id="C语言中的转换"><a href="#C语言中的转换" class="headerlink" title="C语言中的转换"></a>C语言中的转换</h4><ol><li>使用标准库函数atoi和atof：</li></ol><ul><li>atoi函数将字符串转换为整数</li><li>atof函数将字符串转换为浮点数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span> <span class="hljs-comment">//包含atoi、atof函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  <span class="hljs-comment">//包含printf函数</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;12345&quot;</span>;<br>    <span class="hljs-type">int</span> num = <span class="hljs-built_in">atoi</span>(str);<br>    <span class="hljs-type">float</span> float_num = <span class="hljs-built_in">atof</span>(str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num: %d\n&quot;</span>,num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;float_num: %f\n&quot;</span>,float_num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>  结果：  <img src="/2024/03/01/posts/LCR002-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/03/01/posts/LCR002-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/2024-03-04-19-02-24.png" class title="字符串转数值"></li></ul><ol><li>使用标准库函数sprintf和sscanf</li></ol><ul><li><p>sprintf函数将格式化的数据写入字符串。</p></li><li><p>sscanf函数从字符串中读取格式化的数据。</p> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs perl"> <span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br><span class="hljs-keyword">int</span> main() &#123;<br>    char str[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">12345</span>;<br>    float float_num = <span class="hljs-number">123.45</span>;<br>    <span class="hljs-keyword">sprintf</span>(str, <span class="hljs-string">&quot;%d&quot;</span>, num);<br>    sscanf(str, <span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;str: %s\n&quot;</span>,str);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;num: %d\n&quot;</span>,num);<br><br>    <span class="hljs-keyword">sprintf</span>(str, <span class="hljs-string">&quot;%f&quot;</span>, float_num);<br>    sscanf(str, <span class="hljs-string">&quot;%f&quot;</span>, &amp;float_num);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;str: %s\n&quot;</span>,str);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;float_num: %f\n&quot;</span>,float_num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><img src="/2024/03/01/posts/LCR002-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/03/01/posts/LCR002-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/2024-03-04-19-03-02.png" class title="结果"><p>因为浮点数在内存中的表示方式和人类理解的十进制表示方式存在微小的差异，导致在转换为字符串和再次从字符串转换回浮点数时可能会引入精度损失。这是由于浮点数的存储方式决定的，它们以二进制形式存储，并且无法精确地表示一些十进制小数。</p><p>解决这个问题的一种方法是使用精确度格式说明符来限制输出的小数位数。例如，对于sprintf，可以使用”%.2f”来限制输出到小数点后两位。这样可以减小精度损失。</p></li></ul><h4 id="C-中的转换"><a href="#C-中的转换" class="headerlink" title="C++中的转换"></a>C++中的转换</h4><ol><li><p>使用字符串流 stringstream：</p><p>使用 std::stringstream 类可以很方便地在字符串和数值之间进行转换。可以使用 &lt;&lt; 操作符将数值插入到字符串流中，或者使用 &gt;&gt; 操作符从字符串流中提取数值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>     std::string str = <span class="hljs-string">&quot;12345&quot;</span>;<br>     <span class="hljs-type">int</span> num;<br>     std::<span class="hljs-built_in">stringstream</span>(str) &gt;&gt; num; <span class="hljs-comment">// 将字符串转换为整数</span><br>     std::cout &lt;&lt; <span class="hljs-string">&quot;num: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;<br>     <br>     <span class="hljs-type">int</span> another_num = <span class="hljs-number">54321</span>;<br>     std::stringstream stream;<br>     stream &lt;&lt; another_num; <span class="hljs-comment">// 将整数转换为字符串</span><br>     std::string result = stream.<span class="hljs-built_in">str</span>();<br>     std::cout &lt;&lt; <span class="hljs-string">&quot;result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br> <br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br><br></code></pre></td></tr></table></figure></li><li><p>使用标准库函数 stoi 和 to_string：</p><p>C++11 引入了 std::stoi 和 std::to_string 函数，分别用于将字符串转换为整数和将整数转换为字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>     std::string str = <span class="hljs-string">&quot;12345&quot;</span>;<br>     <span class="hljs-type">int</span> num = std::<span class="hljs-built_in">stoi</span>(str); <span class="hljs-comment">// 将字符串转换为整数</span><br>     std::cout &lt;&lt; <span class="hljs-string">&quot;num: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;<br>     <br>     <span class="hljs-type">int</span> another_num = <span class="hljs-number">54321</span>;<br>     std::string result = std::<span class="hljs-built_in">to_string</span>(another_num); <span class="hljs-comment">// 将整数转换为字符串</span><br>     std::cout &lt;&lt; <span class="hljs-string">&quot;result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>     <br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>整数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
      <tag>字符串与数值的转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pa0</title>
    <link href="/2024/01/22/posts/pa0/"/>
    <url>/2024/01/22/posts/pa0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="PA0实验记录"><a href="#PA0实验记录" class="headerlink" title="PA0实验记录"></a>PA0实验记录</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">bash -c &#x27;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse&quot;</span> &gt; <span class="hljs-string">/etc/apt/sources.list</span>&#x27;<br><br>/* 解释<br>这条命令是在 Bash shell 中执行一个命令：<br>    bash: 启动 Bash shell，一个常见的 Unix/Linux shell。<br>    -c: 选项表示后面跟随着要执行的命令。<br>    &#x27;<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse&quot;</span> &gt; <span class="hljs-string">/etc/apt/sources.list</span>&#x27;: 这是要执行的命令。解释如下：<br>    <span class="hljs-keyword">echo</span>: 输出指定的文本。<br>    <span class="hljs-string">&quot;deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse&quot;</span>: 这是要输出的文本，通常是用于配置 APT <span class="hljs-params">(Advanced Package Tool)</span> 软件包管理器的源列表。这特定的源指向阿里云的 Ubuntu 软件包镜像。<br>        &gt; <span class="hljs-string">/etc/apt/sources.list</span>: 将上述输出的文本写入文件 <span class="hljs-string">/etc/apt/sources.list</span>，这是 APT 的主要源列表文件。<br><br>总的来说，这条命令的目的是将特定的 Ubuntu 软件包源地址添加到系统的 APT 源列表中，以便在安装或更新软件包时使用该源。<br>*/<br></code></pre></td></tr></table></figure><p><code>sudo bash -c &#39;echo &quot;deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse&quot; &gt; /etc/apt/sources.list&#39;</code></p><img src="/2024/01/22/posts/pa0/01/22/posts/pa0/2024-01-22-11-05-26.png" class><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 粘贴图片时遇到问题，需要先按照xclip</span><br>sudo apt-<span class="hljs-keyword">get</span> upgrade<br>sudo apt install xclip<br></code></pre></td></tr></table></figure><p>无法安装libreadline-dev</p><p><a href="https://www.cnblogs.com/Wishengine/p/17446121.html">解决方案</a></p><img src="/2024/01/22/posts/pa0/01/22/posts/pa0/2024-01-22-11-57-35.png" class><p><a href="https://blog.csdn.net/qq_36393978/article/details/128659642">参考方案</a></p><h2 id="选做题"><a href="#选做题" class="headerlink" title="选做题"></a>选做题</h2><ol><li>上述各个命令除了cd之外都能找到它们的manpage, 这是为什么? 如果你思考后仍然感到困惑, 试着到互联网上寻找答案.<blockquote><p>在典型的 Unix&#x2F;Linux 系统中，cd 命令是一个内置命令（built-in command），而不是一个外部的可执行文件。因此，它没有对应的 man 页面。</p><p>其他命令如 ls、cp、mv、rm 等通常是外部的可执行文件，它们存在于系统的可执行文件路径中（通常是 &#x2F;bin、&#x2F;usr&#x2F;bin 等目录）。因此，这些命令有对应的 man 页面，可以通过 man 命令查看。</p><p>在 Unix&#x2F;Linux 中，内置命令是由 shell 直接处理的，而不是通过调用外部的可执行文件。这使得内置命令更加高效，因为不需要启动新的进程。相反，外部命令需要创建新的进程来执行。</p><p>要查看 cd 命令的文档，您可以使用 help cd 或 man bash（查看 Bash shell 的手册），因为 cd 是 Bash shell 的内置命令。这将提供与 cd 相关的信息。<br><a href="https://blog.csdn.net/fakejvruo/article/details/123951266">https://blog.csdn.net/fakejvruo/article/details/123951266</a></p></blockquote></li></ol><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><img src="/2024/01/22/posts/pa0/01/22/posts/pa0/2024-01-30-18-30-38.png" class><p>tmux如何使终端滚动？如何实现滚动条？</p>]]></content>
    
    
    <categories>
      
      <category>PA实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCR001.两数相除</title>
    <link href="/2023/12/05/posts/LCR001-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/"/>
    <url>/2023/12/05/posts/LCR001-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="剑指offer（专项突破版）1-1-整数的基础知识"><a href="#剑指offer（专项突破版）1-1-整数的基础知识" class="headerlink" title="剑指offer（专项突破版）1.1 整数的基础知识"></a>剑指offer（专项突破版）1.1 整数的基础知识</h2><h3 id="题目链接：LCR001-两数相除"><a href="#题目链接：LCR001-两数相除" class="headerlink" title="题目链接：LCR001-两数相除"></a>题目链接：<a href="https://leetcode.cn/problems/xoh6Oh/description/">LCR001-两数相除</a></h3><p>书上的讲解很清晰，不过好像漏掉了<code>a=-2147483648 b=1</code>的情况。不知道还有没有其他方法进一步优化，留作以后更新。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> divide(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) &#123;<br>        <span class="hljs-comment">//判断边界</span><br>        <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0x80000000</span> &amp;&amp; b == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> INT_MAX;<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> a;<br>        <span class="hljs-comment">//判断结果符号、都变成负数</span><br>        <span class="hljs-built_in">int</span> flag = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>)&#123;<br>            flag--;<br>            a = -a;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(b &gt; <span class="hljs-number">0</span>)&#123;<br>            flag--;<br>            b = -b;<br>        &#125;<br>        <span class="hljs-comment">//两层循环</span><br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(a &lt;= b)&#123;<br>            <span class="hljs-comment">//暂存除数</span><br>            <span class="hljs-built_in">int</span> divisor = b;<br>            <span class="hljs-built_in">int</span> quotient = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(divisor &gt;= <span class="hljs-number">0xc0000000</span> &amp;&amp; a &lt;= divisor + divisor)&#123;<br>                quotient += quotient;<br>                divisor += divisor;<br>            &#125;<br>            <span class="hljs-comment">//此时被除数刚刚大于除数</span><br>            res += quotient;<br>            a -= divisor;<br>        &#125;<br>        <span class="hljs-comment">//判断结果符号</span><br>        <span class="hljs-keyword">return</span> flag==<span class="hljs-number">1</span> ? -res : res;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>整数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/12/04/diaries/hello-world/"/>
    <url>/2023/12/04/diaries/hello-world/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><img src="/2023/12/04/diaries/hello-world/12/04/diaries/hello-world/nku.jpg" class title="nku"><p>记录一下，博客第一天。</p><p>以后要多多创作！</p>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
